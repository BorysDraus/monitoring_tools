# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MonitoringTools
                                 A QGIS plugin
 Wetlands Green Life Monitoring Tools
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-11-11
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Borys Draus
        email                : borys.draus@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from qgis.core import QgsVectorLayer, QgsFeature, QgsField, QgsCoordinateReferenceSystem,QgsCoordinateTransform, QgsGeometry, QgsPointXY, QgsField, QgsProject, Qgis, QgsProcessingFeedback, QgsExpression, edit, QgsExpressionContext, QgsExpressionContextUtils
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QLineEdit, QToolBar
from PyQt5.QtWidgets import QMessageBox, QWidget
from PyQt5.QtCore import QVariant, Qt
from .TimerMessageBox import CustomMessageBox
# Initialize Qt resources from file resources.py
from .resources import *

from qgis._core import QgsWkbTypes, QgsMapLayer, QgsVectorFileWriter, QgsVectorDataProvider, QgsField, QgsRectangle, \
    QgsMapLayerProxyModel, QgsProcessing



from .atribute_table_manager import AtributeTableManager

# Import the code for the DockWidget
from .monitoring_tools_dockwidget import MonitoringToolsDockWidget
import sqlite3
import re
import os
import csv
from datetime import datetime

class MonitoringTools:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'MonitoringTools_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&MonitoringTools')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'MonitoringTools')
        self.toolbar.setObjectName(u'MonitoringTools')

        #print "** INITIALIZING MonitoringTools"

        self.pluginIsActive = False
        self.dockwidget = None


    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('MonitoringTools', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/monitoring_tools/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'MonitoringTools'),
            callback=self.run,
            parent=self.iface.mainWindow())



    #--------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING MonitoringTools"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD MonitoringTools"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&MonitoringTools'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar



    def appendDataToLabel(self, text_message, QLabel):
        text = QLabel.text()
        if text:
            QLabel.setText(text + "\n" + text_message)
        else:
            QLabel.setText(text_message)


    # Wskazanie bazy danych
    def selectDbaseDirectory(self):
        filename = QFileDialog.getOpenFileName(self.dockwidget, "Wskaż bazę danych: *.db", "", "*.db")
        if isinstance(filename, tuple):
            self.dockwidget.lineEdit_dBase_directory.setText(filename[0])
            # Wskazanie lokalizacji folderów z adresem
            dirnameOfCatalog = self.resolveDir('info')
            dirOfFile = dirnameOfCatalog + "/base_address.txt"
            file = open(dirOfFile, "w+")
            file.write(str(filename[0]))
            file.close()


    # Ladowanie adresu bazy po uruchomieniu aplikacji
    def dBaseDirectoryLoad(self):
        dirnameOfCatalog = self.resolveDir('info')
        dirOfFile = dirnameOfCatalog + "/base_address.txt"
        if os.path.isfile(dirOfFile):
            with open(dirOfFile) as f:
                f = f.readline()
                if os.path.exists(str(f)):
                    self.dockwidget.lineEdit_dBase_directory.setText(str(f))


    # Metoda zwraca lokalizację wskazanego folderu lub pliku
    def resolveDir(self, name, basepath=None):
        if not basepath:
            basepath = os.path.dirname(os.path.realpath(__file__))
        return os.path.join(basepath, name)


    # Method for cear info label and warning label
    def clear_info_labels(self):
        self.dockwidget.label_info.setText("")
        self.dockwidget.label_warning.setText("")


    def comboBoxAraesPolygonSelectAction(self):
        self.dockwidget.mMapLayerComboBoxAraesPolygon.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.dockwidget.comboBoxFieldsName.clear()
        layer = self.dockwidget.mMapLayerComboBoxAraesPolygon.currentLayer()
        if layer != None:
            # Get the list of field names (column names)
            field_names = [field.name() for field in layer.fields()]
            self.dockwidget.comboBoxFieldsName.addItems(field_names)



    # T_0101
    def generatePointLayer(self):

        # Clear info labels
        self.clear_info_labels()

        # Dbase address
        d_base = str(self.dockwidget.lineEdit_dBase_directory.text()).replace('\\', '/')

        # Clear warning massage
        self.dockwidget.label_warning.setText("")

        # check if base exist
        if not (str(d_base)):
            self.dockwidget.label_warning.setText("Nie wskazano bazy danych!")
            return False

        # Split dbase file name
        base_name = os.path.splitext(os.path.basename(d_base))[0]
        base_name_ext = os.path.basename(d_base)

        # Declare connections
        conn = sqlite3.connect(d_base)
        cursor = conn.cursor()

        # DBASE
        self.appendDataToLabel("", self.dockwidget.label_info)
        self.appendDataToLabel("BAZA DANYCH", self.dockwidget.label_info)
        # File name
        self.appendDataToLabel(base_name_ext, self.dockwidget.label_info)
        # Version
        cursor.execute("PRAGMA user_version;")
        sqlite_version = cursor.fetchone()[0]
        self.appendDataToLabel("Wersja bazy danych: " + str(sqlite_version), self.dockwidget.label_info)
        # Date range
        cursor.execute("SELECT MIN(data_oceny) FROM stanowisko_rok WHERE data_oceny IS NOT NULL AND data_oceny <> ''")
        date_from = cursor.fetchone()[0]
        cursor.execute("SELECT MAX(data_oceny) FROM stanowisko_rok WHERE data_oceny IS NOT NULL AND data_oceny <> ''")
        date_to = cursor.fetchone()[0]
        if date_from is None:
            date_from = "?"
        if date_to is None:
            date_to = "?"
        self.appendDataToLabel("Zakres dat: " + date_from + "  -  " + date_to, self.dockwidget.label_info)

        # EXPERT
        self.appendDataToLabel("", self.dockwidget.label_info)
        self.appendDataToLabel("DANE WYKONAWCY", self.dockwidget.label_info)
        cursor.execute(
            "SELECT DISTINCT stanowisko_rok_ekspert.email, sl_ekspert.imie, sl_ekspert.nazwisko, sl_ekspert.instytucja_cd, sl_ekspert.telefon "
            "FROM stanowisko_rok_ekspert "
            "INNER JOIN sl_ekspert on stanowisko_rok_ekspert.email = sl_ekspert.email")
        rows = cursor.fetchall()
        for row in rows:
            self.appendDataToLabel("Wykonawca: " + row[1] + " " + row[2], self.dockwidget.label_info)
            self.appendDataToLabel(row[3], self.dockwidget.label_info)
            self.appendDataToLabel("Tel: " + row[4], self.dockwidget.label_info)
            self.appendDataToLabel("E-mail: " + row[0], self.dockwidget.label_info)

        # CALCULATED COORDINATES INFORMATIONS
        self.appendDataToLabel("", self.dockwidget.label_info)
        self.appendDataToLabel("KARTY POWIERZCHNI MONITORINGOWYCH", self.dockwidget.label_info)
        cursor.execute("SELECT * FROM stanowisko_rok")
        rows = cursor.fetchall()
        self.appendDataToLabel("Liczba powierzchni: " + str(len(rows)), self.dockwidget.label_info)
        cursor.execute("SELECT * FROM stanowisko_rok WHERE x != '' and y != '' and x > 0 and y >0")
        rows = cursor.fetchall()
        self.appendDataToLabel("Liczba powierzchni ze współrzędnymi: " + str(len(rows)), self.dockwidget.label_info)

        # Information about established and rejected surfaces
        cursor.execute("SELECT COUNT(*) FROM stanowisko_rok WHERE stanowisko_rok.rezygnacja_fl != 1;")
        row_count = cursor.fetchone()[0]
        self.appendDataToLabel("Liczba powierzchni założonych: " + str(row_count), self.dockwidget.label_info)
        cursor.execute("SELECT COUNT(*) FROM stanowisko_rok WHERE stanowisko_rok.rezygnacja_fl = 1;")
        row_count = cursor.fetchone()[0]
        self.appendDataToLabel("Liczba powierzchni odrzuconych: " + str(row_count), self.dockwidget.label_info)

        # DATA FOR POINT LAYER
        cursor.execute("SELECT stanowisko.stanowisko_nr,"
                       " stanowisko.stanowisko_nm,"
                       " stanowisko.siedlisko_cd,"
                       " stanowisko.siedlisko_plan_cd,"
                       " stanowisko.siedlisko_lp_cd,"
                       " stanowisko.zgodnosc_cd,"
                       " stanowisko_rok.x,"
                       " stanowisko_rok.y,"
                       " stanowisko_rok_ekspert.email,"
                       " sl_ekspert.instytucja_cd,"
                       " stanowisko_rok.data_oceny,"
                       " stanowisko_rok.ocena_cd "
                       "FROM stanowisko INNER JOIN stanowisko_rok "
                       "ON stanowisko.stanowisko_nr = stanowisko_rok.stanowisko_nr  "
                       "INNER JOIN stanowisko_rok_ekspert "
                       "ON stanowisko_rok.stanowisko_nr = stanowisko_rok_ekspert.stanowisko_nr and stanowisko_rok.rok = stanowisko_rok_ekspert.rok "
                       "INNER JOIN sl_ekspert ON stanowisko_rok_ekspert.email = sl_ekspert.email "
                       "WHERE x != '' and y != '' and x > 0 and y >0")

        # Fetch all the rows from the result set
        rows = cursor.fetchall()

        vl = QgsVectorLayer("Point", base_name + "_pkt_monit", "memory")
        pr = vl.dataProvider()
        # Enter editing mode
        vl.startEditing()
        # add fields
        pr.addAttributes([QgsField("ID_STAN", QVariant.Int),
                          QgsField("NZW_STAN", QVariant.String),
                          QgsField("SIEDL", QVariant.String),
                          QgsField("SIEDL_PLAN", QVariant.String),
                          QgsField("SIEDL_LP", QVariant.String),
                          QgsField("KOD_ZGODN", QVariant.String),
                          QgsField("X", QVariant.Double),
                          QgsField("Y", QVariant.Double),
                          QgsField("E_MAIL", QVariant.String),
                          QgsField("BUL_ODDZ", QVariant.String),
                          QgsField("DATA", QVariant.String),
                          QgsField("OCENA", QVariant.String)])

        for row in rows:

            x_str = row[7]
            y_str = row[6]

            x = 0
            y = 0

            if self.is_numeric_with_dots(str(x_str)):
                x = float(x_str)
            else:
                self.appendDataToLabel(
                    "Błędne wartości współrzędnych w bazie danych: " + str(x_str) + " Stanowisko:" + str(row[0]),
                    self.dockwidget.label_warning)
                continue

            if self.is_numeric_with_dots(str(y_str)):
                y = float(y_str)
            else:
                self.appendDataToLabel(
                    "Błędne wartości współrzędnych w bazie danych: " + str(y_str) + " Stanowisko:" + str(row[0]),
                    self.dockwidget.label_warning)
                continue

            fet = QgsFeature()
            fet.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(x, y)))

            fet.setAttributes([row[0], row[1], row[2], row[3], row[4], row[5], x, y, row[8], row[9], row[10], row[11]])

            pr.addFeatures([fet])

        # Commit changes
        vl.commitChanges()
        vl.renderer().symbol().setSize(2)
        vl.triggerRepaint()

        # Close the cursor and connection
        cursor.close()
        conn.close()

        # Show in project
        QgsProject.instance().addMapLayer(vl)


    # T_0102
    def rewrite_area_to_dbase(self):

        # Clear info labels
        self.clear_info_labels()

        # Dbase
        d_base = self.get_dBase_directory()
        if not d_base:
            return False

        # Layer
        layer = self.getLayer()
        if not layer:
            return False

        CustomMessageBox.showWithTimeout(10, "Obliczanie powierzchni poligonów...", "", icon=QMessageBox.Information)
        self.appendDataToLabel("Obliczanie powierzchni poligonów...", self.dockwidget.label_info)

        # Connection settings
        conn = sqlite3.connect(d_base)
        cursor = conn.cursor()

        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, layer, "AREA_HA", QVariant.Double)
        layer_provider = layer.dataProvider()
        layer_fields = layer.fields()
        field_area = layer_fields.indexFromName("AREA_HA")
        features_of_layer = layer.getFeatures()
        area_list_from_layer = []
        list_of_subarea = []
        field_name = self.dockwidget.comboBoxFieldsName.currentText()
        field_area_id = layer.fields().indexFromName(field_name)


        for f in features_of_layer:
            id = f.id()
            feat = layer.getFeature(id)

            # SUBAREA
            geom = f.geometry()
            area = geom.area() / 10000
            area = round(area, 2)
            attr_value_subarea = {field_area: area}
            layer_provider.changeAttributeValues({id: attr_value_subarea})
            area_list_from_layer.append(feat[field_area_id])
            list_of_subarea.append(area)

        layer.commitChanges()

        # Info
        CustomMessageBox.showWithTimeout(5, "Obliczono powierzchnię poligonów warstwy wektorowej", "", icon=QMessageBox.Information)
        self.appendDataToLabel("Obliczono powierzchnię poligonów warstwy wektorowej", self.dockwidget.label_info)

        for index, area in enumerate(area_list_from_layer):

            area_id = area_list_from_layer[index]
            subarea = list_of_subarea[index]

            print(str(area_id) + ":" + str(subarea))

            update_query = f"UPDATE stanowisko_rok SET powierzchnia = {subarea} WHERE stanowisko_nr = {area_id}"
            cursor.execute(update_query)

            conn.commit()


        CustomMessageBox.showWithTimeout(5, "Zaktualizowano powierzchnię w bazie danych...", "", icon=QMessageBox.Information)
        self.appendDataToLabel("Zaktualizowano powierzchnię w bazie danych...", self.dockwidget.label_info)

        self.dockwidget.pushButton_rewrite_area_to_dbase.setStyleSheet('QPushButton {background-color: #3cb371}')

        cursor.close()
        conn.close()


    # T_0103
    def add_coordinates_to_dbase(self):

        # # Specify the EPSG code for the desired project coordinate system (e.g., WGS 84)
        # new_project_crs_epsg = 4326
        # # Define the new project coordinate reference system
        # new_project_crs = QgsCoordinateReferenceSystem(new_project_crs_epsg, QgsCoordinateReferenceSystem.EpsgCrsId)
        # # Set the new coordinate system for the project
        # QgsProject.instance().setCrs(new_project_crs)


        # Clear info labels
        self.clear_info_labels()

        # Dbase
        d_base = self.get_dBase_directory()
        if not d_base:
            return False
        # Connection settings
        conn = sqlite3.connect(d_base)
        cursor = conn.cursor()


        # Layer
        layer = self.getLayer()
        if not layer:
            return False
        field_name = self.dockwidget.comboBoxFieldsName.currentText()
        field_area_id = layer.fields().indexFromName(field_name)
        list_of_centroid_values = []

        # Check if the layer is valid
        if not layer.isValid():
            print("Layer failed to load!")

        # Set layer scr to 2180
        crs = layer.crs()
        crs.createFromId(2180)
        layer.setCrs(QgsCoordinateReferenceSystem(crs))


        # Transform CRS from 2180 to 4326
        transform = QgsCoordinateTransform(QgsCoordinateReferenceSystem("EPSG:2180"), QgsCoordinateReferenceSystem("EPSG:4326"), QgsProject.instance())


        # Get the centroid coordinates of each feature
        for feature in layer.getFeatures():
            geometry = feature.geometry()
            if layer.type() == QgsMapLayer.VectorLayer and (layer.wkbType() == QgsWkbTypes.Polygon or layer.wkbType() == QgsWkbTypes.MultiPolygon):

                id = feature.id()
                feat = layer.getFeature(id)
                area_id = feat[field_area_id]

                # Calculate centroid
                centroid = geometry.centroid().asPoint()
                # Transform the coordinates to WGS 84
                centroid_wgs84 = transform.transform(centroid)

                # Update the records
                update_query = """UPDATE stanowisko_rok SET x = ?, y = ? 
                WHERE stanowisko_nr = ? AND (x IS NULL OR x = '') AND (y IS NULL OR y = '')"""


                # Execute the update query
                cursor.execute(update_query, (centroid_wgs84.y(), centroid_wgs84.x(), area_id))

                # Commit the changes
                conn.commit()

                print(
                    f"Feature {feature.id()}: Centroid Coordinates (WGS 84) - Latitude: {centroid_wgs84.y()}, Longitude: {centroid_wgs84.x()}")
            else:
                continue

        conn.close()
        CustomMessageBox.showWithTimeout(5, "Zaktualizowano brakujce współrzędne w bazie danych.", "", icon=QMessageBox.Information)
        self.appendDataToLabel("Zaktualizowano brakujce współrzędne w bazie danych.", self.dockwidget.label_info)
        self.dockwidget.pushButton_add_coordinates_to_d_base.setStyleSheet('QPushButton {background-color: #3cb371}')


    # C_0101
    def numeration_validating_map(self):

        # Clear info labels
        self.clear_info_labels()

        # Layer
        layer = self.dockwidget.mMapLayerComboBoxAraesPolygon.currentLayer()
        if not (layer):
            self.dockwidget.label_warning.setText("Nie wskazano warstwy!")
            return False

        area_list_from_layer = []
        invalid_numbers_layer = []

        field_name = self.dockwidget.comboBoxFieldsName.currentText()
        field_area_id = layer.fields().indexFromName(field_name)

        for f in layer.getFeatures():
            id = f.id()
            feat = layer.getFeature(id)
            area_list_from_layer.append(feat[field_area_id])


        # Check corectness
        for data_layer in area_list_from_layer:
            if not self.is_numeric_and_length(str(data_layer)):
                invalid_numbers_layer.append(data_layer)
        if len(invalid_numbers_layer) > 0:
            self.appendDataToLabel("", self.dockwidget.label_warning)
            self.appendDataToLabel("Błędnie zanumerowane powierzchnie w warstwie:", self.dockwidget.label_warning)

            for data_layer in invalid_numbers_layer:
                    self.appendDataToLabel(str(data_layer), self.dockwidget.label_warning)

            self.generate_csv_reports("Błędnie zanumerowane powierzchnie w warstwie", ["ID_STANOWISKA"],invalid_numbers_layer, "monitoring_gis_tools_raporty_kontroli", "0101_wykaz_blednie_zan_powierzchni_mapa.csv")
            self.dockwidget.pushButtonNumerationValidatingLayer.setStyleSheet('QPushButton {background-color: #ff0000}')
        else:
            self.appendDataToLabel("Wszystkie powierzchnie w warstwie zanumerowano poprawnie.", self.dockwidget.label_info)
            self.generate_csv_reports("Błędnie zanumerowane powierzchnie w warstwie - brak", ["ID_STANOWISKA"],invalid_numbers_layer, "monitoring_gis_tools_raporty_kontroli", "0101_wykaz_blednie_zan_powierzchni_mapa_OK.csv")
            self.dockwidget.pushButtonNumerationValidatingLayer.setStyleSheet('QPushButton {background-color: #3cb371}')


    # C_0102
    def control_duplicates(self):

        self.clear_info_labels()

        layer = self.getLayer()

        # Check if the layer is valid
        if not layer.isValid():
            print(f"Layer '{layer}' is not valid.")
            CustomMessageBox.showWithTimeout(10, "Warstwa jest niepoprawna...", "", icon=QMessageBox.Information)
            return False

        # Get the index of the column
        column_name = self.dockwidget.comboBoxFieldsName.currentText()
        column_index = layer.fields().indexFromName(column_name)

        # Create a dictionary to store the count of each attribute value
        attribute_count = {}

        # Iterate through features in the layer
        for feature in layer.getFeatures():
            # Get the attribute value for the specified column
            attribute_value = feature[column_index]

            # Update the count in the dictionary
            if attribute_value in attribute_count:
                attribute_count[attribute_value] += 1
            else:
                attribute_count[attribute_value] = 1

        # Identify duplicate attribute values
        duplicate_values = [value for value, count in attribute_count.items() if count > 1]

        if len(duplicate_values) == 0:
            self.appendDataToLabel(f'Brak duplikatów, kolumna: {column_name}', self.dockwidget.label_info)
            CustomMessageBox.showWithTimeout(5, f'Brak duplikatów, kolumna: {column_name}', "", icon=QMessageBox.Information)
            self.generate_csv_reports(f'Brak duplikatów, kolumna: {column_name}', ["ID_STANOWISKA"], duplicate_values, "monitoring_gis_tools_raporty_kontroli", "0102_duplikaty_warstwa_OK.csv")
            self.dockwidget.pushButton_control_duplicates.setStyleSheet('QPushButton {background-color: #3cb371}')
            return False

        CustomMessageBox.showWithTimeout(5, f'Warstwa zawiera duplikaty w kolumnie: {column_name}', "", icon=QMessageBox.Information)
        self.appendDataToLabel(f'Warstwa zawiera duplikaty w kolumnie: {column_name}:', self.dockwidget.label_warning)
        for duplicate_value in duplicate_values:
            self.appendDataToLabel(str(duplicate_value), self.dockwidget.label_warning)
        self.generate_csv_reports(f'Warstwa zawiera duplikaty w kolumnie: {column_name}', ["ID_STANOWISKA"],duplicate_values, "monitoring_gis_tools_raporty_kontroli", "0102_duplikaty_warstwa.csv")
        self.dockwidget.pushButton_control_duplicates.setStyleSheet('QPushButton {background-color: #ff0000}')

        # Create a list to store feature IDs with duplicate values
        duplicate_feature_ids = []

        # Iterate through features again to identify features with duplicate values
        for feature in layer.getFeatures():
            attribute_value = feature[column_index]

            # Check if the attribute value is in the list of duplicate values
            if attribute_value in duplicate_values:
                duplicate_feature_ids.append(feature.id())

        # Select duplicates
        layer.selectByIds(duplicate_feature_ids)

        # Zoom to the selected features with buffer
        box = layer.boundingBoxOfSelected()
        xmin, xmax, ymin, ymax = box.xMinimum(), box.xMaximum(), box.yMinimum(), box.yMaximum()
        xmin -= 100
        xmax += 100
        ymin -= 100
        ymax += 100
        box = QgsRectangle(xmin, ymin, xmax, ymax)
        self.iface.mapCanvas().setExtent(box)
        self.iface.mapCanvas().refresh()


    # C_0201
    def numeration_validating_map_dBase(self):

        # Clear info labels
        self.clear_info_labels()

        # Dbase address
        d_base = str(self.dockwidget.lineEdit_dBase_directory.text()).replace('\\', '/')
        if not (str(d_base)):
            self.dockwidget.label_warning.setText("Nie wskazano bazy danych!")
            return False

        # Declare connections
        conn = sqlite3.connect(d_base)
        cursor = conn.cursor()

        cursor.execute("SELECT stanowisko_nr FROM stanowisko_rok;")
        rows = cursor.fetchall()

        ara_list_from_dBase = []
        invalid_numbers_dBase = []

        for row in rows:
            ara_list_from_dBase.append(row[0])

        # Check corectness
        for data_dbase in  ara_list_from_dBase:
            if not self.is_numeric_and_length(str(data_dbase)):
                invalid_numbers_dBase.append(data_dbase)
        if len(invalid_numbers_dBase) > 0:
            self.appendDataToLabel("", self.dockwidget.label_warning)
            self.appendDataToLabel("Błędnie zanumerowane powierzchnie w bazie danych:", self.dockwidget.label_warning)
            for data_dbase in invalid_numbers_dBase:
                self.appendDataToLabel(str(data_dbase), self.dockwidget.label_warning)
            self.generate_csv_reports("Błędnie zanumerowane powierzchnie w bazie danych", ["ID_STANOWISKA"],invalid_numbers_dBase, "monitoring_gis_tools_raporty_kontroli", "0201_wykaz_blednie_zanumerowanych_powierzchni_baza.csv")
            self.dockwidget.pushButtonNumerationValidatingDBase.setStyleSheet('QPushButton {background-color: #ff0000}')
        else:
            self.appendDataToLabel("Wszystkie powierzchnie w bazie zanumerowano poprawnie.", self.dockwidget.label_info)
            self.generate_csv_reports("Błędnie zanumerowane powierzchnie w bazie - brak", ["ID_STANOWISKA"],invalid_numbers_dBase, "monitoring_gis_tools_raporty_kontroli", "0201_wykaz_blednie_zanumerowanych_powierzchni_baza_OK.csv")
            self.dockwidget.pushButtonNumerationValidatingDBase.setStyleSheet('QPushButton {background-color: #3cb371}')


    # C_0203 OK
    def control_coordinates(self):

        list = self.getListOfAreaByQuery("SELECT DISTINCT stanowisko.stanowisko_nr "
                                         "FROM stanowisko "
                                         "INNER join stanowisko_rok on stanowisko.stanowisko_nr = stanowisko_rok.stanowisko_nr "
                                         "WHERE COALESCE(x, 0) = 0 OR COALESCE(y, 0) = 0;")

        if len(list) > 0:
            self.appendDataToLabel("", self.dockwidget.label_warning)
            self.appendDataToLabel("Nieobliczone współrzędne w wybranych płatach:", self.dockwidget.label_warning)
            for data_dbase in list:
                self.appendDataToLabel(str(data_dbase), self.dockwidget.label_warning)
            self.generate_csv_reports("Nieobliczone współrzędne w wybranych płatach", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0203_wykaz_brak_wspolrzednych_baza.csv")
            self.dockwidget.pushButton_control_coordinates.setStyleSheet('QPushButton {background-color: #ff0000}')
        else:
            self.appendDataToLabel("Nieobliczone współrzędne w wybranych płatach - brak", self.dockwidget.label_info)
            self.generate_csv_reports("Nieobliczone współrzędne w wybranych płatach - brak", ["ID_STANOWISKA"],list, "monitoring_gis_tools_raporty_kontroli", "0203_wykaz_brak_wspolrzednych_baza_OK.csv")
            self.dockwidget.pushButton_control_coordinates.setStyleSheet('QPushButton {background-color: #3cb371}')






    # C_0204
    def missing_gen_assasement(self):

        list = self.getListOfAreaByQuery("SELECT DISTINCT stanowisko.stanowisko_nr "
                                         "FROM stanowisko "
                                         "INNER join stanowisko_rok on stanowisko.stanowisko_nr = stanowisko_rok.stanowisko_nr "
                                         "INNER join sl_siedlisko on stanowisko.siedlisko_cd = sl_siedlisko.siedlisko_cd "
                                         "WHERE COALESCE(stanowisko.siedlisko_cd, '') NOT IN ('', 'brak') "
                                         "AND coalesce(stanowisko_rok.ocena_cd,'') not in (select ocena_cd from sl_ocena)"
                                         "AND sl_siedlisko.projekt_fl = 1")

        if len(list) > 0:
            self.appendDataToLabel("", self.dockwidget.label_warning)
            self.appendDataToLabel("Brak oceny ogólnej:", self.dockwidget.label_warning)
            for data_dbase in list:
                self.appendDataToLabel(str(data_dbase), self.dockwidget.label_warning)
            self.generate_csv_reports("Brak oceny ogólnej w wybranych płatach", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0204_wykaz_brak_oceny_ogolnej.csv")
            self.dockwidget.pushButton_control_missing_gen_assasement.setStyleSheet('QPushButton {background-color: #ff0000}')
        else:
            self.appendDataToLabel("Wszystkie powierzchnie z oznaczeniem siedliska posiadają ocenę", self.dockwidget.label_info)
            self.generate_csv_reports("Wszystkie powierzchnie z oznaczeniem siedliska posiadają ocenę", ["ID_STANOWISKA"],list, "monitoring_gis_tools_raporty_kontroli", "0204_wykaz_brak_oceny_ogolnej_OK.csv")
            self.dockwidget.pushButton_control_missing_gen_assasement.setStyleSheet('QPushButton {background-color: #3cb371}')


    # C_0205 OK
    def missing_par_assasement(self):

        # list = self.getListOfAreaByQuery("SELECT subquery.stanowisko_nr, subquery.rok, subquery.SIEDL,subquery.PS,subquery.SF,subquery.PO "
        #                                  "FROM (SELECT srp.stanowisko_nr, "
        #                                  "srp.rok, "
        #                                  "stanowisko.siedlisko_cd AS SIEDL, "
        #                                  "MAX(srp.ocena_cd) FILTER(WHERE srp.parametr_cd = 'PS' OR srp.ocena_cd = '') AS PS, "
        #                                  "MAX(srp.ocena_cd) FILTER(WHERE srp.parametr_cd = 'SF' OR srp.ocena_cd = '') AS SF, "
        #                                  "MAX(srp.ocena_cd) FILTER(WHERE srp.parametr_cd = 'PO' OR srp.ocena_cd = '') AS PO "
        #                                  "FROM stanowisko_rok_parametr srp INNER JOIN stanowisko ON srp.stanowisko_nr = stanowisko.stanowisko_nr "
        #                                  "WHERE stanowisko.siedlisko_cd NOT IN ('', 'brak') "
        #                                  "GROUP BY srp.stanowisko_nr, srp.rok, stanowisko.siedlisko_cd) AS subquery "
        #                                  "WHERE COALESCE(PS, '') NOT IN ('FV', 'U1', 'U2', 'XX') OR "
        #                                  "COALESCE(SF, '') NOT IN ('FV', 'U1', 'U2', 'XX') OR "
        #                                  "COALESCE(PO, '') NOT IN ('FV', 'U1', 'U2', 'XX')")

        list = self.getListOfAreaByQuery("with t as "
                                         "(select stanowisko_nr,parametr_cd from stanowisko s "
                                         "join sl_siedlisko ss on s.siedlisko_cd=ss.siedlisko_cd "
                                         "join sl_parametr on true where projekt_fl) "
                                         "select distinct t.stanowisko_nr "
                                         "from t left join stanowisko_rok_parametr srp on srp.stanowisko_nr=t.stanowisko_nr and srp.parametr_cd=t.parametr_cd "
                                         "where coalesce(srp.ocena_cd,'') not in (select ocena_cd from sl_ocena);")



        if len(list) > 0:
            self.appendDataToLabel("", self.dockwidget.label_warning)
            self.appendDataToLabel("Brak oceny parametrów:", self.dockwidget.label_warning)
            for data_dbase in list:
                self.appendDataToLabel(str(data_dbase), self.dockwidget.label_warning)
            self.generate_csv_reports("Brak oceny parametrów w wybranych płatach", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0205_wykaz_brak_oceny_parametrow.csv")
            self.dockwidget.pushButton_control_missing_par_assasement.setStyleSheet('QPushButton {background-color: #ff0000}')
        else:
            self.appendDataToLabel("Wszystkie powierzchnie z oznaczeniem siedliska posiadają ocenę parametrów", self.dockwidget.label_info)
            self.generate_csv_reports("Wszystkie powierzchnie z oznaczeniem siedliska posiadają ocenę parametrów", ["ID_STANOWISKA"],list, "monitoring_gis_tools_raporty_kontroli", "0205_wykaz_brak_oceny_parametrow_OK.csv")
            self.dockwidget.pushButton_control_missing_par_assasement.setStyleSheet('QPushButton {background-color: #3cb371}')


    # C_0206 OK
    def missing_indicators_assasement(self):

        list = self.getListOfAreaByQuery("with t as "
                                         "(select stanowisko_nr,ssw.wskaznik_nr "
                                         "from stanowisko s join sl_siedlisko ss on s.siedlisko_cd=ss.siedlisko_cd "
                                         "join sl_siedlisko_wskaznik ssw on ss.siedlisko_cd = ssw.siedlisko_cd "
                                         "where projekt_fl and ssw.wskaznik_rodzaj_cd = 'O') "
                                         "select distinct t.stanowisko_nr "
                                         "from t left join stanowisko_rok_wskaznik srw on srw.stanowisko_nr=t.stanowisko_nr and srw.wskaznik_nr=t.wskaznik_nr "
                                         "where coalesce(srw.ocena_cd,'') not in (select ocena_cd from sl_ocena);")

        if len(list) > 0:
            self.appendDataToLabel("", self.dockwidget.label_warning)
            self.appendDataToLabel("Brak oceny wskaźników w wybranych płatach:", self.dockwidget.label_warning)
            for data_dbase in list:
                self.appendDataToLabel(str(data_dbase), self.dockwidget.label_warning)
            self.generate_csv_reports("Brak oceny wskaźników w wybranych płatach", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0206_wykaz_brak_oceny_wskaznikow.csv")
            self.dockwidget.pushButton_control_missing_indicators_assasement.setStyleSheet('QPushButton {background-color: #ff0000}')
        else:
            self.appendDataToLabel("Wszystkie powierzchnie z oznaczeniem siedliska posiadają ocenę wskaźników", self.dockwidget.label_info)
            self.generate_csv_reports("Wszystkie powierzchnie z oznaczeniem siedliska posiadają ocenę wskaźników", ["ID_STANOWISKA"],list, "monitoring_gis_tools_raporty_kontroli", "0206_wykaz_brak_oceny_wskaznikow_OK.csv")
            self.dockwidget.pushButton_control_missing_indicators_assasement.setStyleSheet('QPushButton {background-color: #3cb371}')


    # C_0207 OK
    def missing_gen_assasement_desc(self):

        list = self.getListOfAreaByQuery("select distinct sr.stanowisko_nr "
                                         "from stanowisko s "
                                         "join sl_siedlisko ss on s.siedlisko_cd=ss.siedlisko_cd join stanowisko_rok sr on s.stanowisko_nr=sr.stanowisko_nr "
                                         "where projekt_fl "
                                         "and coalesce(sr.komentarz_ocena_stanu_ochrony,'') not in ('',' ');")

        if len(list) > 0:
            self.appendDataToLabel("", self.dockwidget.label_warning)
            self.appendDataToLabel("Brak oceny opisowej (ocena ogólna) w wybranych płatach:", self.dockwidget.label_warning)
            for data_dbase in list:
                self.appendDataToLabel(str(data_dbase), self.dockwidget.label_warning)
            self.generate_csv_reports("Brak oceny opisowej (ocena ogólna) w wybranych płatach", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0207_wykaz_brak_oceny_ogolnej_opisowej.csv")
            self.dockwidget.pushButton_control_missing_gen_assasement_desc.setStyleSheet('QPushButton {background-color: #ff0000}')
        else:
            self.appendDataToLabel("Wszystkie powierzchnie z oznaczeniem siedliska posiadają ocenę opisową", self.dockwidget.label_info)
            self.generate_csv_reports("Wszystkie powierzchnie z oznaczeniem siedliska posiadają ocenę opisową", ["ID_STANOWISKA"],list, "monitoring_gis_tools_raporty_kontroli", "0207_wykaz_brak_oceny_ogolnej_opisowej_OK.csv")
            self.dockwidget.pushButton_control_missing_gen_assasement_desc.setStyleSheet('QPushButton {background-color: #3cb371}')


    # C_0208 OK
    def missing_par_assasement_desc(self):

        list = self.getListOfAreaByQuery("SELECT DISTINCT s.stanowisko_nr "
                                         "from stanowisko s join sl_siedlisko ss on s.siedlisko_cd=ss.siedlisko_cd "
                                         "JOIN stanowisko_rok_parametr srp on s.stanowisko_nr = srp.stanowisko_nr "
                                         "WHERE ss.projekt_fl AND "
                                         "coalesce(srp.komentarz,'') in ('',' ','⁶','*','/','6','I','7','&','l','y','o','8','w','9','-','.','v','i','(','k','. ','pl','90','11','|. ','   ','see','''','''''',' .',' ');")


        if len(list) > 0:
            self.appendDataToLabel("", self.dockwidget.label_warning)
            self.appendDataToLabel("Brak oceny opisowej parametrów:", self.dockwidget.label_warning)
            for data_dbase in list:
                self.appendDataToLabel(str(data_dbase), self.dockwidget.label_warning)
            self.generate_csv_reports("Brak oceny opisowej parametrów w wybranych płatach", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0208_wykaz_brak_oceny_opisowej_parametrow.csv")
            self.dockwidget.pushButton_control_missing_par_assasement_desc.setStyleSheet('QPushButton {background-color: #ff0000}')
        else:
            self.appendDataToLabel("Wszystkie powierzchnie z oznaczeniem siedliska posiadają ocenę opisową parametrów", self.dockwidget.label_info)
            self.generate_csv_reports("Wszystkie powierzchnie z oznaczeniem siedliska posiadają ocenę opisową parametrów", ["ID_STANOWISKA"],list, "monitoring_gis_tools_raporty_kontroli", "0208_wykaz_brak_oceny_opisowej_parametrow_OK.csv")
            self.dockwidget.pushButton_control_missing_par_assasement_desc.setStyleSheet('QPushButton {background-color: #3cb371}')


    # C_0209 OK
    def missing_indicators_assasement_desc(self):

        list = self.getListOfAreaByQuery("SELECT DISTINCT s.stanowisko_nr from stanowisko s join sl_siedlisko ss on s.siedlisko_cd=ss.siedlisko_cd JOIN stanowisko_rok_wskaznik srw on s.stanowisko_nr = srw.stanowisko_nr join sl_siedlisko_wskaznik ssw on s.siedlisko_cd=ssw.siedlisko_cd WHERE ss.projekt_fl and ssw.wskaznik_rodzaj_cd='O' AND coalesce(srw.wartosc,'') in ('',' ','''','''''','|','/','.','-',',','~','!','p','l','po','ww','''-','Bra','jw.','...',' ',' ');")

        if len(list) > 0:
            self.appendDataToLabel("", self.dockwidget.label_warning)
            self.appendDataToLabel("Brak oceny opisowej wskaźników w wybranych płatach:", self.dockwidget.label_warning)
            for data_dbase in list:
                self.appendDataToLabel(str(data_dbase), self.dockwidget.label_warning)
            self.generate_csv_reports("Brak oceny opisowej wskaźników w wybranych płatach", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0209_wykaz_brak_oceny_opisowej_wskaznikow.csv")
            self.dockwidget.pushButton_control_missing_indicators_assasement_desc.setStyleSheet('QPushButton {background-color: #ff0000}')
        else:
            self.appendDataToLabel("Wszystkie powierzchnie z oznaczeniem siedliska posiadają ocenę opisową wskaźników", self.dockwidget.label_info)
            self.generate_csv_reports("Wszystkie powierzchnie z oznaczeniem siedliska posiadają ocenę opisową wskaźników", ["ID_STANOWISKA"],list, "monitoring_gis_tools_raporty_kontroli", "0209_wykaz_brak_oceny_opisowej_wskaznikow_OK.csv")
            self.dockwidget.pushButton_control_missing_indicators_assasement_desc.setStyleSheet('QPushButton {background-color: #3cb371}')


    # C_0210 OK, not in use
    def missing_gen_assasement_exist_desc_assasement(self):

        list = self.getListOfAreaByQuery("SELECT DISTINCT s.stanowisko_nr from stanowisko s join sl_siedlisko ss on s.siedlisko_cd=ss.siedlisko_cd left JOIN stanowisko_rok sr on s.stanowisko_nr = sr.stanowisko_nr WHERE ss.projekt_fl AND (coalesce(sr.ocena_cd,'') not in (select ocena_cd from sl_ocena) or coalesce(sr.komentarz_ocena_stanu_ochrony,'') in ('',' '));")

        if len(list) > 0:
            self.appendDataToLabel("", self.dockwidget.label_warning)
            self.appendDataToLabel("Brak oceny ogólnej, istniejąca ocena opisowa:", self.dockwidget.label_warning)
            for data_dbase in list:
                self.appendDataToLabel(str(data_dbase), self.dockwidget.label_warning)
            self.generate_csv_reports("Brak oceny ogólnej, istniejąca ocena opisowa", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0210_wykaz_brak_oceny_ogolnej_istniejaca_ocena_opisowa.csv")
            self.dockwidget.pushButton_control_missing_gen_assasement_exist_desc_assasement.setStyleSheet('QPushButton {background-color: #ff0000}')
        else:
            self.appendDataToLabel("Wszystkie powierzchnie z oceną opisową posiadają ocenę ogólną", self.dockwidget.label_info)
            self.generate_csv_reports("Wszystkie powierzchnie z oceną opisową posiadają ocenę ogólną", ["ID_STANOWISKA"],list, "monitoring_gis_tools_raporty_kontroli", "0210_wykaz_brak_oceny_ogolnej_istniejaca_ocena_opisowa_OK.csv")
            self.dockwidget.pushButton_control_missing_gen_assasement_exist_desc_assasement.setStyleSheet('QPushButton {background-color: #3cb371}')


    # C_0213 OK
    def missing_site_description(self):

        list = self.getListOfAreaByQuery("SELECT DISTINCT s.stanowisko_nr from stanowisko s join sl_siedlisko ss on s.siedlisko_cd=ss.siedlisko_cd JOIN stanowisko_rok sr on s.stanowisko_nr = sr.stanowisko_nr WHERE ss.projekt_fl AND length(coalesce(sr.opis_siedliska,''))<9")

        if len(list) > 0:
            self.appendDataToLabel("", self.dockwidget.label_warning)
            self.appendDataToLabel("Brak opisu siedliska na stanowisku:", self.dockwidget.label_warning)
            for data_dbase in list:
                self.appendDataToLabel(str(data_dbase), self.dockwidget.label_warning)
            self.generate_csv_reports("Brak opisu siedliska na stanowisku", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0213_wykaz_brak_opisu_siedliska_na_stanowisku.csv")
            self.dockwidget.pushButton_control_missing_site_description.setStyleSheet('QPushButton {background-color: #ff0000}')
        else:
            self.appendDataToLabel("Wszystkie powierzchnie z określonym kodem siedliska posiadają opis siedliska na stanowisku", self.dockwidget.label_info)
            self.generate_csv_reports("Wszystkie powierzchnie z określonym kodem siedliska posiadają opis siedliska na stanowisku", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0213_wykaz_brak_opisu_siedliska_na_stanowisku_OK.csv")
            self.dockwidget.pushButton_control_missing_site_description.setStyleSheet('QPushButton {background-color: #3cb371}')


    # C_0214 OK
    def missing_natural_values(self):

        list = self.getListOfAreaByQuery("SELECT DISTINCT s.stanowisko_nr from stanowisko s "
                                         "join sl_siedlisko ss on s.siedlisko_cd=ss.siedlisko_cd "
                                         "JOIN stanowisko_rok sr on s.stanowisko_nr = sr.stanowisko_nr "
                                         "WHERE ss.projekt_fl AND length(coalesce(sr.wartosci_przyrodnicze,''))<4 or sr.wartosci_przyrodnicze='''<.'")

        if len(list) > 0:
            self.appendDataToLabel("", self.dockwidget.label_warning)
            self.appendDataToLabel("Brak wprowadznonych wartości przyrodniczych:", self.dockwidget.label_warning)
            for data_dbase in list:
                self.appendDataToLabel(str(data_dbase), self.dockwidget.label_warning)
            self.generate_csv_reports("Brak wprowadznonych wartości przyrodniczych", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0214_wykaz_brak_wartosci_przyrodniczych.csv")
            self.dockwidget.pushButton_control_missing_natural_values.setStyleSheet('QPushButton {background-color: #ff0000}')
        else:
            self.appendDataToLabel("Wszystkie powierzchnie z określonym kodem siedliska posiadają opis wartości przyrodniczych", self.dockwidget.label_info)
            self.generate_csv_reports("Wszystkie powierzchnie z określonym kodem siedliska posiadają opis wartości przyrodniczych", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0214_wykaz_brak_wartosci_przyrodniczych_OK.csv")
            self.dockwidget.pushButton_control_missing_natural_values.setStyleSheet('QPushButton {background-color: #3cb371}')


    # C_0215 OK
    def missing_date_information(self):

        list = self.getListOfAreaByQuery("SELECT DISTINCT s.stanowisko_nr FROM stanowisko s left join stanowisko_rok_datakontroli srd on s.stanowisko_nr = srd.stanowisko_nr WHERE coalesce(srd.data_kontroli,'')='';")

        if len(list) > 0:
            self.appendDataToLabel("", self.dockwidget.label_warning)
            self.appendDataToLabel("Brak informacji o dacie kontroli:", self.dockwidget.label_warning)
            for data_dbase in list:
                self.appendDataToLabel(str(data_dbase), self.dockwidget.label_warning)
            self.generate_csv_reports("Brak informacji o dacie kontroli", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0215_wykaz_brak_informacji_o_dacie_kontroli.csv")
            self.dockwidget.pushButton_missing_date_information.setStyleSheet('QPushButton {background-color: #ff0000}')
        else:
            self.appendDataToLabel("Wszystkie powierzchnie posiadają informację o dacie kontroli", self.dockwidget.label_info)
            self.generate_csv_reports("Wszystkie powierzchnie posiadają informację o dacie kontroli", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0215_wykaz_brak_informacji_o_dacie_kontroli_OK.csv")
            self.dockwidget.pushButton_missing_date_information.setStyleSheet('QPushButton {background-color: #3cb371}')


    # C_0216 OK
    def missing_availability_information(self):

        list = self.getListOfAreaByQuery("SELECT DISTINCT s.stanowisko_nr "
                                         "FROM stanowisko s join stanowisko_rok_datakontroli srd on s.stanowisko_nr = srd.stanowisko_nr "
                                         "WHERE coalesce(cast(srd.dostepnosc_cd as text),'') in ('','0') or (cast(coalesce(dostepnosc_cd,'') as text) in ('niedostępna z przyczyn abiotycznych','niedostępna z przyczyn antropogenicznych','niedostępna z przyczyn biotycznych') and coalesce(opis,'') = '');")

        if len(list) > 0:
            self.appendDataToLabel("", self.dockwidget.label_warning)
            self.appendDataToLabel("Brak informacji o dostępności powierzchni:", self.dockwidget.label_warning)
            for data_dbase in list:
                self.appendDataToLabel(str(data_dbase), self.dockwidget.label_warning)
            self.generate_csv_reports("Brak informacji o dostępności powierzchni", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0216_wykaz_brak_informacji_o_dostępności.csv")
            self.dockwidget.pushButton_missing_availability_information.setStyleSheet('QPushButton {background-color: #ff0000}')
        else:
            self.appendDataToLabel("Wszystkie powierzchnie posiadają informację o dostępności", self.dockwidget.label_info)
            self.generate_csv_reports("Wszystkie powierzchnie posiadają informację o dostępności", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0216_wykaz_brak_informacji_o_dostępności_OK.csv")
            self.dockwidget.pushButton_missing_availability_information.setStyleSheet('QPushButton {background-color: #3cb371}')


    # C_0217 OK
    def missing_impacts(self):
        list = self.getListOfAreaByQuery("SELECT DISTINCT s.stanowisko_nr from stanowisko s "
                                         "join sl_siedlisko ss on s.siedlisko_cd=ss.siedlisko_cd "
                                         "JOIN stanowisko_rok sr on s.stanowisko_nr = sr.stanowisko_nr "
                                         "LEFT join stanowisko_rok_oddzialywanie sro on sr.stanowisko_nr = sro.stanowisko_nr and sr.rok = sro.rok "
                                         "WHERE ss.projekt_fl AND coalesce(sro.oddzialywanie_cd,'') not in (select oddzialywanie_cd from sl_oddzialywanie);")

        if len(list) > 0:
            self.appendDataToLabel("", self.dockwidget.label_warning)
            self.appendDataToLabel("Brak informacji o oddziaływaniach:", self.dockwidget.label_warning)
            for data_dbase in list:
                self.appendDataToLabel(str(data_dbase), self.dockwidget.label_warning)
            self.generate_csv_reports("Brak informacji o oddziaływaniach", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0217_wykaz_brak_informacji_o_oddzialywaniach.csv")
            self.dockwidget.pushButton_missing_impacts.setStyleSheet('QPushButton {background-color: #ff0000}')
        else:
            self.appendDataToLabel("Wszystkie powierzchnie posiadają informację o oddziaływaniach", self.dockwidget.label_info)
            self.generate_csv_reports("Wszystkie powierzchnie posiadają informację o oddziaływaniach", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0217_wykaz_brak_informacji_o_oddzialywaniach_OK.csv")
            self.dockwidget.pushButton_missing_impacts.setStyleSheet('QPushButton {background-color: #3cb371}')


    # C_0218 OK
    def missing_threats(self):
        list = self.getListOfAreaByQuery("SELECT DISTINCT s.stanowisko_nr from stanowisko s JOIN sl_siedlisko ss on s.siedlisko_cd=ss.siedlisko_cd JOIN stanowisko_rok sr on s.stanowisko_nr = sr.stanowisko_nr LEFT join stanowisko_rok_zagrozenie srz on sr.stanowisko_nr = srz.stanowisko_nr and sr.rok = srz.rok WHERE ss.projekt_fl AND coalesce(srz.oddzialywanie_cd,'') not in (select oddzialywanie_cd from sl_oddzialywanie);")

        if len(list) > 0:
            self.appendDataToLabel("", self.dockwidget.label_warning)
            self.appendDataToLabel("Brak informacji o zagrożeniach:", self.dockwidget.label_warning)
            for data_dbase in list:
                self.appendDataToLabel(str(data_dbase), self.dockwidget.label_warning)
            self.generate_csv_reports("Brak informacji o zagrożeniach", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0218_wykaz_brak_informacji_o_zagrozeniach.csv")
            self.dockwidget.pushButton_missing_threats.setStyleSheet('QPushButton {background-color: #ff0000}')
        else:
            self.appendDataToLabel("Wszystkie powierzchnie posiadają informację o zagrożeniach", self.dockwidget.label_info)
            self.generate_csv_reports("Wszystkie powierzchnie posiadają informację o zagrożeniach", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0218_wykaz_brak_informacji_o_zagrozeniach_OK.csv")
            self.dockwidget.pushButton_missing_threats.setStyleSheet('QPushButton {background-color: #3cb371}')


    # C_0219 OK
    def missing_protectiv_actions(self):

        list = self.getListOfAreaByQuery("select distinct s.stanowisko_nr from stanowisko s join sl_siedlisko ss on s.siedlisko_cd=ss.siedlisko_cd join stanowisko_rok sr on s.stanowisko_nr=sr.stanowisko_nr join stanowisko_rok_dzialanieochronne srd on sr.stanowisko_nr=srd.stanowisko_nr and sr.rok=srd.rok where ss.projekt_fl and (coalesce(srd.dzialanie_cd,'') not in (select dzialanie_cd from sl_dzialanie_ochronne) or coalesce(srd.dzialanie_typ_cd,'') not in (select dzialanie_typ_cd from sl_dzialanie_ochronne_typ) or (srd.powierzchnia=0 and not cala_pow_fl) or (length(coalesce(srd.opis,'')<4) and length(coalesce(srd.dodatkowe_uwarunkowania,'')<4)));")

        if len(list) > 0:
            self.appendDataToLabel("", self.dockwidget.label_warning)
            self.appendDataToLabel("Brak informacji (niepełne informacje) o działaniach ochronnych:", self.dockwidget.label_warning)
            for data_dbase in list:
                self.appendDataToLabel(str(data_dbase), self.dockwidget.label_warning)
            self.generate_csv_reports("Brak informacji (niepełne informacje) o działaniach ochronnych:", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0219_wykaz_brak_informacji_o_dzialaniach_ochronnych.csv")
            self.dockwidget.pushButton_missing_protectiv_actions.setStyleSheet('QPushButton {background-color: #ff0000}')
        else:
            self.appendDataToLabel("Wszystkie powierzchnie posiadają pełną informację o działaniach ochronnych", self.dockwidget.label_info)
            self.generate_csv_reports("Wszystkie powierzchnie posiadają pełną informację o działaniach ochronnych", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0219_wykaz_brak_informacji_o_dzialaniach_ochronnych_OK.csv")
            self.dockwidget.pushButton_missing_protectiv_actions.setStyleSheet('QPushButton {background-color: #3cb371}')


    # C_02220
    def missing_elements_in_photo_doc(self):
        list = self.getListOfAreaByQuery("select distinct s.stanowisko_nr from stanowisko s join sl_siedlisko ss on s.siedlisko_cd=ss.siedlisko_cd join stanowisko_rok sr on s.stanowisko_nr=sr.stanowisko_nr join stanowisko_rok_foto srf on sr.stanowisko_nr=srf.stanowisko_nr and sr.rok=srf.rok left join (select stanowisko_nr,rok,count(*) cnt from stanowisko_rok_foto group by 1,2) t on sr.stanowisko_nr=t.stanowisko_nr and sr.rok=t.rok where ss.projekt_fl and (srf.stanowisko_nr||'_'||srf.foto_nr||coalesce('_'||case when srf.sufix='' then null else srf.sufix end,'')||'.jpg' != srf.nazwa or not coalesce(cast(replace(srf.x,',','.') as float),0) between 49.002046518 and 54.836416667 or not coalesce(cast(replace(srf.y,',','.') as float),0) between 14.12288486 and 24.145783075 or not coalesce(cast(replace(srf.z,',','.') as float),-100) between -2 and 2499 or coalesce(cnt,0)<2);")

        if len(list) > 0:
            self.appendDataToLabel("", self.dockwidget.label_warning)
            self.appendDataToLabel("Braki w dokumentacji fotograficznej:", self.dockwidget.label_warning)
            for data_dbase in list:
                self.appendDataToLabel(str(data_dbase), self.dockwidget.label_warning)
            self.generate_csv_reports("Braki w dokumentacji fotograficznej:", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0220_wykaz_braki_w_dokumentacji_fotograficznej.csv")
            self.dockwidget.pushButton_missingelements_in_photo_documentation.setStyleSheet('QPushButton {background-color: #ff0000}')
        else:
            self.appendDataToLabel("Wszystkie powierzchnie posiadają pełną dokumentację fotograficzną", self.dockwidget.label_info)
            self.generate_csv_reports("Wszystkie powierzchnie posiadają pełną dokumentację fotograficzną", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0220_wykaz_braki_w_dokumentacji_fotograficznej_OK.csv")
            self.dockwidget.pushButton_missingelements_in_photo_documentation.setStyleSheet('QPushButton {background-color: #3cb371}')



    # C_0221
    def compatibility_validation(self):
        list = self.getListOfAreaByQuery("select distinct s.stanowisko_nr "
                                         "from stanowisko s left join sl_siedlisko s1 on s.siedlisko_plan_cd=s1.siedlisko_cd left join sl_siedlisko s2 on s.siedlisko_lp_cd  =s2.siedlisko_cd left join sl_siedlisko s3 on s.siedlisko_cd     =s3.siedlisko_cd where not((s.siedlisko_plan_cd=s.siedlisko_cd and zgodnosc_cd=1) or (coalesce(s1.projekt_fl,0)=0 and coalesce(s2.projekt_fl,0)=0 and s3.projekt_fl=1 and zgodnosc_cd=2) or (s.siedlisko_plan_cd!=s.siedlisko_cd and s1.projekt_fl and s3.projekt_fl and zgodnosc_cd=3) or (s1.projekt_fl=1 and s3.projekt_fl=0 and s.zgodnosc_cd=4) or (s1.projekt_fl=1 and s.siedlisko_cd='brak' and zgodnosc_cd in (5,6,7)) or (s.siedlisko_lp_cd=s.siedlisko_cd and coalesce(s1.projekt_fl,0)=0 and s.zgodnosc_cd=8) or (s2.projekt_fl=1 and coalesce(s3.projekt_fl,0)=0 and s.zgodnosc_cd=9)) or coalesce(s.zgodnosc_cd,0) in (0,'')")

        if len(list) > 0:
            self.appendDataToLabel("", self.dockwidget.label_warning)
            self.appendDataToLabel("Błędne oznaczenia (brak oznaczenia) zgodności z dokumentacją:", self.dockwidget.label_warning)
            for data_dbase in list:
                self.appendDataToLabel(str(data_dbase), self.dockwidget.label_warning)
            self.generate_csv_reports("Błędne oznaczenia (brak oznaczenia) zgodności z dokumentacją:", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0221_wykaz_stanowisk_z_bledna_ocena_zgodnosci.csv")
            self.dockwidget.pushButton_compatibility_validation.setStyleSheet('QPushButton {background-color: #ff0000}')
        else:
            self.appendDataToLabel("Ocena zgodności z dokumentacją (w zakresie kontroli) nie wykazała błędów", self.dockwidget.label_info)
            self.generate_csv_reports("Ocena zgodności z dokumentacją (w zakresie kontroli) nie wykazała błędów", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0221_wykaz_stanowisk_z_bledna_ocena_zgodnosci_OK.csv")
            self.dockwidget.pushButton_compatibility_validation.setStyleSheet('QPushButton {background-color: #3cb371}')



    # C_0222 OK
    def missing_resigantion_exist_resignation_cause(self):

        list = self.getListOfAreaByQuery("select distinct s.stanowisko_nr "
                                         "from stanowisko s "
                                         "join stanowisko_rok sr on s.stanowisko_nr=sr.stanowisko_nr "
                                         "join sl_siedlisko ss on s.siedlisko_cd=ss.siedlisko_cd "
                                         "where ss.projekt_fl and not rezygnacja_fl and coalesce(uzasadnienie_rezygnacji,'') != ''")

        if len(list) > 0:
            self.appendDataToLabel("", self.dockwidget.label_warning)
            self.appendDataToLabel("Stanowiska z uzasadnieniem rezygnacji (odstąpienia), bez zaznaczenia odstąpienia:", self.dockwidget.label_warning)
            for data_dbase in list:
                self.appendDataToLabel(str(data_dbase), self.dockwidget.label_warning)
            self.generate_csv_reports("Stanowiska z uzasadnieniem rezygnacji (odstąpienia), bez zaznaczenia odstąpienia", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0222_wykaz_stanowisk_z_uzasadnieniem_rezygnacji_bez_zaznaczenia_rezygnacji.csv")
            self.dockwidget.pushButton_missing_resigantion_exist_resignation_cause.setStyleSheet('QPushButton {background-color: #ff0000}')
        else:
            self.appendDataToLabel("Wszystkie stanowiska z opisem rezygnacji posiadają oznaczenie rezygnacji", self.dockwidget.label_info)
            self.generate_csv_reports("Wszystkie stanowiska z opisem rezygnacji posiadają oznaczenie rezygnacji", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0222_wykaz_stanowisk_z_uzasadnieniem_rezygnacji_bez_zaznaczenia_rezygnacji_OK.csv")
            self.dockwidget.pushButton_missing_resigantion_exist_resignation_cause.setStyleSheet('QPushButton {background-color: #3cb371}')



    # C_0223 OK
    def missing_resigantion_cause(self):
        list = self.getListOfAreaByQuery("select distinct s.stanowisko_nr from stanowisko s join stanowisko_rok sr on s.stanowisko_nr=sr.stanowisko_nr join sl_siedlisko ss on s.siedlisko_cd=ss.siedlisko_cd where ss.projekt_fl and rezygnacja_fl and length(coalesce(uzasadnienie_rezygnacji,''))<4;")

        if len(list) > 0:
            self.appendDataToLabel("", self.dockwidget.label_warning)
            self.appendDataToLabel("Stanowiska bez uzasadnienia rezygnacji:", self.dockwidget.label_warning)
            for data_dbase in list:
                self.appendDataToLabel(str(data_dbase), self.dockwidget.label_warning)
            self.generate_csv_reports("Stanowiska bez uzasadnienia rezygnacji", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0223_wykaz_stanowiska_bez_uzasadnienia_rezygnacji.csv")
            self.dockwidget.pushButton_missing_resigantion_cause.setStyleSheet('QPushButton {background-color: #ff0000}')
        else:
            self.appendDataToLabel("Wszystkie stanowiska, w których odstąpiono od monitoringu posiadają uzasadnie rezygnacji (odstąpnia)", self.dockwidget.label_info)
            self.generate_csv_reports("Wszystkie stanowiska, w których odstąpiono od monitoringu posiadają uzasadnie rezygnacji (odstąpnia)", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0223_wykaz_stanowiska_bez_uzasadnienia_rezygnacji_OK.csv")
            self.dockwidget.pushButton_missing_resigantion_cause.setStyleSheet('QPushButton {background-color: #3cb371}')


    # C_0224
    def control_coordinates_extend_pl(self):

        list = self.getListOfAreaByQuery("SELECT DISTINCT s.stanowisko_nr "
                                         "FROM stanowisko s join sl_siedlisko ss on s.siedlisko_cd=ss.siedlisko_cd join stanowisko_rok sr on s.stanowisko_nr = sr.stanowisko_nr "
                                         "WHERE projekt_fl "
                                         "and (not coalesce(cast(replace(x,',','.') as float),0) between 49.002046518 "
                                         "and 54.836416667 or not coalesce(cast(replace(y,',','.') as float),0) between 14.12288486 "
                                         "and 24.145783075 or not coalesce(cast(replace(z,',','.') as float),-100) between -2 and 2499 );")

        if len(list) > 0:
            self.appendDataToLabel("", self.dockwidget.label_warning)
            self.appendDataToLabel("Współrzędne poza teoretycznym zasięgiem projektu (zasięg PL, -3<h<2500):", self.dockwidget.label_warning)
            for data_dbase in list:
                self.appendDataToLabel(str(data_dbase), self.dockwidget.label_warning)
            self.generate_csv_reports("Współrzędne poza teoretycznym zasięgiem projektu (zasięg PL, -3<h<2500):", ["ID_STANOWISKA"], list, "monitoring_gis_tools_raporty_kontroli", "0224_wykaz_wspolrzedne_poza_PL.csv")
            self.dockwidget.pushButton_invalid_coordinates.setStyleSheet('QPushButton {background-color: #ff0000}')
        else:
            self.appendDataToLabel("Prawdopodobnie wszystkie współrzędne znajdują się w zasięgu opracowania", self.dockwidget.label_info)
            self.generate_csv_reports("Prawdopodobnie wszystkie współrzędne znajdują się w zasięgu opracowania", ["ID_STANOWISKA"],list, "monitoring_gis_tools_raporty_kontroli", "0224_wykaz_wspolrzedne_poza_PL_OK.csv")
            self.dockwidget.pushButton_invalid_coordinates.setStyleSheet('QPushButton {background-color: #3cb371}')






    # C_0301  C_03011 C_03012 C_03013
    def compatibilyty_check_tools(self):

        # Clear info labels
        self.clear_info_labels()

        # Dbase address
        d_base = str(self.dockwidget.lineEdit_dBase_directory.text()).replace('\\', '/')

        # check if base exist
        if not (str(d_base)):
            self.dockwidget.label_warning.setText("Nie wskazano bazy danych!")
            return False

        # Declare connections
        conn = sqlite3.connect(d_base)
        cursor = conn.cursor()

        cursor.execute("SELECT stanowisko_nr FROM stanowisko_rok;")
        rows = cursor.fetchall()

        layer = self.dockwidget.mMapLayerComboBoxAraesPolygon.currentLayer()

        if not (layer):
            self.dockwidget.label_warning.setText("Nie wskazano warstwy!")
            return False


        ara_list_from_dBase = []
        area_list_from_layer = []
        field_name = self.dockwidget.comboBoxFieldsName.currentText()
        field_area_id = layer.fields().indexFromName(field_name)
        #Exist in dbase, not exist in layer
        exist_in_both = []
        exist_id_dbase = []
        exist_is_layer = []

        for row in rows:
            ara_list_from_dBase.append(row[0])


        for f in layer.getFeatures():
            id = f.id()
            feat = layer.getFeature(id)
            area_list_from_layer.append(feat[field_area_id])



        for data_dbase in  ara_list_from_dBase:
            if data_dbase in area_list_from_layer:
                exist_in_both.append(data_dbase)
            else:
                exist_id_dbase.append(data_dbase)

        for data_layer in area_list_from_layer:
            if data_layer not in ara_list_from_dBase:
                exist_is_layer.append(data_layer)

        self.appendDataToLabel("Raporty kontroli (*.csv): " + self.get_file_directory() + "/monitoring_gis_tools_raporty_kontroli", self.dockwidget.label_info)

        self.appendDataToLabel("", self.dockwidget.label_info)
        self.appendDataToLabel("Powierzchnie istniejące zarówno w warstwie i w bazie danych:", self.dockwidget.label_info)
        print("Powierzchnie istniejące w warstwie i w bazie:")
        for data in exist_in_both:
            self.appendDataToLabel(str(data), self.dockwidget.label_info)
            print(str(data))
        self.generate_csv_reports("Powierzchnie istniejące zarówno w warstwie i w bazie danych", ["ID_STANOWISKA"], exist_in_both, "monitoring_gis_tools_raporty_kontroli", "03011_wykaz_powierzchni_zgodnych_mapa_baza.csv")



        self.appendDataToLabel("", self.dockwidget.label_warning)
        self.appendDataToLabel("Powierzchnie istniejące w bazie danych a nie istniejące w warstwie:", self.dockwidget.label_warning)
        print("Powierzchnie istniejące wyłącznie w bazie danych:")
        for data in exist_id_dbase:
            self.appendDataToLabel(str(data), self.dockwidget.label_warning)
            print(str(data))
        self.generate_csv_reports("Powierzchnie istniejące w bazie danych a nie istniejące w warstwie", ["ID_STANOWISKA"], exist_id_dbase, "monitoring_gis_tools_raporty_kontroli","03012_wykaz_powierzchni_isnt_wylacznie_w_bazie.csv")


        self.appendDataToLabel("", self.dockwidget.label_warning)
        self.appendDataToLabel("Powierzchnie istniejące w warstwie a nie istniejące w bazie danych:", self.dockwidget.label_warning)
        print("Powierzchnie istniejące wyłącznie w warstwie:")
        for data in exist_is_layer:
            self.appendDataToLabel(str(data), self.dockwidget.label_warning)
            print(str(data))
        self.generate_csv_reports("Powierzchnie istniejące w warstwie a nie istniejące w bazie danych", ["ID_STANOWISKA"], exist_is_layer, "monitoring_gis_tools_raporty_kontroli","03013_wykaz_powierzchni_isnt_wylacznie_w_warstwie.csv")


        if exist_is_layer or exist_id_dbase:
            self.dockwidget.pushButton_compatibilyty.setStyleSheet('QPushButton {background-color: #ff0000}')
        else:
            self.dockwidget.pushButton_compatibilyty.setStyleSheet('QPushButton {background-color: #3cb371}')


    def getListOfAreaByQuery(self, query):

        list = []

        # Clear info labels
        self.clear_info_labels()

        # Dbase address
        d_base = self.get_dBase_directory()
        if not d_base:
            print("Faill")
            return False

        conn = sqlite3.connect(d_base)
        cursor = conn.cursor()
        cursor.execute(query)
        rows = cursor.fetchall()
        for row in rows:
            print(row[0])
            list.append(row[0])
        return list


    def is_numeric_with_dots(self, input_str):
        # Define the regular expression pattern
        pattern = re.compile(r'^[0-9.]+$')
        # Use the search function to check if the pattern matches the input string
        match = pattern.search(input_str)
        # If a match is found, the input string contains only numeric characters and dots
        return bool(match)


    def is_numeric_and_length(self, input_str):
        # Check if the length is 10
        if len(input_str) == 10:
            # Check if all characters are digits
            if input_str.isdigit():
                return True
            else:
                return False
        else:
            return False


    def get_file_directory(self):
        # Dbase address
        d_base = str(self.dockwidget.lineEdit_dBase_directory.text()).replace('\\', '/')
        # check if base exist
        if not (str(d_base)):
            self.dockwidget.label_warning.setText("Nie wskazano bazy danych!")
            return False
        else:
            return os.path.dirname(d_base)


    def getLayer(self):
        layer = self.dockwidget.mMapLayerComboBoxAraesPolygon.currentLayer()
        if not (str(layer)):
            CustomMessageBox.showWithTimeout(10, "Nie wybrano warstwy!", "", icon=QMessageBox.Warning)
            self.dockwidget.label_warning.setText("Nie wybrano warstwy!")
            return False
        else:
            return layer


    def get_dBase_directory(self):
        # Dbase address
        d_base = str(self.dockwidget.lineEdit_dBase_directory.text()).replace('\\', '/')
        # check if base exist
        if not (str(d_base)):
            CustomMessageBox.showWithTimeout(10, "Nie wskazano bazy danych!", "", icon=QMessageBox.Warning)
            self.dockwidget.label_warning.setText("Nie wskazano bazy danych!")
            return False
        else:
            return d_base


    def generate_csv_reports(self, description, header, data,  folder_directory, report_name):

        if not os.path.exists(self.get_file_directory() + "/" + folder_directory):
            os.makedirs(self.get_file_directory() + "/" + folder_directory)

        current_date = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

        file_path = self.get_file_directory() + "/" + folder_directory + "/" + report_name

        data = [[str(item)] for item in data]

        with open(file_path, 'w', encoding='cp1250', newline='') as f:
            writer = csv.writer(f, delimiter=';')

            # write the header
            writer.writerow([description])
            writer.writerow(['Wygenerowano: ', current_date])
            writer.writerow("")
            writer.writerow(header)
            # write multiple rows
            writer.writerows(data)









    #--------------------------------------------------------------------------
    def run(self):
        """Run method that loads and starts the plugin"""



        if not self.pluginIsActive:
            self.pluginIsActive = True


            #print "** STARTING MonitoringTools"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = MonitoringToolsDockWidget()

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            self.comboBoxAraesPolygonSelectAction()

            # Odświeżanie ostatnio wykorzystanych ścieżek
            # Odświeżanie ostatnio wykorzystanych ścieżek
            self.dBaseDirectoryLoad()

            # Actions button click
            self.dockwidget.pushButton_select_dBase.clicked.connect(self.selectDbaseDirectory)
            self.dockwidget.pushButton_generate_point_layer.clicked.connect(self.generatePointLayer)
            self.dockwidget.pushButton_compatibilyty.clicked.connect(self.compatibilyty_check_tools)
            self.dockwidget.pushButtonNumerationValidatingLayer.clicked.connect(self.numeration_validating_map)
            self.dockwidget.pushButtonNumerationValidatingDBase.clicked.connect(self.numeration_validating_map_dBase)

            # T_0101
            self.dockwidget.pushButton_rewrite_area_to_dbase.clicked.connect(self.rewrite_area_to_dbase)

            # T_0103
            self.dockwidget.pushButton_add_coordinates_to_d_base.clicked.connect(self.add_coordinates_to_dbase)

            # C_0102
            self.dockwidget.pushButton_control_duplicates.clicked.connect(self.control_duplicates)

            self.dockwidget.pushButton_control_coordinates.clicked.connect(self.control_coordinates)
            self.dockwidget.pushButton_control_missing_gen_assasement.clicked.connect(self.missing_gen_assasement)
            self.dockwidget.pushButton_control_missing_par_assasement.clicked.connect(self.missing_par_assasement)
            self.dockwidget.pushButton_control_missing_gen_assasement_desc.clicked.connect(self.missing_gen_assasement_desc)
            self.dockwidget.pushButton_control_missing_par_assasement_desc.clicked.connect(self.missing_par_assasement_desc)
            self.dockwidget.pushButton_control_missing_indicators_assasement.clicked.connect(self.missing_indicators_assasement)
            self.dockwidget.pushButton_control_missing_indicators_assasement_desc.clicked.connect(self.missing_indicators_assasement_desc)
            # C_0210
            self.dockwidget.pushButton_control_missing_gen_assasement_exist_desc_assasement.clicked.connect(self.missing_gen_assasement_exist_desc_assasement)
            # 0213
            self.dockwidget.pushButton_control_missing_site_description.clicked.connect(self.missing_site_description)
            # 0214
            self.dockwidget.pushButton_control_missing_natural_values.clicked.connect(self.missing_natural_values)
            # 0215
            self.dockwidget.pushButton_missing_date_information.clicked.connect(self.missing_date_information)
            # 0216
            self.dockwidget.pushButton_missing_availability_information.clicked.connect(self.missing_availability_information)
            # 0217
            self.dockwidget.pushButton_missing_impacts.clicked.connect(self.missing_impacts)
            # 0218
            self.dockwidget.pushButton_missing_threats.clicked.connect(self.missing_threats)
            # 0219
            self.dockwidget.pushButton_missing_protectiv_actions.clicked.connect(self.missing_protectiv_actions)
            # 0220
            self.dockwidget.pushButton_missingelements_in_photo_documentation.clicked.connect(self.missing_elements_in_photo_doc)
            # 0221
            self.dockwidget.pushButton_compatibility_validation.clicked.connect(self.compatibility_validation)

            # C_0222
            self.dockwidget.pushButton_missing_resigantion_exist_resignation_cause.clicked.connect(self.missing_resigantion_exist_resignation_cause)

            # C_0223
            self.dockwidget.pushButton_missing_resigantion_cause.clicked.connect(self.missing_resigantion_cause)

            # C_0224
            self.dockwidget.pushButton_invalid_coordinates.clicked.connect(self.control_coordinates_extend_pl)



            self.dockwidget.mMapLayerComboBoxAraesPolygon.activated.connect(lambda: self.comboBoxAraesPolygonSelectAction())
            self.dockwidget.mMapLayerComboBoxAraesPolygon.layerChanged.connect(lambda: self.comboBoxAraesPolygonSelectAction())
            self.dockwidget.mMapLayerComboBoxAraesPolygon.currentIndexChanged.connect(self.comboBoxAraesPolygonSelectAction)


            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)
            self.dockwidget.show()
