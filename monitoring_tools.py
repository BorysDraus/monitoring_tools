# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MonitoringTools
                                 A QGIS plugin
 Wetlands Green Life Monitoring Tools
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-11-11
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Borys Draus
        email                : borys.draus@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from typing import List

from qgis import processing, PyQt
from qgis.core import QgsLayerTreeLayer, QgsPoint, QgsPointLocator, QgsSnappingConfig, QgsSnappingUtils, QgsTolerance, QgsProcessingFeatureSourceDefinition, QgsProcessingAlgorithm, QgsProcessingParameterFeatureSource, QgsProcessingParameterFeatureSink, QgsFeatureRequest, QgsSpatialIndex
from qgis.core import QgsVectorLayer, QgsFeature, QgsField, QgsCoordinateReferenceSystem,QgsCoordinateTransform, QgsGeometry, QgsPointXY, QgsField, QgsProject, Qgis, QgsProcessingFeedback, QgsExpression, edit, QgsExpressionContext, QgsExpressionContextUtils
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QLineEdit, QToolBar, QProgressDialog
from PyQt5.QtWidgets import QMessageBox, QWidget, QComboBox
from PyQt5.QtCore import QVariant, Qt,QFileInfo
from shapely import Polygon, unary_union, LineString, MultiLineString, Point, MultiPoint


from .control_model import ControlModel
from .TimerMessageBox import CustomMessageBox
# Initialize Qt resources from file resources.py
from .resources import *

from qgis._core import QgsWkbTypes, QgsMapLayer, QgsVectorFileWriter, QgsVectorDataProvider, QgsField, QgsRectangle, \
    QgsMapLayerProxyModel, QgsProcessing

import os
from qgis.core import QgsVectorFileWriter, QgsVectorLayer, QgsProject, QgsProcessingFeedback, QgsApplication, QgsProcessingContext
from qgis.PyQt.QtCore import QFileInfo

from datetime import datetime
import geopandas as gpd
from shapely.wkt import loads
from shapely.geometry import MultiPolygon
from qgis.core import QgsFeature

from matplotlib import pyplot as plt

from osgeo import gdal, ogr


from .atribute_table_manager import AtributeTableManager

# Import the code for the DockWidget
from .monitoring_tools_dockwidget import MonitoringToolsDockWidget
import sqlite3
import re
import os
import csv
from datetime import datetime

from qgis.core import QgsRasterLayer, QgsRasterBandStats
from qgis.analysis import QgsRasterCalculator, QgsRasterCalculatorEntry



class MonitoringTools:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'MonitoringTools_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&MonitoringTools')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'MonitoringTools')
        self.toolbar.setObjectName(u'MonitoringTools')

        #print "** INITIALIZING MonitoringTools"

        self.pluginIsActive = False
        self.dockwidget = None

        self.selected_year = datetime.now().year  # Initialize with the current year

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('MonitoringTools', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/monitoring_tools/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'MonitoringTools'),
            callback=self.run,
            parent=self.iface.mainWindow())



    #--------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING MonitoringTools"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD MonitoringTools"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&MonitoringTools'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar



    def appendDataToLabel(self, text_message, QLabel):
        text = QLabel.text()
        if text:
            print(text_message)
            QLabel.setText(text + "\n" + text_message)
        else:
            QLabel.setText(text_message)


    def clearPlainTextEditInfo(self):
        self.dockwidget.plainTextEdit_info.setPlainText("")

    def appendDataToPlainTextEdit(self, text_message, plain_text_edit):
        current_text = plain_text_edit.toPlainText().strip()  # Get current text and strip whitespace
        text_message = text_message.strip()  # Strip whitespace from the new message

        # Combine current text and new message, handling newline characters
        new_text = current_text + "\n" + text_message if current_text else text_message

        # Set the updated text to the QPlainTextEdit
        plain_text_edit.setPlainText(new_text)


    # Wskazanie bazy danych
    def selectDbaseDirectory(self):
        filename = QFileDialog.getOpenFileName(self.dockwidget, "Wskaż bazę danych: *.db", "", "*.db")
        if isinstance(filename, tuple):
            self.dockwidget.lineEdit_dBase_directory.setText(filename[0])
            # Wskazanie lokalizacji folderów z adresem
            dirnameOfCatalog = self.resolveDir('info')
            dirOfFile = dirnameOfCatalog + "/base_address.txt"
            file = open(dirOfFile, "w+")
            file.write(str(filename[0]))
            file.close()


    # Ladowanie adresu bazy po uruchomieniu aplikacji
    def dBaseDirectoryLoad(self):
        dirnameOfCatalog = self.resolveDir('info')
        dirOfFile = dirnameOfCatalog + "/base_address.txt"
        if os.path.isfile(dirOfFile):
            with open(dirOfFile) as f:
                f = f.readline()
                if os.path.exists(str(f)):
                    self.dockwidget.lineEdit_dBase_directory.setText(str(f))


    # Metoda zwraca lokalizację wskazanego folderu lub pliku
    def resolveDir(self, name, basepath=None):
        if not basepath:
            basepath = os.path.dirname(os.path.realpath(__file__))
        return os.path.join(basepath, name)


    # Method for cear info label and warning label
    def clear_info_labels(self):
        self.dockwidget.label_info.setText("")
        self.dockwidget.label_warning.setText("")


    def comboBoxAraesPolygonSelectAction(self):
        self.dockwidget.mMapLayerComboBoxAraesPolygon.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.dockwidget.comboBoxFieldsName.clear()
        layer = self.dockwidget.mMapLayerComboBoxAraesPolygon.currentLayer()
        if layer != None:
            # Get the list of field names (column names)
            field_names = [field.name() for field in layer.fields()]
            self.dockwidget.comboBoxFieldsName.addItems(field_names)

    def populate_year_combobox(self):
        # Populate the combo box and set the current year as default.
        current_year = datetime.now().year
        start_year = 2023
        end_year = 2032
        # Clear any existing items
        self.dockwidget.comboBoxYear.clear()
        # Add the years to the combo box
        for year in range(start_year, end_year + 1):
            self.dockwidget.comboBoxYear.addItem(str(year))
        # Set the current year as the default selected item
        index = self.dockwidget.comboBoxYear.findText(str(current_year))
        if index != -1:
            self.dockwidget.comboBoxYear.setCurrentIndex(index)

    def update_selected_year(self):
        """Update the selected year when the combo box changes."""
        self.selected_year = int(self.dockwidget.comboBoxYear.currentText())

    # T_0101
    def generatePointLayer(self):

        # Clear info labels
        self.clear_info_labels()

        # Dbase address
        d_base = str(self.dockwidget.lineEdit_dBase_directory.text()).replace('\\', '/')

        # Clear warning massage
        self.dockwidget.label_warning.setText("")

        # check if base exist
        if not (str(d_base)):
            self.dockwidget.label_warning.setText("Nie wskazano bazy danych!")
            return False

        # Split dbase file name
        base_name = os.path.splitext(os.path.basename(d_base))[0]
        base_name_ext = os.path.basename(d_base)

        # Declare connections
        conn = sqlite3.connect(d_base)
        cursor = conn.cursor()

        # DBASE
        self.appendDataToLabel("", self.dockwidget.label_info)
        self.appendDataToLabel("BAZA DANYCH", self.dockwidget.label_info)
        # File name
        self.appendDataToLabel(base_name_ext, self.dockwidget.label_info)
        # Version
        cursor.execute("PRAGMA user_version;")
        sqlite_version = cursor.fetchone()[0]
        self.appendDataToLabel("Wersja bazy danych: " + str(sqlite_version), self.dockwidget.label_info)
        # Date range
        cursor.execute("SELECT MIN(data_oceny) FROM stanowisko_rok WHERE data_oceny IS NOT NULL AND data_oceny <> ''")
        date_from = cursor.fetchone()[0]
        cursor.execute("SELECT MAX(data_oceny) FROM stanowisko_rok WHERE data_oceny IS NOT NULL AND data_oceny <> ''")
        date_to = cursor.fetchone()[0]
        if date_from is None:
            date_from = "?"
        if date_to is None:
            date_to = "?"
        self.appendDataToLabel("Zakres dat: " + date_from + "  -  " + date_to, self.dockwidget.label_info)

        # EXPERT
        self.appendDataToLabel("", self.dockwidget.label_info)
        self.appendDataToLabel("DANE WYKONAWCY", self.dockwidget.label_info)
        cursor.execute(
            "SELECT DISTINCT stanowisko_rok_ekspert.email, sl_ekspert.imie, sl_ekspert.nazwisko, sl_ekspert.instytucja_cd, sl_ekspert.telefon "
            "FROM stanowisko_rok_ekspert "
            "INNER JOIN sl_ekspert on stanowisko_rok_ekspert.email = sl_ekspert.email")
        rows = cursor.fetchall()
        for row in rows:
            self.appendDataToLabel("Wykonawca: " + row[1] + " " + row[2], self.dockwidget.label_info)
            self.appendDataToLabel(row[3], self.dockwidget.label_info)
            self.appendDataToLabel("Tel: " + row[4], self.dockwidget.label_info)
            self.appendDataToLabel("E-mail: " + row[0], self.dockwidget.label_info)

        # CALCULATED COORDINATES INFORMATIONS
        self.appendDataToLabel("", self.dockwidget.label_info)
        self.appendDataToLabel("KARTY POWIERZCHNI MONITORINGOWYCH", self.dockwidget.label_info)
        cursor.execute("SELECT * FROM stanowisko_rok")
        rows = cursor.fetchall()
        self.appendDataToLabel("Liczba powierzchni: " + str(len(rows)), self.dockwidget.label_info)
        cursor.execute("SELECT * FROM stanowisko_rok WHERE x != '' and y != '' and x > 0 and y >0")
        rows = cursor.fetchall()
        self.appendDataToLabel("Liczba powierzchni ze współrzędnymi: " + str(len(rows)), self.dockwidget.label_info)

        # Information about established and rejected surfaces
        cursor.execute("SELECT COUNT(*) FROM stanowisko_rok WHERE stanowisko_rok.rezygnacja_fl != 1;")
        row_count = cursor.fetchone()[0]
        self.appendDataToLabel("Liczba powierzchni założonych: " + str(row_count), self.dockwidget.label_info)
        cursor.execute("SELECT COUNT(*) FROM stanowisko_rok WHERE stanowisko_rok.rezygnacja_fl = 1;")
        row_count = cursor.fetchone()[0]
        self.appendDataToLabel("Liczba powierzchni odrzuconych: " + str(row_count), self.dockwidget.label_info)

        # DATA FOR POINT LAYER
        cursor.execute("SELECT stanowisko.stanowisko_nr,"
                       " stanowisko.stanowisko_nm,"
                       " stanowisko.siedlisko_cd,"
                       " stanowisko.siedlisko_plan_cd,"
                       " stanowisko.siedlisko_lp_cd,"
                       " stanowisko.zgodnosc_cd,"
                       " stanowisko_rok.x,"
                       " stanowisko_rok.y,"
                       " stanowisko_rok_ekspert.email,"
                       " sl_ekspert.instytucja_cd,"
                       " stanowisko_rok.data_oceny,"
                       " stanowisko_rok.ocena_cd "
                       "FROM stanowisko INNER JOIN stanowisko_rok "
                       "ON stanowisko.stanowisko_nr = stanowisko_rok.stanowisko_nr  "
                       "INNER JOIN stanowisko_rok_ekspert "
                       "ON stanowisko_rok.stanowisko_nr = stanowisko_rok_ekspert.stanowisko_nr and stanowisko_rok.rok = stanowisko_rok_ekspert.rok "
                       "INNER JOIN sl_ekspert ON stanowisko_rok_ekspert.email = sl_ekspert.email "
                       "WHERE x != '' and y != '' and x > 0 and y >0")

        # Fetch all the rows from the result set
        rows = cursor.fetchall()

        vl = QgsVectorLayer("Point", base_name + "_pkt_monit", "memory")
        pr = vl.dataProvider()
        # Enter editing mode
        vl.startEditing()
        # add fields
        pr.addAttributes([QgsField("ID_STAN", QVariant.Int),
                          QgsField("NZW_STAN", QVariant.String),
                          QgsField("SIEDL", QVariant.String),
                          QgsField("SIEDL_PLAN", QVariant.String),
                          QgsField("SIEDL_LP", QVariant.String),
                          QgsField("KOD_ZGODN", QVariant.String),
                          QgsField("X", QVariant.Double),
                          QgsField("Y", QVariant.Double),
                          QgsField("E_MAIL", QVariant.String),
                          QgsField("BUL_ODDZ", QVariant.String),
                          QgsField("DATA", QVariant.String),
                          QgsField("OCENA", QVariant.String)])

        for row in rows:

            x_str = row[7]
            y_str = row[6]

            x = 0
            y = 0

            if self.is_numeric_with_dots(str(x_str)):
                x = float(x_str)
            else:
                self.appendDataToLabel(
                    "Błędne wartości współrzędnych w bazie danych: " + str(x_str) + " Stanowisko:" + str(row[0]),
                    self.dockwidget.label_warning)
                continue

            if self.is_numeric_with_dots(str(y_str)):
                y = float(y_str)
            else:
                self.appendDataToLabel(
                    "Błędne wartości współrzędnych w bazie danych: " + str(y_str) + " Stanowisko:" + str(row[0]),
                    self.dockwidget.label_warning)
                continue

            fet = QgsFeature()
            fet.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(x, y)))

            fet.setAttributes([row[0], row[1], row[2], row[3], row[4], row[5], x, y, row[8], row[9], row[10], row[11]])

            pr.addFeatures([fet])

        # Commit changes
        vl.commitChanges()
        vl.renderer().symbol().setSize(2)
        vl.triggerRepaint()

        # Close the cursor and connection
        cursor.close()
        conn.close()

        # Show in project
        QgsProject.instance().addMapLayer(vl)


    # T_0102
    def rewrite_area_to_dbase(self):

        # Clear info labels
        self.clear_info_labels()

        # Dbase
        d_base = self.get_dBase_directory()
        if not d_base:
            return False

        # Layer
        layer = self.getLayer()
        if not layer:
            return False

        CustomMessageBox.showWithTimeout(10, "Obliczanie powierzchni poligonów...", "", icon=QMessageBox.Information)
        self.appendDataToLabel("Obliczanie powierzchni poligonów...", self.dockwidget.label_info)

        # Connection settings
        conn = sqlite3.connect(d_base)
        cursor = conn.cursor()

        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, layer, "AREA_HA", QVariant.Double)
        layer_provider = layer.dataProvider()
        layer_fields = layer.fields()
        field_area = layer_fields.indexFromName("AREA_HA")
        features_of_layer = layer.getFeatures()
        total_features = layer.featureCount()
        area_list_from_layer = []
        list_of_subarea = []
        field_name = self.dockwidget.comboBoxFieldsName.currentText()
        field_area_id = layer.fields().indexFromName(field_name)


          # Create a progress dialog
        progress_dialog = QProgressDialog("Processing...", "Cancel", 0, total_features)
        progress_dialog.setWindowModality(2)  # Make the dialog modal
        progress_dialog.show()



        for f in features_of_layer:
            id = f.id()
            feat = layer.getFeature(id)

            progress_dialog.setValue(id)

            # SUBAREA
            geom = f.geometry()
            area = geom.area() / 10000
            area = round(area, 2)
            attr_value_subarea = {field_area: area}
            layer_provider.changeAttributeValues({id: attr_value_subarea})
            area_list_from_layer.append(feat[field_area_id])
            list_of_subarea.append(area)

        layer.commitChanges()


        # Info
        CustomMessageBox.showWithTimeout(5, "Obliczono powierzchnię poligonów warstwy wektorowej", "", icon=QMessageBox.Information)
        self.appendDataToLabel("Obliczono powierzchnię poligonów warstwy wektorowej", self.dockwidget.label_info)

        for index, area in enumerate(area_list_from_layer):

            area_id = area_list_from_layer[index]
            subarea = list_of_subarea[index]

            print(str(area_id) + ":" + str(subarea))

            update_query = f"UPDATE stanowisko_rok SET powierzchnia = {subarea} WHERE stanowisko_nr = {area_id}"
            cursor.execute(update_query)

            conn.commit()


        CustomMessageBox.showWithTimeout(5, "Zaktualizowano powierzchnię w bazie danych...", "", icon=QMessageBox.Information)
        self.appendDataToLabel("Zaktualizowano powierzchnię w bazie danych...", self.dockwidget.label_info)

        self.dockwidget.pushButton_rewrite_area_to_dbase.setStyleSheet('QPushButton {background-color: #3cb371}')

        cursor.close()
        conn.close()

        progress_dialog.setValue(total_features)
        progress_dialog.close()


    # T_0103
    def add_coordinates_to_dbase(self):

        # # Specify the EPSG code for the desired project coordinate system (e.g., WGS 84)
        # new_project_crs_epsg = 4326
        # # Define the new project coordinate reference system
        # new_project_crs = QgsCoordinateReferenceSystem(new_project_crs_epsg, QgsCoordinateReferenceSystem.EpsgCrsId)
        # # Set the new coordinate system for the project
        # QgsProject.instance().setCrs(new_project_crs)


        # Clear info labels
        self.clear_info_labels()

        # Dbase
        d_base = self.get_dBase_directory()
        if not d_base:
            return False
        # Connection settings
        conn = sqlite3.connect(d_base)
        cursor = conn.cursor()


        # Layer
        layer = self.getLayer()
        if not layer:
            return False
        field_name = self.dockwidget.comboBoxFieldsName.currentText()
        field_area_id = layer.fields().indexFromName(field_name)
        list_of_centroid_values = []

        # Check if the layer is valid
        if not layer.isValid():
            print("Layer failed to load!")

        # Set layer scr to 2180
        crs = layer.crs()
        crs.createFromId(2180)
        layer.setCrs(QgsCoordinateReferenceSystem(crs))


        # Transform CRS from 2180 to 4326
        transform = QgsCoordinateTransform(QgsCoordinateReferenceSystem("EPSG:2180"), QgsCoordinateReferenceSystem("EPSG:4326"), QgsProject.instance())


        # Get the centroid coordinates of each feature
        for feature in layer.getFeatures():
            geometry = feature.geometry()
            if layer.type() == QgsMapLayer.VectorLayer and (layer.wkbType() == QgsWkbTypes.Polygon or layer.wkbType() == QgsWkbTypes.MultiPolygon):

                id = feature.id()
                feat = layer.getFeature(id)
                area_id = feat[field_area_id]

                # Calculate centroid
                centroid = geometry.centroid().asPoint()
                # Transform the coordinates to WGS 84
                centroid_wgs84 = transform.transform(centroid)

                # Update the records
                update_query = """UPDATE stanowisko_rok SET x = ?, y = ? 
                WHERE stanowisko_nr = ? AND coalesce(cast(x as int), 0)=0 or coalesce(cast(y as int), 0)=0"""


                # Execute the update query
                cursor.execute(update_query, (centroid_wgs84.y(), centroid_wgs84.x(), area_id))

                # Execute the update query
                # cursor.execute(update_query)

                # Commit the changes
                conn.commit()

                print(
                    f"Feature {feature.id()}: Centroid Coordinates (WGS 84) - Latitude: {centroid_wgs84.y()}, Longitude: {centroid_wgs84.x()}")
            else:
                continue

        conn.close()
        CustomMessageBox.showWithTimeout(5, "Zaktualizowano brakujce współrzędne w bazie danych.", "", icon=QMessageBox.Information)
        self.appendDataToLabel("Zaktualizowano brakujce współrzędne w bazie danych.", self.dockwidget.label_info)
        self.dockwidget.pushButton_add_coordinates_to_d_base.setStyleSheet('QPushButton {background-color: #3cb371}')


    # T_0104
    def corect_compatibility(self):

        # Clear info labels
        self.clear_info_labels()

        # Dbase
        d_base = self.get_dBase_directory()
        if not d_base:
            return False
        # Connection settings
        conn = sqlite3.connect(d_base)
        cursor = conn.cursor()


        try:

            # Update 01
            update_query = "update stanowisko set zgodnosc_cd=1 where siedlisko_cd in (select siedlisko_cd from sl_siedlisko where projekt_fl) and coalesce(zgodnosc_cd,0) in (0,'') and siedlisko_plan_cd=siedlisko_cd;"
            cursor.execute(update_query)
            conn.commit()

            # Update 08
            update_query = "update stanowisko set zgodnosc_cd=8 where siedlisko_cd in (select siedlisko_cd from sl_siedlisko where projekt_fl) and coalesce(zgodnosc_cd,0) in (0,'') and siedlisko_lp_cd=siedlisko_cd and siedlisko_plan_cd in (select siedlisko_cd from sl_siedlisko where not projekt_fl);"
            cursor.execute(update_query)
            conn.commit()

            # Update 09
            update_query = "update stanowisko set zgodnosc_cd=9 where coalesce(zgodnosc_cd,0) in (0,'') and siedlisko_plan_cd in (select siedlisko_cd from sl_siedlisko where not projekt_fl) and siedlisko_lp_cd in (select siedlisko_cd from sl_siedlisko where projekt_fl) and siedlisko_cd='brak'"
            cursor.execute(update_query)
            conn.commit()

        except Exception as e:
            CustomMessageBox.showWithTimeout(5, "Proces zakończył się niepowodzeniem!", "", icon=QMessageBox.Warning)
            self.appendDataToLabel("Proces zakończył się niepowodzeniem!", self.dockwidget.label_warning)
            self.dockwidget.pushButton_correct_compatibility.setStyleSheet('QPushButton {background-color: #ff0000}')
            conn.rollback()
            return False
        finally:
            cursor.close()
            conn.close()

        CustomMessageBox.showWithTimeout(5, "Proces zakończył się powodzeniem!", "", icon=QMessageBox.Information)
        self.appendDataToLabel("Proces zakończył się powodzeniem!", self.dockwidget.label_info)
        self.dockwidget.pushButton_correct_compatibility.setStyleSheet('QPushButton {background-color: #3cb371}')




    # T_0105
    def asign_n2000_to_dbase(self):



        self.removeMapLayerByName('N2000_PL')

        # Input data - user layer
        layer = self.getLayer()
        crs = layer.crs()
        crs.createFromId(2180)
        layer.setCrs(QgsCoordinateReferenceSystem(crs))
        if not layer.isValid():
            print(f"Layer '{layer}' is not valid.")
            CustomMessageBox.showWithTimeout(10, "Warstwa jest niepoprawna...", "", icon=QMessageBox.Information)
            return False
        field_name = self.dockwidget.comboBoxFieldsName.currentText()
        AtributeTableManager.removeColumnToLayerByLayerInstance(self, layer, "kod_n2000")
        # 01 REPAIR GEOMETRY
        result = processing.run("native:fixgeometries", {'INPUT': layer, 'OUTPUT': 'memory:'})
        repair_geom_user_layer = result['OUTPUT']


        # Input data N2000 layer
        dirnameOfCatalog = self.resolveDir('soo_layer')
        geopackage_path =  dirnameOfCatalog + "/N2000_PL.gpkg"
        natura2000_layer = self.iface.addVectorLayer(geopackage_path, "N2000_PL", "ogr")
        if not natura2000_layer:
            print("Layer failed to load!")
            return False


        # Create common part of layers
        result = processing.run("native:intersection", {
            'INPUT': repair_geom_user_layer,
            'OVERLAY': natura2000_layer,
            'INPUT_FIELDS': [], 'OVERLAY_FIELDS': [], 'OVERLAY_FIELDS_PREFIX': '', 'OUTPUT': 'memory:',
            'GRID_SIZE': None})
        common_part_layer = result['OUTPUT']
        common_part_layer.setName('w_N2000')


        # Create external part
        result = processing.run("native:difference", {
            'INPUT': repair_geom_user_layer,
            'OVERLAY': natura2000_layer,
            'OUTPUT': 'memory:',
            'GRID_SIZE': None})
        difference_layer = result['OUTPUT']
        difference_layer.setName('poza_N2000')

        # 03 MERGE
        result = processing.run("native:mergevectorlayers", {'LAYERS': [common_part_layer, difference_layer], 'CRS': None, 'OUTPUT': 'memory:'})
        merge_layer = result['OUTPUT']
        merge_layer.setName('w_poza_N2000')
        # QgsProject.instance().addMapLayer(merge_layer)


        # 04 AGREGATE
        # result = processing.run("native:dissolve", {
        #     'INPUT': merge_layer,
        #     'FIELD': [field_name, 'kod_n2000'], 'SEPARATE_DISJOINT': False, 'OUTPUT': 'memory:'})
        # dissolve_layer = result['OUTPUT']
        # dissolve_layer.setName('bledy_zasiegu')


        # Disolve by ID_STAN and N2000 layer
        # result = processing.run("native:dissolve", {
        #     'INPUT': common_part_layer,
        #     'FIELD': [field_name, 'kod_n2000'], 'SEPARATE_DISJOINT': False, 'OUTPUT': 'memory:'})
        # dissolve_layer = result['OUTPUT']
        # dissolve_layer.setName('stanowisko_n2000')

        result = processing.run("native:dissolve", {
            'INPUT': merge_layer,
            'FIELD': [field_name, 'kod_n2000'], 'SEPARATE_DISJOINT': False, 'OUTPUT': 'memory:'})
        dissolve_layer = result['OUTPUT']
        dissolve_layer.setName('stanowisko_n2000')



        # Duplicates controll with information
        # Get the index of the column
        column_index = dissolve_layer.fields().indexFromName(field_name)

        # Create a dictionary to store the count of each attribute value
        attribute_count = {}

        # Iterate through features in the layer
        for feature in dissolve_layer.getFeatures():
            # Get the attribute value for the specified column
            attribute_value = feature[column_index]

            # Update the count in the dictionary
            if attribute_value in attribute_count:
                attribute_count[attribute_value] += 1
            else:
                attribute_count[attribute_value] = 1

        # Identify duplicate attribute values
        duplicate_values = [value for value, count in attribute_count.items() if count > 1]

        if len(duplicate_values) > 0:
            CustomMessageBox.showInfoCustomMessageBox(
                "W warstwie znajdują się płaty występujące jednocześnie w kilku obszarach Natura 2000!"
                "\n\n"
                "Wykonaj kontrolę C_0104 i popraw zasięg płatów!"
                "\n\nDo stanowiska znajdującego się w obrębie kilku obszarów N2000 zostanie przypisany obszar N2000 o największej powierzchni."
                "\n\nLista powierzchni występujących w kilku płatach znajduje się w raporcie kontroli.",
                "Przypisanie obszarów N2000 do bazy.",
                icon=QMessageBox.Information)
            self.generate_csv_reports('Stanowiska występujące jednocześnie w kilku obszarach N2000:', ["ID_STANOWISKA"],duplicate_values, "monitoring_gis_tools_raporty_kontroli", "T_0105_stanowiska_w_kilku_ob_N2000.csv")



        # Calculate area
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, dissolve_layer, "AREA_HA", QVariant.Double)
        layer_provider = dissolve_layer.dataProvider()
        # layer_fields = dissolve_layer.fields()
        column_area = dissolve_layer.fields().indexFromName("AREA_HA")
        column_n2000 = dissolve_layer.fields().indexFromName("kod_n2000")
        features_of_layer = dissolve_layer.getFeatures()


        for f in features_of_layer:
            id = f.id()
            # SUBAREA
            geom = f.geometry()
            area = geom.area() / 10000
            area = round(area, 2)
            attr_value_subarea = {column_area: area}
            layer_provider.changeAttributeValues({id: attr_value_subarea})

        dissolve_layer.commitChanges()

        # Remove smaller part
        max_area_dict = {}


        # Iterate over features and update the max 'AREA' for each 'ID'
        for feature in dissolve_layer.getFeatures():
            id_value = feature.attributes()[column_index]
            area_value = feature.attributes()[column_area]

            if id_value not in max_area_dict or area_value > max_area_dict[id_value]:
                max_area_dict[id_value] = area_value

        # Create a list of feature IDs to keep
        features_to_keep = []
        for feature in dissolve_layer.getFeatures():
            id_value = feature.attributes()[column_index]
            area_value = feature.attributes()[column_area]

            if area_value == max_area_dict[id_value]:
                features_to_keep.append(feature.id())

        # Set the selected features in the original layer
        dissolve_layer.selectByIds(features_to_keep)
        # Reverse the current selection
        dissolve_layer.invertSelection()

        # Delete the selected features
        dissolve_layer.startEditing()
        dissolve_layer.deleteSelectedFeatures()
        dissolve_layer.commitChanges()

        # Remove data from dBase
        try:
            # Dbase
            d_base = self.get_dBase_directory()
            if not d_base:
                CustomMessageBox.showWithTimeout(5, "Brak dostępu do bazy danych bazie danych.", "", icon=QMessageBox.Information)
                self.dockwidget.pushButton_asign_n2000_to_dbase.setStyleSheet('QPushButton {background-color: #ff0000}')
                return False

            conn = sqlite3.connect(d_base)
            cursor = conn.cursor()

            sql_query = """DELETE FROM stanowisko_rok_forma_op
                           WHERE forma_ochrony_przyrody_cd LIKE 'n2kh%'
                              OR forma_ochrony_przyrody_cd LIKE 'n2kc%'
                              OR forma_ochrony_przyrody_cd LIKE 'PLH%'
                              OR forma_ochrony_przyrody_cd LIKE 'PLC%'
                              OR forma_ochrony_przyrody_cd LIKE 'None%'
                              OR forma_ochrony_przyrody_cd IS NULL
                              OR forma_ochrony_przyrody_cd = "";"""
            cursor.execute(sql_query)
            deleted_rows = cursor.rowcount
            conn.commit()
            CustomMessageBox.showWithTimeout(5, f"Usunięto {deleted_rows} przypisań do obszarów siedliskoskowych (PLH, PLC) z bazy danych.", "",icon=QMessageBox.Information)

        except sqlite3.Error as e:
            print(f"Error removing data from database: {e}")
            conn.rollback()
            self.dockwidget.pushButton_asign_n2000_to_dbase.setStyleSheet('QPushButton {background-color: #ff0000}')
            return False
        finally:
            conn.close()

        try:
            # Dbase
            d_base = self.get_dBase_directory()
            if not d_base:
                CustomMessageBox.showWithTimeout(5, "Brak dostępu do bazy danych bazie danych.", "", icon=QMessageBox.Information)
                return False

            conn = sqlite3.connect(d_base)
            cursor = conn.cursor()

            total_inserted_rows = 0

            for feature in dissolve_layer.getFeatures():
                id = feature.id()
                feat = dissolve_layer.getFeature(id)
                area_id = feat[column_index]
                n2000 = feat[column_n2000]

                stanowisko_value = area_id
                rok_value = self.selected_year

                forma_ochrony_przyrody_cd_value = n2000


                if n2000 is not None and n2000.startswith("PLH"):
                    forma_ochrony_przyrody_cd_value = 'n2kh_' +  n2000
                elif n2000 is not None and n2000.startswith("PLC"):
                    forma_ochrony_przyrody_cd_value = 'n2kc_' +  n2000

                # Define the SQL query to insert a new row
                if n2000 is not None:
                    sql_query = f"""INSERT INTO stanowisko_rok_forma_op (stanowisko_nr, rok, forma_ochrony_przyrody_cd) VALUES ('{stanowisko_value}', {rok_value}, '{forma_ochrony_przyrody_cd_value}');"""
                    cursor.execute(sql_query)
                    total_inserted_rows += cursor.rowcount

            conn.commit()

        except sqlite3.Error as e:
            print(f"Error adding data to database: {e}")
            conn.rollback()
            self.dockwidget.pushButton_asign_n2000_to_dbase.setStyleSheet('QPushButton {background-color: #ff0000}')
            return False

        finally:
            conn.close()
            CustomMessageBox.showWithTimeout(5, f"Dodano {total_inserted_rows} przypisań do obszarów siedliskoskowych (PLH, PLC) z warstwy do bazy danych.", "",icon=QMessageBox.Information)

        # Join layers and rewrite data between columns
        CustomMessageBox.showWithTimeout(5, "Przepisywanie kodu obszaru do warstwy siedlisk (kolumna 'kod_n2000')...", "",icon=QMessageBox.Information)
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, layer, "kod_n2000", QVariant.String)
        AtributeTableManager.rewriteDataBetweenLayers(self, dissolve_layer, layer,  "kod_n2000", field_name, field_name)


        CustomMessageBox.showWithTimeout(5, "Zaktualizowano kody obszarów N2000 w bazie danych.", "", icon=QMessageBox.Information)
        self.dockwidget.pushButton_asign_n2000_to_dbase.setStyleSheet('QPushButton {background-color: #3cb371}')

        # Add layers to project
        # QgsProject.instance().addMapLayer(common_part_layer)
        # QgsProject.instance().addMapLayer(dissolve_layer)


    # T0106
    def repair_geometry_cet_crs(self):

        layer = self.getLayer()
        crs = layer.crs()
        crs.createFromId(2180)
        layer.setCrs(QgsCoordinateReferenceSystem(crs))

        result = processing.run("native:fixgeometries", {'INPUT': layer, 'OUTPUT': 'memory:'})
        repair_geom_user_layer = result['OUTPUT']

        if repair_geom_user_layer:

            layer.startEditing()

            layer.deleteFeatures([f.id() for f in layer.getFeatures()])

            for feature in repair_geom_user_layer.getFeatures():
                layer.addFeature(feature)

            layer.commitChanges()

            print("Geometry repaired in the source layer successfully")

            layer.reload()
        else:
            print("Error fixing geometries")

    # T_0107
    def round_geometry(self):


        layer = self.getLayer()
        crs = layer.crs()
        crs.createFromId(2180)
        layer.setCrs(QgsCoordinateReferenceSystem(crs))
        layer_path = layer.source()

        # Load the layer into a GeoDataFrame
        gdf = gpd.read_file(layer_path)

        # Function to round coordinates of a geometry
        def round_coordinates(geometry, precision=2):
            if geometry.geom_type == 'Point':
                return Point(round(geometry.x, precision), round(geometry.y, precision))
            elif geometry.geom_type == 'LineString' or geometry.geom_type == 'LinearRing':
                return geometry.__class__(
                    [Point(round(coord[0], precision), round(coord[1], precision)) for coord in geometry.coords])
            elif geometry.geom_type == 'Polygon':
                exterior = round_coordinates(geometry.exterior, precision)
                interiors = [round_coordinates(interior, precision) for interior in geometry.interiors]
                return Polygon(exterior, interiors)
            elif geometry.geom_type == 'MultiPoint':
                return MultiPoint([round_coordinates(point, precision) for point in geometry])
            elif geometry.geom_type == 'MultiLineString':
                return MultiLineString([round_coordinates(line, precision) for line in geometry])
            elif geometry.geom_type == 'MultiPolygon':
                return MultiPolygon([round_coordinates(polygon, precision) for polygon in geometry.geoms])
            else:
                raise ValueError(f"Unsupported geometry type: {geometry.geom_type}")

        # Round coordinates of each geometry in the GeoDataFrame
        gdf['geometry'] = gdf['geometry'].apply(round_coordinates)

        # Write the modified GeoDataFrame back to the same shapefile
        gdf.to_file(layer_path, driver='ESRI Shapefile')
        layer.reload()

        # Refresh the QGIS layer to reflect the changes
        layer.triggerRepaint()

    def snap_vertices_to_rezerwaty(self):
        self.appendDataToPlainTextEdit("Starting snapping process...", self.dockwidget.plainTextEdit_info)

        self.removeMapLayerByName('N2000_PL')
        self.removeMapLayerByName('rezerwaty_PL')

        # Input data - user layer
        layer_to_snap = self.getLayer()
        self.appendDataToPlainTextEdit("Got layer to snap: " + layer_to_snap.name(), self.dockwidget.plainTextEdit_info)

        crs = layer_to_snap.crs()
        crs.createFromId(2180)
        layer_to_snap.setCrs(QgsCoordinateReferenceSystem(crs))

        # Get snapping tolerance from the GUI input
        try:
            snap_tolerance = float(self.dockwidget.lineEdit_snap_tolerance.text().replace(",", "."))
        except ValueError:
            self.appendDataToPlainTextEdit("Invalid snapping tolerance value.", self.dockwidget.plainTextEdit_info)
            return

        self.appendDataToPlainTextEdit("Snapping tolerance: " + str(snap_tolerance), self.dockwidget.plainTextEdit_info)

        # Input data rezerwaty layer
        dirnameOfCatalog = self.resolveDir('rez_layer')
        geopackage_path = dirnameOfCatalog + "/rezerwaty_PL.gpkg"
        reserve_layer = self.iface.addVectorLayer(geopackage_path, "rezerwaty_PL", "ogr")
        reserve_layer.setCrs(QgsCoordinateReferenceSystem(crs))
        if not reserve_layer:
            self.appendDataToPlainTextEdit("Layer failed to load: " + geopackage_path, self.dockwidget.plainTextEdit_info)
            return False
        self.appendDataToPlainTextEdit("Loaded rezerwaty layer", self.dockwidget.plainTextEdit_info)

        # Input data N2000 layer
        dirnameOfCatalog = self.resolveDir('soo_layer')
        geopackage_path = dirnameOfCatalog + "/N2000_PL.gpkg"
        natura2000_layer = self.iface.addVectorLayer(geopackage_path, "N2000_PL", "ogr")
        if not natura2000_layer:
            self.appendDataToPlainTextEdit("Layer failed to load: " + geopackage_path, self.dockwidget.plainTextEdit_info)
            return False
        self.appendDataToPlainTextEdit("Loaded N2000 layer", self.dockwidget.plainTextEdit_info)

        if not reserve_layer.isValid() or not natura2000_layer.isValid():
            self.appendDataToPlainTextEdit("One of the layers is not valid.", self.dockwidget.plainTextEdit_info)
            return

        self.appendDataToPlainTextEdit("Snapping layers are valid", self.dockwidget.plainTextEdit_info)

        # Define snapping options
        snapping_config = QgsSnappingConfig()
        snapping_config.setEnabled(True)
        snapping_config.setTolerance(snap_tolerance)  # Set the snapping tolerance
        snapping_config.setType(QgsSnappingConfig.VertexAndSegment)
        snapping_config.setMode(QgsSnappingConfig.AdvancedConfiguration)

        # Set snapping environment to the "rezerwaty_PL" and "N2000_PL.gpkg" layers with priorities
        reserve_layer_settings = QgsSnappingConfig.IndividualLayerSettings(True, QgsSnappingConfig.VertexAndSegment,
                                                                           snap_tolerance,
                                                                           QgsTolerance.ProjectUnits)
        natura2000_layer_settings = QgsSnappingConfig.IndividualLayerSettings(True,
                                                                              QgsSnappingConfig.VertexAndSegment,
                                                                              snap_tolerance,
                                                                              QgsTolerance.ProjectUnits)

        snapping_config.setIndividualLayerSettings(reserve_layer, reserve_layer_settings)
        snapping_config.setIndividualLayerSettings(natura2000_layer, natura2000_layer_settings)

        # Enable snapping
        snapping_utils = self.iface.mapCanvas().snappingUtils()
        snapping_utils.setConfig(snapping_config)
        self.appendDataToPlainTextEdit("Snapping enabled", self.dockwidget.plainTextEdit_info)

        # Initialize progress dialog
        num_features = layer_to_snap.featureCount()
        progress_dialog = QProgressDialog("Snapping vertices...", "Cancel", 0, num_features)
        progress_dialog.setWindowTitle("Processing")
        progress_dialog.setWindowModality(Qt.WindowModal)
        progress_dialog.show()

        # Iterate through the features of the layer to snap
        for i, feature in enumerate(layer_to_snap.getFeatures()):
            if progress_dialog.wasCanceled():
                self.appendDataToPlainTextEdit("Process canceled by user.", self.dockwidget.plainTextEdit_info)
                break

            self.appendDataToPlainTextEdit("Processing feature: " + str(feature.id()), self.dockwidget.plainTextEdit_info)
            geom = feature.geometry()
            if geom:
                new_vertices = []
                for vertex in geom.vertices():
                    point_xy = QgsPointXY(vertex)
                    snapped_match = None

                    # Attempt to snap to the "rezerwaty" layer first
                    snapped_match = snapping_utils.snapToMap(point_xy)
                    if not snapped_match.isValid():
                        # If snapping to "rezerwaty" is not successful, attempt to snap to an edge
                        snapped_match = snapping_utils.snapToMap(point_xy)
                    if not snapped_match.isValid():
                        # If snapping to an edge in "rezerwaty" is not successful, attempt to snap to a vertex in "N2000_PL"
                        snapped_match = snapping_utils.snapToMap(point_xy)
                    if not snapped_match.isValid():
                        # If snapping to a vertex in "N2000_PL" is not successful, attempt to snap to an edge
                        snapped_match = snapping_utils.snapToMap(point_xy)

                    if snapped_match.isValid():
                        new_vertex = snapped_match.point()
                    else:
                        new_vertex = vertex
                    new_vertices.append(QgsPointXY(new_vertex))  # Ensure QgsPointXY objects

                # Update the geometry with snapped vertices
                new_geom = QgsGeometry.fromPolygonXY([new_vertices])
                layer_to_snap.dataProvider().changeGeometryValues({feature.id(): new_geom})

            # Update progress dialog
            progress_dialog.setValue(i + 1)

        # Close progress dialog
        progress_dialog.close()

        # Disable snapping after snapping is complete
        snapping_utils.setConfig(QgsSnappingConfig())

        # Refresh the map canvas to make the changes visible
        self.iface.mapCanvas().refreshAllLayers()

    # T_0108
    def prepare_structure(self):

        layer = self.getLayer()
        columnns_to_leave = ["NR_PLATU", "AREA_HA", "kod_n2000", "rez_przyr"]
        column_name = self.dockwidget.comboBoxFieldsName.currentText()
        column_index = layer.fields().indexFromName(column_name)

        AtributeTableManager.removeEachColumnExeptDeclaredByLayerInstance(self, layer, columnns_to_leave)

        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, layer, "SIEDL", QVariant.String)
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, layer, "SIEDL_PLAN", QVariant.String)
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, layer, "SIEDL_LP", QVariant.String)
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, layer, "ZGODN_KOD", QVariant.Int)
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, layer, "ZGODN_OPIS", QVariant.String)
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, layer, "ROK", QVariant.Int)
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, layer, "REZYGNACJA", QVariant.Int)
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, layer, "UZ_REYGN", QVariant.String)
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, layer, "WART_PRZYR", QVariant.String)
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, layer, "OPIS_SIEDL", QVariant.String)
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, layer, "ZARZ_TEREN", QVariant.String)
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, layer, "DATA_OCENY", QVariant.String)
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, layer, "PARAM_PS", QVariant.String)
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, layer, "PARAM_SSF", QVariant.String)
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, layer, "PARAM_PO", QVariant.String)
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, layer, "OCENA", QVariant.String)
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, layer, "OCENA_OPIS", QVariant.String)

        column_year = layer.fields().indexFromName("AREA_HA")

        # Dbase address
        d_base = str(self.dockwidget.lineEdit_dBase_directory.text()).replace('\\', '/')
        if not (str(d_base)):
            self.dockwidget.label_warning.setText("Nie wskazano bazy danych!")
            return False

        # Declare connections
        conn = sqlite3.connect(d_base)
        cursor = conn.cursor()

        cursor.execute(" SELECT s.stanowisko_nr, s.siedlisko_cd, s.siedlisko_plan_cd, s.siedlisko_lp_cd, s.zgodnosc_cd, sz.zgodnosc_nm, sr.rok, sr.rezygnacja_fl, sr.uzasadnienie_rezygnacji, sr.wartosci_przyrodnicze, sr.opis_siedliska, sr.zarzadzajacy_terenem, sr.data_oceny, MAX(CASE WHEN srp.parametr_cd = 'PS' OR srp.ocena_cd = '' THEN srp.ocena_cd ELSE NULL END) AS PS, MAX(CASE WHEN srp.parametr_cd = 'SF' OR srp.ocena_cd = '' THEN srp.ocena_cd ELSE NULL END) AS SF, MAX(CASE WHEN srp.parametr_cd = 'PO' OR srp.ocena_cd = '' THEN srp.ocena_cd ELSE NULL END) AS PO, sr.ocena_cd, sr.komentarz_ocena_stanu_ochrony FROM stanowisko s LEFT JOIN stanowisko_rok sr ON sr.stanowisko_nr = s.stanowisko_nr LEFT JOIN stanowisko_rok_parametr srp ON sr.stanowisko_nr = srp.stanowisko_nr AND sr.rok = srp.rok LEFT JOIN sl_zgodnosc sz ON s.zgodnosc_cd = sz.zgodnosc_cd GROUP BY sr.stanowisko_nr;")
        rows = cursor.fetchall()

        list = []

        for row in rows:
            list.append((row[0], row[1], row[2], row[3], row[4], row[5], row[6], row[7], row[8], row[9], row[10], row[11], row[12], row[13], row[14], row[15], row[16], row[17]))


        total_features = layer.featureCount()

        # Create a progress dialog
        progress_dialog = QProgressDialog("Processing...", "Cancel", 0, total_features)
        progress_dialog.setWindowModality(2)  # Make the dialog modal
        progress_dialog.show()


        layer.startEditing()
        layer_provider = layer.dataProvider()
        fields = layer.fields()

        for f in layer.getFeatures():
            id = f.id()
            feat = layer.getFeature(id)
            attribute_value = feat[column_index]

            progress_dialog.setValue(id)

            for data in list:
                if data[0] == attribute_value:

                    if(data[1]):
                        layer_provider.changeAttributeValues({id: {fields.indexFromName("SIEDL"): data[1]}})
                    if (data[2]):
                        layer_provider.changeAttributeValues({id: {fields.indexFromName("SIEDL_PLAN"): data[2]}})
                    if (data[3]):
                        layer_provider.changeAttributeValues({id: {fields.indexFromName("SIEDL_LP"): data[3]}})
                    if (data[4]):
                        layer_provider.changeAttributeValues({id: {fields.indexFromName("ZGODN_KOD"): data[4]}})
                    if(data[5]):
                        layer_provider.changeAttributeValues({id: {fields.indexFromName("ZGODN_OPIS"): data[5]}})
                    if (data[6]):
                        layer_provider.changeAttributeValues({id: {fields.indexFromName("ROK") : data[6]}})
                    if (data[7]):
                        layer_provider.changeAttributeValues({id: {fields.indexFromName("REZYGNACJA") : data[7]}})
                    if (data[8]):
                        layer_provider.changeAttributeValues({id: {fields.indexFromName("UZ_REYGN"): data[8]}})
                    if (data[9]):
                        layer_provider.changeAttributeValues({id: {fields.indexFromName("WART_PRZYR"): data[9]}})
                    if (data[10]):
                        layer_provider.changeAttributeValues({id: {fields.indexFromName("OPIS_SIEDL"): data[10]}})
                    if (data[11]):
                        layer_provider.changeAttributeValues({id: {fields.indexFromName("ZARZ_TEREN"): data[11]}})
                    if (data[12]):
                        layer_provider.changeAttributeValues({id: {fields.indexFromName("DATA_OCENY"): data[12]}})
                    if (data[13]):
                        layer_provider.changeAttributeValues({id: {fields.indexFromName("PARAM_PS"): data[13]}})
                    if (data[14]):
                        layer_provider.changeAttributeValues({id: {fields.indexFromName("PARAM_SSF"): data[14]}})
                    if (data[15]):
                        layer_provider.changeAttributeValues({id: {fields.indexFromName("PARAM_PO"): data[15]}})
                    if (data[16]):
                        layer_provider.changeAttributeValues({id: {fields.indexFromName("OCENA"): data[16]}})
                    if (data[17]):
                        layer_provider.changeAttributeValues({id: {fields.indexFromName("OCENA_OPIS"): data[17]}})


        layer.commitChanges()


        progress_dialog.setValue(total_features)
        progress_dialog.close()
        self.dockwidget.pushButton_prepare_structure.setStyleSheet('QPushButton {background-color: #3cb371}')



    # T_0109
    def asign_nature_reserve_to_dbase(self):


        self.removeMapLayerByName('rezerwaty_PL')

        # Input data - user layer
        layer = self.getLayer()
        crs = layer.crs()
        crs.createFromId(2180)
        layer.setCrs(QgsCoordinateReferenceSystem(crs))

        if not layer.isValid():
            print(f"Layer '{layer}' is not valid.")
            CustomMessageBox.showWithTimeout(10, "Warstwa jest niepoprawna...", "", icon=QMessageBox.Information)
            return False

        field_name = self.dockwidget.comboBoxFieldsName.currentText()
        AtributeTableManager.removeColumnToLayerByLayerInstance(self, layer, "rez_przyr")

        # 01 REPAIR GEOMETRY
        result = processing.run("native:fixgeometries", {'INPUT': layer, 'OUTPUT': 'memory:'})
        repair_geom_user_layer = result['OUTPUT']


        # Input data N2000 layer
        dirnameOfCatalog = self.resolveDir('rez_layer')
        geopackage_path =  dirnameOfCatalog + "/rezerwaty_PL.gpkg"
        nature_reserve_layer = self.iface.addVectorLayer(geopackage_path, "rezerwaty_PL", "ogr")
        nature_reserve_layer.setCrs(QgsCoordinateReferenceSystem(crs))

        if not nature_reserve_layer:
            print("Layer failed to load!")
            return False


        # Create common part of layers
        result = processing.run("native:intersection", {
            'INPUT': repair_geom_user_layer,
            'OVERLAY': nature_reserve_layer,
            'INPUT_FIELDS': [], 'OVERLAY_FIELDS': [], 'OVERLAY_FIELDS_PREFIX': '', 'OUTPUT': 'memory:',
            'GRID_SIZE': None})
        common_part_layer = result['OUTPUT']
        common_part_layer.setName('w_rezerwacie')


        # Create external part
        result = processing.run("native:difference", {
            'INPUT': repair_geom_user_layer,
            'OVERLAY': nature_reserve_layer,
            'OUTPUT': 'memory:',
            'GRID_SIZE': None})
        difference_layer = result['OUTPUT']
        difference_layer.setName('poza_rezerwatem')

        # 03 MERGE
        result = processing.run("native:mergevectorlayers", {'LAYERS': [common_part_layer, difference_layer], 'CRS': None, 'OUTPUT': 'memory:'})
        merge_layer = result['OUTPUT']
        merge_layer.setName('w_poza_rezerwatem')
        # QgsProject.instance().addMapLayer(merge_layer)


        result = processing.run("native:dissolve", {
            'INPUT': merge_layer,
            'FIELD': [field_name, 'rez_przyr'], 'SEPARATE_DISJOINT': False, 'OUTPUT': 'memory:'})
        dissolve_layer = result['OUTPUT']
        dissolve_layer.setName('stanowisko_rez_przyr')
        columnns_to_leave = ["NR_PLATU", "rez_przyr", "kodinspire"]
        AtributeTableManager.removeEachColumnExeptDeclaredByLayerInstance(self, dissolve_layer, columnns_to_leave)
        # QgsProject.instance().addMapLayer(dissolve_layer)


        # Duplicates controll with information
        # Get the index of the column
        column_index = dissolve_layer.fields().indexFromName(field_name)


        # Create a dictionary to store the count of each attribute value
        attribute_count = {}

        # Iterate through features in the layer
        for feature in dissolve_layer.getFeatures():
            # Get the attribute value for the specified column
            attribute_value = feature[column_index]

            # Update the count in the dictionary
            if attribute_value in attribute_count:
                attribute_count[attribute_value] += 1
            else:
                attribute_count[attribute_value] = 1

        # Identify duplicate attribute values
        duplicate_values = [value for value, count in attribute_count.items() if count > 1]
        print(duplicate_values)


        if len(duplicate_values) > 0:
            CustomMessageBox.showInfoCustomMessageBox(
                "W warstwie znajdują się płaty występujące jednocześnie w kilku rezerwatach przyrody, lub przecinają się w kilu miejscach z jednym rezerwatem przyrody!"
                "\n\n"
                "Wykonaj kontrolę C_0104 i popraw zasięg płatów!"
                "\n\nDo stanowiska znajdującego się w obrębie kilku rezerwatów zostanie przypisany rezerwat o największej powierzchni."
                "\n\nLista powierzchni występujących w kilku płatach znajduje się w raporcie kontroli.",
                "Przypisanie rezerwatów do bazy.",
                icon=QMessageBox.Information)
            self.generate_csv_reports('Stanowiska występujące jednocześnie w kilku rezerwatach przyrody:', ["ID_STANOWISKA"],duplicate_values, "monitoring_gis_tools_raporty_kontroli", "T_0109_stanowiska_w_rezerwatach_przyrody.csv")



        # Calculate area
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, dissolve_layer, "AREA_HA", QVariant.Double)
        layer_provider = dissolve_layer.dataProvider()
        # layer_fields = dissolve_layer.fields()
        column_area = dissolve_layer.fields().indexFromName("AREA_HA")
        column_nature_reserve = dissolve_layer.fields().indexFromName("rez_przyr")
        column_kod_inspire = dissolve_layer.fields().indexFromName("kodinspire")
        features_of_layer = dissolve_layer.getFeatures()


        for f in features_of_layer:
            id = f.id()
            # SUBAREA
            geom = f.geometry()
            area = geom.area() / 10000
            area = round(area, 2)
            attr_value_subarea = {column_area: area}
            layer_provider.changeAttributeValues({id: attr_value_subarea})

        dissolve_layer.commitChanges()

        # Remove smaller part
        max_area_dict = {}


        # Iterate over features and update the max 'AREA' for each 'ID'
        for feature in dissolve_layer.getFeatures():
            id_value = feature.attributes()[column_index]
            area_value = feature.attributes()[column_area]

            if id_value not in max_area_dict or area_value > max_area_dict[id_value]:
                max_area_dict[id_value] = area_value

        # Create a list of feature IDs to keep
        features_to_keep = []
        for feature in dissolve_layer.getFeatures():
            id_value = feature.attributes()[column_index]
            area_value = feature.attributes()[column_area]

            if area_value == max_area_dict[id_value]:
                features_to_keep.append(feature.id())

        # Set the selected features in the original layer
        dissolve_layer.selectByIds(features_to_keep)
        # Reverse the current selection
        dissolve_layer.invertSelection()

        # Delete the selected features
        dissolve_layer.startEditing()
        dissolve_layer.deleteSelectedFeatures()
        dissolve_layer.commitChanges()

        # Remove data from dBase
        try:
            # Dbase
            d_base = self.get_dBase_directory()
            if not d_base:
                CustomMessageBox.showWithTimeout(5, "Brak dostępu do bazy danych bazie danych.", "", icon=QMessageBox.Information)
                self.dockwidget.pushButton_asign_n2000_to_dbase.setStyleSheet('QPushButton {background-color: #ff0000}')
                return False

            conn = sqlite3.connect(d_base)
            cursor = conn.cursor()

            sql_query = """DELETE FROM stanowisko_rok_forma_op
                           WHERE forma_ochrony_przyrody_cd LIKE 'rp%'
                              OR forma_ochrony_przyrody_cd = "";"""
            cursor.execute(sql_query)
            deleted_rows = cursor.rowcount
            conn.commit()
            CustomMessageBox.showWithTimeout(5, f"Usunięto {deleted_rows} przypisań do rezerwatów przyrody z bazy danych.", "",icon=QMessageBox.Information)

        except sqlite3.Error as e:
            print(f"Error removing data from database: {e}")
            conn.rollback()
            self.dockwidget.pushButton_asign_nature_reserve_to_dbase.setStyleSheet('QPushButton {background-color: #ff0000}')
            return False
        finally:
            conn.close()

        try:
            # Dbase
            d_base = self.get_dBase_directory()
            if not d_base:
                CustomMessageBox.showWithTimeout(5, "Brak dostępu do bazy danych bazie danych.", "", icon=QMessageBox.Information)
                return False

            conn = sqlite3.connect(d_base)
            cursor = conn.cursor()

            total_inserted_rows = 0

            for feature in dissolve_layer.getFeatures():
                id = feature.id()
                feat = dissolve_layer.getFeature(id)
                area_id = feat[column_index]
                nature_reserve = feat[column_nature_reserve]
                nature_reserve_nr = feat[column_kod_inspire]
                nature_reserve_nr_last_part = None

                if nature_reserve_nr is not None and isinstance(nature_reserve_nr, str):
                    nature_reserve_nr_last_part = nature_reserve_nr.rsplit('.', 1)[-1]


                stanowisko_value = area_id
                rok_value = self.selected_year

                forma_ochrony_przyrody_cd_value = None


                if nature_reserve_nr is not None:
                    forma_ochrony_przyrody_cd_value = 'rp_' +  nature_reserve_nr_last_part


                # Define the SQL query to insert a new row
                if nature_reserve is not None:
                    sql_query = f"""INSERT INTO stanowisko_rok_forma_op (stanowisko_nr, rok, forma_ochrony_przyrody_cd) VALUES ('{stanowisko_value}', {rok_value}, '{forma_ochrony_przyrody_cd_value}');"""
                    cursor.execute(sql_query)
                    total_inserted_rows += cursor.rowcount

            conn.commit()

        except sqlite3.Error as e:
            print(f"Error adding data to database: {e}")
            conn.rollback()
            self.dockwidget.pushButton_asign_nature_reserve_to_dbase.setStyleSheet('QPushButton {background-color: #ff0000}')
            return False

        finally:
            conn.close()
            CustomMessageBox.showWithTimeout(5, f"Dodano {total_inserted_rows} przypisań do rezerwatów z warstwy do bazy danych.", "",icon=QMessageBox.Information)

        # Join layers and rewrite data between columns
        CustomMessageBox.showWithTimeout(5, "Przepisywanie rezerwatów przyrody do warstwy siedlisk (kolumna 'rez_przyr')...", "",icon=QMessageBox.Information)
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, layer, "rez_przyr", QVariant.String)
        AtributeTableManager.rewriteDataBetweenLayers(self, dissolve_layer, layer,  "rez_przyr", field_name, field_name)


        CustomMessageBox.showWithTimeout(5, "Zaktualizowano przypisanie do rezerwatów w bazie danych.", "", icon=QMessageBox.Information)
        self.dockwidget.pushButton_asign_nature_reserve_to_dbase.setStyleSheet('QPushButton {background-color: #3cb371}')

        # Add layers to project
        # QgsProject.instance().addMapLayer(common_part_layer)
        # QgsProject.instance().addMapLayer(dissolve_layer)

    # C_0101
    def numeration_validating_map(self):

        # Clear info labels
        self.clear_info_labels()

        # Layer
        layer = self.dockwidget.mMapLayerComboBoxAraesPolygon.currentLayer()
        if not (layer):
            self.dockwidget.label_warning.setText("Nie wskazano warstwy!")
            return False

        area_list_from_layer = []
        invalid_numbers_layer = []

        field_name = self.dockwidget.comboBoxFieldsName.currentText()
        field_area_id = layer.fields().indexFromName(field_name)

        for f in layer.getFeatures():
            id = f.id()
            feat = layer.getFeature(id)
            area_list_from_layer.append(feat[field_area_id])


        # Check corectness
        for data_layer in area_list_from_layer:
            if not self.is_numeric_and_length(str(data_layer)):
                invalid_numbers_layer.append(data_layer)
        if len(invalid_numbers_layer) > 0:
            self.appendDataToLabel("", self.dockwidget.label_warning)
            self.appendDataToLabel("Błędnie zanumerowane powierzchnie w warstwie:", self.dockwidget.label_warning)

            for data_layer in invalid_numbers_layer:
                    self.appendDataToLabel(str(data_layer), self.dockwidget.label_warning)

            self.generate_csv_reports("Błędnie zanumerowane powierzchnie w warstwie", ["ID_STANOWISKA"],invalid_numbers_layer, "monitoring_gis_tools_raporty_kontroli", "0101_wykaz_blednie_zan_powierzchni_mapa.csv")
            self.dockwidget.pushButtonNumerationValidatingLayer.setStyleSheet('QPushButton {background-color: #ff0000}')
        else:
            self.appendDataToLabel("Wszystkie powierzchnie w warstwie zanumerowano poprawnie.", self.dockwidget.label_info)
            self.generate_csv_reports("Błędnie zanumerowane powierzchnie w warstwie - brak", ["ID_STANOWISKA"],invalid_numbers_layer, "monitoring_gis_tools_raporty_kontroli", "0101_wykaz_blednie_zan_powierzchni_mapa_OK.csv")
            self.dockwidget.pushButtonNumerationValidatingLayer.setStyleSheet('QPushButton {background-color: #3cb371}')

    # C_0102
    def control_duplicates(self):

        self.clear_info_labels()

        layer = self.getLayer()

        # Check if the layer is valid
        if not layer.isValid():
            print(f"Layer '{layer}' is not valid.")
            CustomMessageBox.showWithTimeout(10, "Warstwa jest niepoprawna...", "", icon=QMessageBox.Information)
            return False

        # Get the index of the column
        column_name = self.dockwidget.comboBoxFieldsName.currentText()
        column_index = layer.fields().indexFromName(column_name)

        # Create a dictionary to store the count of each attribute value
        attribute_count = {}

        # Iterate through features in the layer
        for feature in layer.getFeatures():
            # Get the attribute value for the specified column
            attribute_value = feature[column_index]

            # Update the count in the dictionary
            if attribute_value in attribute_count:
                attribute_count[attribute_value] += 1
            else:
                attribute_count[attribute_value] = 1

        # Identify duplicate attribute values
        duplicate_values = [value for value, count in attribute_count.items() if count > 1]

        if len(duplicate_values) == 0:
            self.appendDataToLabel(f'Brak duplikatów, kolumna: {column_name}', self.dockwidget.label_info)
            CustomMessageBox.showWithTimeout(5, f'Brak duplikatów, kolumna: {column_name}', "", icon=QMessageBox.Information)
            self.generate_csv_reports(f'Brak duplikatów, kolumna: {column_name}', ["ID_STANOWISKA"], duplicate_values, "monitoring_gis_tools_raporty_kontroli", "0102_duplikaty_warstwa_OK.csv")
            self.dockwidget.pushButton_control_duplicates.setStyleSheet('QPushButton {background-color: #3cb371}')
            return False

        CustomMessageBox.showWithTimeout(5, f'Warstwa zawiera duplikaty w kolumnie: {column_name}', "", icon=QMessageBox.Information)
        self.appendDataToLabel(f'Warstwa zawiera duplikaty w kolumnie: {column_name}:', self.dockwidget.label_warning)
        for duplicate_value in duplicate_values:
            self.appendDataToLabel(str(duplicate_value), self.dockwidget.label_warning)
        self.generate_csv_reports(f'Warstwa zawiera duplikaty w kolumnie: {column_name}', ["ID_STANOWISKA"],duplicate_values, "monitoring_gis_tools_raporty_kontroli", "0102_duplikaty_warstwa.csv")
        self.dockwidget.pushButton_control_duplicates.setStyleSheet('QPushButton {background-color: #ff0000}')

        # Create a list to store feature IDs with duplicate values
        duplicate_feature_ids = []

        # Iterate through features again to identify features with duplicate values
        for feature in layer.getFeatures():
            attribute_value = feature[column_index]

            # Check if the attribute value is in the list of duplicate values
            if attribute_value in duplicate_values:
                duplicate_feature_ids.append(feature.id())

        # Select duplicates
        layer.selectByIds(duplicate_feature_ids)

        # Zoom to the selected features with buffer
        box = layer.boundingBoxOfSelected()
        xmin, xmax, ymin, ymax = box.xMinimum(), box.xMaximum(), box.yMinimum(), box.yMaximum()
        xmin -= 100
        xmax += 100
        ymin -= 100
        ymax += 100
        box = QgsRectangle(xmin, ymin, xmax, ymax)
        self.iface.mapCanvas().setExtent(box)
        self.iface.mapCanvas().refresh()



    # C_0103
    def control_n2000_extent(self):

        CustomMessageBox.showInfoCustomMessageBox("Sprawdź ustawienie warstwy zasięgu siedlisk oraz prawidłowej kolumny z numerem stanowiska!"
                                                  "\n\n"
                                                  "Wygenerowane zostaną warstwy: "
                                                  "\n-płatów w obszarze N2000 (w_N2000),"
                                                  "\n-płatów poza N2000 (poza_N2000),"
                                                  "\n-płatów w i poza N2000 (w_poza_N2000),"
                                                  "\n-płatów, które przecienają się z zasięgiem N2000 (bledy_zasiegu),"
                                                  "\n\n Należy przeanalizować warstwę 'bledy_zasiegu' i skorygować dane.",
                                                  "Kontrola zasięgu płatów względem obszarów N2000",
                                         icon=QMessageBox.Information)

        # remove_map_layer
        self.removeMapLayerByName('N2000_PL')
        self.removeMapLayerByName("w_N2000")
        self.removeMapLayerByName('poza_N2000')
        self.removeMapLayerByName('w_poza_N2000')
        self.removeMapLayerByName('bledy_zasiegu')
        self.removeMapLayerByName('rezerwaty_PL')
        self.removeMapLayerByName("w_rezerwacie")
        self.removeMapLayerByName('poza_rezerwatem')
        self.removeMapLayerByName('w_poza_rezerwatem')


        self.clear_info_labels()

        #Get n2000 - layer
        dirnameOfCatalog = self.resolveDir('soo_layer')
        geopackage_path =  dirnameOfCatalog + "/N2000_PL.gpkg"

        layer = self.getLayer()
        crs = layer.crs()
        crs.createFromId(2180)
        layer.setCrs(QgsCoordinateReferenceSystem(crs))
        if not layer.isValid():
            print(f"Layer '{layer}' is not valid.")
            CustomMessageBox.showWithTimeout(10, "Warstwa jest niepoprawna...", "", icon=QMessageBox.Information)
            return False

        AtributeTableManager.removeColumnToLayerByLayerInstance(self, layer, "kod_n2000")
        field_name = self.dockwidget.comboBoxFieldsName.currentText()
        field_area_id = layer.fields().indexFromName(field_name)


        # 01 REPAIR GEOMETRY
        result = processing.run("native:fixgeometries", {'INPUT': layer, 'OUTPUT': 'memory:'})
        repair_geom_user_layer = result['OUTPUT']


        natura2000_layer = self.iface.addVectorLayer(geopackage_path, "N2000_PL", "ogr")
        if not natura2000_layer:
            print("Layer failed to load!")


        # 01 INTERSECT (COMMON PART)
        result = processing.run("native:intersection", {
            'INPUT': repair_geom_user_layer,
            'OVERLAY': natura2000_layer,
            'INPUT_FIELDS': [], 'OVERLAY_FIELDS': [], 'OVERLAY_FIELDS_PREFIX': '', 'OUTPUT': 'memory:',
            'GRID_SIZE': None})
        common_part_layer = result['OUTPUT']
        common_part_layer.setName('w_N2000')


        # 02 ROZNICA
        result = processing.run("native:difference", {
            'INPUT': repair_geom_user_layer,
            'OVERLAY': natura2000_layer,
            'OUTPUT': 'memory:',
            'GRID_SIZE': None})
        difference_layer = result['OUTPUT']
        difference_layer.setName('poza_N2000')


        # 03 MERGE
        result = processing.run("native:mergevectorlayers", {'LAYERS': [common_part_layer, difference_layer], 'CRS': None, 'OUTPUT': 'memory:'})
        merge_layer = result['OUTPUT']
        merge_layer.setName('w_poza_N2000')
        QgsProject.instance().addMapLayer(merge_layer)


        # 04 AGREGATE
        result = processing.run("native:dissolve", {
            'INPUT': merge_layer,
            'FIELD': [field_name, 'kod_n2000'], 'SEPARATE_DISJOINT': False, 'OUTPUT': 'memory:'})
        dissolve_layer = result['OUTPUT']
        dissolve_layer.setName('bledy_zasiegu')
        # 05 CALCULATE AREA
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, dissolve_layer, "AREA_HA", QVariant.Double)
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, dissolve_layer, "DUPLICATE", QVariant.Int)
        layer_provider = dissolve_layer.dataProvider()
        layer_fields = dissolve_layer.fields()
        field_area = layer_fields.indexFromName("AREA_HA")
        field_duplicate = layer_fields.indexFromName("DUPLICATE")
        features_of_layer = dissolve_layer.getFeatures()
        field_area_id = dissolve_layer.fields().indexFromName(field_name)

        for f in features_of_layer:
            id = f.id()
            feat = dissolve_layer.getFeature(id)

            # SUBAREA
            geom = f.geometry()
            area = geom.area() / 10000
            area = round(area, 2)
            attr_value_subarea = {field_area: area}
            layer_provider.changeAttributeValues({id: attr_value_subarea})
            # area_list_from_layer.append(feat[field_area_id])
            # list_of_subarea.append(area)

        # 06 FIND DUPLICATES
        # Create a dictionary to store the count of each attribute value
        attribute_count = {}
        duplicate_feature_ids = []
        # Iterate through features in the layer
        for feature in dissolve_layer.getFeatures():
            # Get the attribute value for the specified column
            attribute_value = feature[field_area_id]
            # Update the count in the dictionary
            if attribute_value in attribute_count:
                attribute_count[attribute_value] += 1
            else:
                attribute_count[attribute_value] = 1

        # Identify duplicate attribute values
        duplicate_values = [value for value, count in attribute_count.items() if count > 1]

        if len(duplicate_values) == 0:
            self.appendDataToLabel('Brak obiektów o błędnym zasięgu w odniesieniu do obszarów Natura 2000', self.dockwidget.label_info)
            CustomMessageBox.showWithTimeout(5, 'Brak obiektów o błędnym zasięgu w odniesieniu do obszarów Natura 2000', "", icon=QMessageBox.Information)
            self.generate_csv_reports(f'Brak obiektów o błędnym zasięgu w odniesieniu do obszarów Natura 2000', ["ID_STANOWISKA"], duplicate_values, "monitoring_gis_tools_raporty_kontroli", "0103_bledny_zasieg_N2000_OK.csv")
            self.dockwidget.pushButton_control_n2000_extent.setStyleSheet('QPushButton {background-color: #3cb371}')

        else:
            CustomMessageBox.showWithTimeout(5, 'Warstwa zawiera obiekty o błędnym zasięgu w odniesieniu do obszarów Natura 2000', "", icon=QMessageBox.Information)
            self.appendDataToLabel('Warstwa zawiera obiekty o błędnym zasięgu w odniesieniu do obszarów Natura 2000', self.dockwidget.label_warning)
            for duplicate_value in duplicate_values:
                self.appendDataToLabel(str(duplicate_value), self.dockwidget.label_warning)
            self.generate_csv_reports('Warstwa zawiera obiekty o błędnym zasięgu w odniesieniu do obszarów Natura 2000', ["ID_STANOWISKA"],duplicate_values, "monitoring_gis_tools_raporty_kontroli", "0103_bledny_zasieg_N2000.csv")
            self.dockwidget.pushButton_control_n2000_extent.setStyleSheet('QPushButton {background-color: #ff0000}')

        # Iterate through features again to identify features with duplicate values
        for feature in dissolve_layer.getFeatures():
            attribute_value = feature[field_area_id]
            id = feature.id()

            # Check if the attribute value is in the list of duplicate values
            if attribute_value in duplicate_values:
                attr_value_duplicates = {field_duplicate: 1}
                layer_provider.changeAttributeValues({id: attr_value_duplicates})
                duplicate_feature_ids.append(feature.id())

        # Select duplicates
        # dissolve_layer.selectByIds(duplicate_feature_ids)
        dissolve_layer.selectByExpression("DUPLICATE IS null")

        # Remove the selected features
        dissolve_layer.startEditing()
        dissolve_layer.deleteSelectedFeatures()
        dissolve_layer.commitChanges()

        # Clear the selection
        dissolve_layer.removeSelection()

        # Create a dictionary to store the smallest area for each unique NR_PLATU
        smallest_areas = {}

        # Iterate through features in the layer
        for feature in dissolve_layer.getFeatures():
            nr_platu = feature['NR_PLATU']
            area = feature['AREA_HA']

            # If NR_PLATU is not in the dictionary or the current area is smaller than the stored one
            if nr_platu not in smallest_areas or area < smallest_areas[nr_platu][0]:
                smallest_areas[nr_platu] = (area, feature.id())

        # Select only the features with the smallest area for each NR_PLATU
        selected_feature_ids = []
        for nr_platu, (smallest_area, feature_id) in smallest_areas.items():
            selected_feature_ids.append(feature_id)

        # Deselect all features
        dissolve_layer.removeSelection()

        # Select the features with the smallest area
        dissolve_layer.selectByIds(selected_feature_ids)

        # Inverse the selection
        dissolve_layer.invertSelection()

        # Remove the selected features (i.e., the ones with larger areas)
        dissolve_layer.startEditing()
        dissolve_layer.deleteSelectedFeatures()
        dissolve_layer.commitChanges()

        QgsProject.instance().addMapLayer(common_part_layer)
        QgsProject.instance().addMapLayer(difference_layer)
        QgsProject.instance().addMapLayer(dissolve_layer)

    # C_0104
    def control_nat_reserve_extent(self):

        CustomMessageBox.showInfoCustomMessageBox("Sprawdź ustawienie warstwy zasięgu siedlisk oraz prawidłowej kolumny z numerem stanowiska!"
                                                  "\n\n"
                                                    "Wygenerowane zostaną warstwy: "
                                                  "\n-płatów w zasięgu rezerwatów (w_rezerwacie),"
                                                  "\n-płatów poza rezerwatem (poza_rezerwatem),"
                                                  "\n-płatów w i poza rezerwatem (w_poza_rezerwatem),"
                                                  "\n-płatów, które przecienają się z zasięgiem rezerwatów (bledy_zasiegu),"
                                                  "\n\n Należy przeanalizować warstwę 'bledy_zasiegu' i skorygować dane.",
                                                  "Kontrola zasięgu płatów względem rezerwatów przyrody",
                                         icon=QMessageBox.Information)

        # remove_map_layer
        self.removeMapLayerByName('N2000_PL')
        self.removeMapLayerByName("w_N2000")
        self.removeMapLayerByName('poza_N2000')
        self.removeMapLayerByName('w_poza_N2000')
        self.removeMapLayerByName('bledy_zasiegu')
        self.removeMapLayerByName('rezerwaty_PL')
        self.removeMapLayerByName("w_rezerwacie")
        self.removeMapLayerByName('poza_rezerwatem')
        self.removeMapLayerByName('w_poza_rezerwatem')

        self.clear_info_labels()

        #Get n2000 - layer
        dirnameOfCatalog = self.resolveDir('rez_layer')
        geopackage_path =  dirnameOfCatalog + "/rezerwaty_PL.gpkg"

        layer = self.getLayer()
        crs = layer.crs()
        crs.createFromId(2180)
        layer.setCrs(QgsCoordinateReferenceSystem(crs))
        if not layer.isValid():
            print(f"Layer '{layer}' is not valid.")
            CustomMessageBox.showWithTimeout(10, "Warstwa jest niepoprawna...", "", icon=QMessageBox.Information)
            return False

        field_name = self.dockwidget.comboBoxFieldsName.currentText()
        field_area_id = layer.fields().indexFromName(field_name)

        # 01 REPAIR GEOMETRY
        result = processing.run("native:fixgeometries", {'INPUT': layer, 'OUTPUT': 'memory:'})
        repair_geom_user_layer = result['OUTPUT']

        reserve_layer = self.iface.addVectorLayer(geopackage_path, "rezerwaty_PL", "ogr")
        reserve_layer.setCrs(QgsCoordinateReferenceSystem(crs))
        if not reserve_layer:
            print("Layer failed to load!")

        # 01 INTERSECT (COMMON PART)
        result = processing.run("native:intersection", {
            'INPUT': repair_geom_user_layer,
            'OVERLAY': reserve_layer,
            'INPUT_FIELDS': [], 'OVERLAY_FIELDS': [], 'OVERLAY_FIELDS_PREFIX': '', 'OUTPUT': 'memory:',
            'GRID_SIZE': None})
        common_part_layer = result['OUTPUT']
        common_part_layer.setName('w_rezerwacie')
        QgsProject.instance().addMapLayer(common_part_layer)

        # 02 ROZNICA
        result = processing.run("native:difference", {
            'INPUT': repair_geom_user_layer,
            'OVERLAY': reserve_layer,
            'OUTPUT': 'memory:',
            'GRID_SIZE': None})
        difference_layer = result['OUTPUT']
        difference_layer.setName('poza_rezerwatem')
        QgsProject.instance().addMapLayer(difference_layer)

        # 03 MERGE
        result = processing.run("native:mergevectorlayers", {'LAYERS': [common_part_layer, difference_layer], 'CRS': None, 'OUTPUT': 'memory:'})
        merge_layer = result['OUTPUT']
        merge_layer.setName('w_poza_rezerwatem')
        QgsProject.instance().addMapLayer(merge_layer)

        # 04 AGREGATE
        result = processing.run("native:dissolve", {
            'INPUT': merge_layer,
            'FIELD': [field_name, 'rez_przyr'], 'SEPARATE_DISJOINT': False, 'OUTPUT': 'memory:'})
        dissolve_layer = result['OUTPUT']
        dissolve_layer.setName('bledy_zasiegu')
        QgsProject.instance().addMapLayer(dissolve_layer)

        # 05 CALCULATE AREA
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, dissolve_layer, "AREA_HA", QVariant.Double)
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, dissolve_layer, "DUPLICATE", QVariant.Int)
        layer_provider = dissolve_layer.dataProvider()
        layer_fields = dissolve_layer.fields()
        field_area = layer_fields.indexFromName("AREA_HA")
        field_duplicate = layer_fields.indexFromName("DUPLICATE")
        features_of_layer = dissolve_layer.getFeatures()
        field_area_id = dissolve_layer.fields().indexFromName(field_name)

        for f in features_of_layer:
            id = f.id()
            feat = dissolve_layer.getFeature(id)

            # SUBAREA
            geom = f.geometry()
            area = geom.area() / 10000
            area = round(area, 2)
            attr_value_subarea = {field_area: area}
            layer_provider.changeAttributeValues({id: attr_value_subarea})
            # area_list_from_layer.append(feat[field_area_id])
            # list_of_subarea.append(area)

        # 06 FIND DUPLICATES
        # Create a dictionary to store the count of each attribute value
        attribute_count = {}
        duplicate_feature_ids = []
        # Iterate through features in the layer
        for feature in dissolve_layer.getFeatures():
            # Get the attribute value for the specified column
            attribute_value = feature[field_area_id]
            # Update the count in the dictionary
            if attribute_value in attribute_count:
                attribute_count[attribute_value] += 1
            else:
                attribute_count[attribute_value] = 1

        # Identify duplicate attribute values
        duplicate_values = [value for value, count in attribute_count.items() if count > 1]

        if len(duplicate_values) == 0:
            self.appendDataToLabel('Brak obiektów o błędnym zasięgu w odniesieniu do rezerwatów', self.dockwidget.label_info)
            CustomMessageBox.showWithTimeout(5, 'Brak obiektów o błędnym zasięgu w odniesieniu do rezerwatów', "", icon=QMessageBox.Information)
            self.generate_csv_reports(f'Brak obiektów o błędnym zasięgu w odniesieniu do rezerwatów', ["ID_STANOWISKA"], duplicate_values, "monitoring_gis_tools_raporty_kontroli", "0104_bledny_zasieg_rererwaty_OK.csv")
            self.dockwidget.pushButton_control_nat_reserve_extent.setStyleSheet('QPushButton {background-color: #3cb371}')

        else:
            CustomMessageBox.showWithTimeout(5, 'Warstwa zawiera obiekty o błędnym zasięgu w odniesieniu do rezerwatów przyrody', "", icon=QMessageBox.Information)
            self.appendDataToLabel('Warstwa zawiera obiekty o błędnym zasięgu w odniesieniu do rezerwatów przyrody', self.dockwidget.label_warning)
            for duplicate_value in duplicate_values:
                self.appendDataToLabel(str(duplicate_value), self.dockwidget.label_warning)
            self.generate_csv_reports('Warstwa zawiera obiekty o błędnym zasięgu w odniesieniu do rezerwatów przyrody', ["ID_STANOWISKA"],duplicate_values, "monitoring_gis_tools_raporty_kontroli", "0104_bledny_zasieg_rererwaty.csv")
            self.dockwidget.pushButton_control_nat_reserve_extent.setStyleSheet('QPushButton {background-color: #ff0000}')

        # Iterate through features again to identify features with duplicate values
        for feature in dissolve_layer.getFeatures():
            attribute_value = feature[field_area_id]
            id = feature.id()

            # Check if the attribute value is in the list of duplicate values
            if attribute_value in duplicate_values:
                attr_value_duplicates = {field_duplicate: 1}
                layer_provider.changeAttributeValues({id: attr_value_duplicates})
                duplicate_feature_ids.append(feature.id())

        # Select duplicates
        # dissolve_layer.selectByIds(duplicate_feature_ids)
        dissolve_layer.selectByExpression("DUPLICATE IS null")

        # Remove the selected features
        dissolve_layer.startEditing()
        dissolve_layer.deleteSelectedFeatures()
        dissolve_layer.commitChanges()

        # Clear the selection
        dissolve_layer.removeSelection()

        # Create a dictionary to store the smallest area for each unique NR_PLATU
        smallest_areas = {}

        # Iterate through features in the layer
        for feature in dissolve_layer.getFeatures():
            nr_platu = feature['NR_PLATU']
            area = feature['AREA_HA']

            # If NR_PLATU is not in the dictionary or the current area is smaller than the stored one
            if nr_platu not in smallest_areas or area < smallest_areas[nr_platu][0]:
                smallest_areas[nr_platu] = (area, feature.id())

        # Select only the features with the smallest area for each NR_PLATU
        selected_feature_ids = []
        for nr_platu, (smallest_area, feature_id) in smallest_areas.items():
            selected_feature_ids.append(feature_id)

        # Deselect all features
        dissolve_layer.removeSelection()

        # Select the features with the smallest area
        dissolve_layer.selectByIds(selected_feature_ids)

        # Inverse the selection
        dissolve_layer.invertSelection()

        # Remove the selected features (i.e., the ones with larger areas)
        dissolve_layer.startEditing()
        dissolve_layer.deleteSelectedFeatures()
        dissolve_layer.commitChanges()

    # C_0105

    # def find_overlaps(self):
    #     self.clear_info_labels()
    #
    #     layer = self.getLayer()
    #     if not layer.isValid():
    #         print(f"Layer '{layer}' is not valid.")
    #         CustomMessageBox.showWithTimeout(10, "Warstwa jest niepoprawna...", "", icon=QMessageBox.Information)
    #         return False
    #
    #     AtributeTableManager.addNewColumnToLayerByLayerInstance(self, layer, "ID", QVariant.Int)
    #     AtributeTableManager.recalculateIDInColumnByLayerInstance(self, layer, "ID", 0)
    #
    #     result = processing.run("native:union",
    #                             {'INPUT': layer, 'OVERLAY': layer, 'OVERLAY_FIELDS_PREFIX': '', 'OUTPUT': 'memory:',
    #                              'GRID_SIZE': None})
    #     unionLayer = result['OUTPUT']
    #
    #     unionLayer.selectByExpression('"ID" <> "ID_2"')
    #
    #     layer.triggerRepaint()
    #     unionLayer.invertSelection()
    #     unionLayer.startEditing()
    #     unionLayer.deleteSelectedFeatures()
    #     unionLayer.commitChanges()
    #
    #     unionLayer.setName('nalozenia_overlaps')
    #     QgsProject.instance().addMapLayer(unionLayer)

    def find_overlaps(self):
        self.clear_info_labels()

        # Get the layer
        layer = self.getLayer()
        if not layer.isValid():
            print(f"Layer '{layer}' is not valid.")
            CustomMessageBox.showWithTimeout(10, "Warstwa jest niepoprawna...", "", icon=QMessageBox.Information)
            return False

        # Create a new memory layer to store overlaps
        overlaps_layer = QgsVectorLayer("MultiPolygon?crs=epsg:2180", "overlaps", "memory")

        # Start editing the new layer
        overlaps_layer.startEditing()

        # Add fields to the new layer (copy fields from the source layer)
        overlaps_layer_fields = layer.fields()
        overlaps_layer_data_provider = overlaps_layer.dataProvider()
        overlaps_layer_data_provider.addAttributes(overlaps_layer_fields)

        # Update the fields
        overlaps_layer.updateFields()

        # Loop through each feature
        for i in range(layer.featureCount()):
            feature1 = layer.getFeature(i)

            # Get the geometry of feature 1
            geometry1 = feature1.geometry()

            # Loop through the remaining features
            for j in range(i + 1, layer.featureCount()):
                feature2 = layer.getFeature(j)

                # Get the geometry of feature 2
                geometry2 = feature2.geometry()

                # Check for overlap
                if geometry1.intersects(geometry2):
                    # Compute the intersection of the geometries
                    intersection_geometry = geometry1.intersection(geometry2)

                    # Filter out non-polygon/multipolygon geometries
                    if intersection_geometry.wkbType() in [3, 6]:  # Polygon or Multipolygon
                        # If the intersection geometry is a GeometryCollection
                        if intersection_geometry.wkbType() == 7:
                            # Iterate through each geometry in the collection
                            for sub_geometry in intersection_geometry.asGeometryCollection():
                                # Check if the geometry is a polygon or multipolygon
                                if sub_geometry.wkbType() in [3, 6]:
                                    # Create a new feature with the polygon/multipolygon geometry
                                    new_feature = QgsFeature()
                                    new_feature.setGeometry(sub_geometry)
                                    new_feature.setAttributes(
                                        feature1.attributes())  # You can choose which attributes to keep

                                    # Add the new feature to the new layer
                                    overlaps_layer.addFeature(new_feature)
                        else:
                            # Create a new feature with the intersection geometry
                            new_feature = QgsFeature()
                            new_feature.setGeometry(intersection_geometry)
                            new_feature.setAttributes(feature1.attributes())  # You can choose which attributes to keep

                            # Add the new feature to the new layer
                            overlaps_layer.addFeature(new_feature)

        # Commit changes to the new layer
        overlaps_layer.commitChanges()

        # Add the new layer to the project
        QgsProject.instance().addMapLayer(overlaps_layer)

    def find_gaps(self):

        # self.clear_info_labels()
        #
        # layer = self.getLayer()
        # if not layer.isValid():
        #     print(f"Layer '{layer}' is not valid.")
        #     CustomMessageBox.showWithTimeout(10, "Warstwa jest niepoprawna...", "", icon=QMessageBox.Information)
        #     return False
        #
        # # Make extent of layer
        # result = processing.run("native:polygonfromlayerextent", {'INPUT': layer, 'ROUND_TO': 0, 'OUTPUT': 'memory:'})
        # extent_layer = result['OUTPUT']
        #
        # # make symetrical difference
        # result = processing.run("native:symmetricaldifference", {'INPUT': layer, 'OVERLAY': extent_layer, 'OVERLAY_FIELDS_PREFIX': '', 'OUTPUT': 'memory:', 'GRID_SIZE': None})
        # symmetrical_difference_layer = result['OUTPUT']
        #
        # # Explode multipart
        # result = processing.run("native:multiparttosingleparts", {'INPUT': symmetrical_difference_layer, 'OUTPUT': 'memory:'})
        # difference_layer_exploaded = result['OUTPUT']
        #
        # # Calculate area
        # AtributeTableManager.addNewColumnToLayerByLayerInstance(self, difference_layer_exploaded, "AREA_HA", QVariant.Double)
        # layer_provider = difference_layer_exploaded.dataProvider()
        # column_area = difference_layer_exploaded.fields().indexFromName("AREA_HA")
        # for f in difference_layer_exploaded.getFeatures():
        #     id = f.id()
        #     geom = f.geometry()
        #     area = geom.area() / 10000
        #     area = round(area, 2)
        #     attr_value_subarea = {column_area: area}
        #     layer_provider.changeAttributeValues({id: attr_value_subarea})
        # difference_layer_exploaded.commitChanges()
        #
        # # Remove the feature with the maximum 'AREA_HA'
        # max_area_feature = max(difference_layer_exploaded.getFeatures(QgsFeatureRequest().setFlags(QgsFeatureRequest.NoGeometry)),key=lambda f: f['AREA_HA'])
        # difference_layer_exploaded.startEditing()
        # difference_layer_exploaded.deleteFeature(max_area_feature.id())
        # difference_layer_exploaded.commitChanges()
        #
        # AtributeTableManager.addNewColumnToLayerByLayerInstance(self, difference_layer_exploaded, "ID", QVariant.Int)
        # AtributeTableManager.recalculateIDInColumnByLayerInstance(self, difference_layer_exploaded, "ID", 0)
        # AtributeTableManager.removeEachColumnExeptDeclaredByLayerInstance(self, difference_layer_exploaded, ["ID",'AREA_HA'] )
        #
        # difference_layer_exploaded.setName('dziury_gaps')
        # QgsProject.instance().addMapLayer(difference_layer_exploaded)
        self.clear_info_labels()

        layer = self.getLayer()
        if not layer.isValid():
            print(f"Layer '{layer}' is not valid.")
            CustomMessageBox.showWithTimeout(10, "Warstwa jest niepoprawna...", "", icon=QMessageBox.Information)
            return False

        # Run the "native:extractbylocation" algorithm to select features that have gaps between them
        result = processing.run("native:extractbylocation",
                                {'INPUT': layer, 'PREDICATE': [6], 'INTERSECT': layer, 'OUTPUT': 'memory:'})
        gapLayer = result['OUTPUT']

        gapLayer.setName('inter_feature_gaps')
        QgsProject.instance().addMapLayer(gapLayer)

        # self.clear_info_labels()
        #
        # layer = self.getLayer()
        # if not layer.isValid():
        #     print(f"Layer '{layer}' is not valid.")
        #     CustomMessageBox.showWithTimeout(10, "Warstwa jest niepoprawna...", "", icon=QMessageBox.Information)
        #     return False
        #
        # result = processing.run("qgis:checkvalidity",
        #                         {'INPUT_LAYER': layer,
        #                          'METHOD': 2, 'IGNORE_RING_SELF_INTERSECTION': False, 'VALID_OUTPUT': 'memory:',
        #                          'INVALID_OUTPUT': 'memory:', 'ERROR_OUTPUT': 'memory:'})
        #
        # valid_layer = result['VALID_OUTPUT']
        # invalid_layer = result['INVALID_OUTPUT']
        # error_layer = result['ERROR_OUTPUT']
        #
        # valid_layer.setName('Warstwa z poprawnymi obiektami')
        # QgsProject.instance().addMapLayer(valid_layer)
        # invalid_layer.setName('Warstwa z niepoprawnymi obiektami')
        # QgsProject.instance().addMapLayer(invalid_layer)
        # error_layer.setName('Blędy')
        # QgsProject.instance().addMapLayer(error_layer)


    # Metody kontroli -dodawane po opracowaniu SQL dla WebMonitoring

    # Kontrole danych ogólnych
    # 10001
    def run_control_10001(self):
        self.get_error_result_by_error_code(10001)

    # 10002
    def run_control_10002(self):
        self.get_error_result_by_error_code(10002)

    # 10005
    def run_control_10005(self):
        self.get_error_result_by_error_code(10005)

    # 10010
    def run_control_10010(self):
        self.get_error_result_by_error_code(10010)

    # 10020
    def run_control_10020(self):
        self.get_error_result_by_error_code(10020)

    # 10100
    def run_control_10100(self):
        self.get_error_result_by_error_code(10100)

    # 10101
    def run_control_10101(self):
        self.get_error_result_by_error_code(10101)

    # 10102
    def run_control_10102(self):
        self.get_error_result_by_error_code(10102)

    # 10200
    def run_control_10200(self):
        self.get_error_result_by_error_code(10200)

    # 10201
    def run_control_10201(self):
        self.get_error_result_by_error_code(10201)

    # 10210
    def run_control_10210(self):
        self.get_error_result_by_error_code(10210)

    # 10211
    def run_control_10211(self):
        self.get_error_result_by_error_code(10211)

    # 10220
    def run_control_10220(self):
        self.get_error_result_by_error_code(10220)

    # 10221
    def run_control_10221(self):
        self.get_error_result_by_error_code(10221)

    # 10230
    def run_control_10230(self):
        self.get_error_result_by_error_code(10230)

    # 10231
    def run_control_10231(self):
        self.get_error_result_by_error_code(10231)

    # 10240
    def run_control_10240(self):
        self.get_error_result_by_error_code(10240)

    # 10250
    def run_control_10250(self):
        self.get_error_result_by_error_code(10250)

    # 10251
    def run_control_10251(self):
        self.get_error_result_by_error_code(10251)

    # 10252
    def run_control_10252(self):
        self.get_error_result_by_error_code(10252)

    # 10260
    def run_control_10260(self):
        self.get_error_result_by_error_code(10260)

    # 10270
    def run_control_10270(self):
        self.get_error_result_by_error_code(10270)

    # 10271
    def run_control_10271(self):
        self.get_error_result_by_error_code(10271)

    # 10280
    def run_control_10280(self):
        self.get_error_result_by_error_code(10280)

    # 10281
    def run_control_10281(self):
        self.get_error_result_by_error_code(10281)

    # 10282
    def run_control_10282(self):
        self.get_error_result_by_error_code(10282)

    # 10290
    def run_control_10290(self):
        self.get_error_result_by_error_code(10290)

    # 10300
    def run_control_10300(self):
        self.get_error_result_by_error_code(10300)

    def complex_control_general_data(self):
        self.clearPlainTextEditInfo()
        # 10001
        self.run_control_10001()
        # 10002
        self.run_control_10002()
        # 10005
        self.run_control_10005()
        # 10010
        self.run_control_10010()
        # 10020
        self.run_control_10020()
        # 10100
        self.run_control_10100()
        # 10101
        self.run_control_10101()
        # 10102
        self.run_control_10102()
        # 10200
        self.run_control_10200()
        # 10201
        self.run_control_10201()
        # 10210
        self.run_control_10210()
        # 10211
        self.run_control_10211()
        # 10220
        self.run_control_10220()
        # 10221
        self.run_control_10221()
        # 10230
        self.run_control_10230()
        # 10231
        self.run_control_10231()
        # 10240
        self.run_control_10240()
        # 10250
        self.run_control_10250()
        # 10251
        self.run_control_10251()
        # 10252
        self.run_control_10252()
        # 10260
        self.run_control_10260()
        # 10270
        self.run_control_10270()
        # 10271
        self.run_control_10271()
        # 10280
        self.run_control_10280()
        # 10281
        self.run_control_10281()
        # 10282
        self.run_control_10282()
        # 10290
        self.run_control_10290()
        # 10300
        self.run_control_10300()
        self.dockwidget.plainTextEdit_info.setPlainText("Wyniki kontroli zostały zapisane w lokalizacji bazy danych")
        self.dockwidget.pushButtonK10000.setStyleSheet('QPushButton {background-color: #b7eced}')

    # Kontrole ocen
    # 30100
    def run_control_30100(self):
        self.get_error_result_by_error_code(30100)

    # 30101
    def run_control_30101(self):
        self.get_error_result_by_error_code(30101)

    # 30102
    def run_control_30102(self):
        self.get_error_result_by_error_code(30102)

    # 30150
    def run_control_30150(self):
        self.get_error_result_by_error_code(30150)

    # 30200
    def run_control_30200(self):
        self.get_error_result_by_error_code(30200)

    # 30201
    def run_control_30201(self):
        self.get_error_result_by_error_code(30201)

    # 30210
    def run_control_30210(self):
        self.get_error_result_by_error_code(30210)

    # 30211
    def run_control_30211(self):
        self.get_error_result_by_error_code(30211)

    # 30212
    def run_control_30212(self):
        self.get_error_result_by_error_code(30212)

    # 30220
    def run_control_30220(self):
        self.get_error_result_by_error_code(30220)

    # 30221
    def run_control_30221(self):
        self.get_error_result_by_error_code(30221)

    # 30222
    def run_control_30222(self):
        self.get_error_result_by_error_code(30222)

    # 30230
    def run_control_30230(self):
        self.get_error_result_by_error_code(30230)

    # 30231
    def run_control_30231(self):
        self.get_error_result_by_error_code(30231)

    # 30232
    def run_control_30232(self):
        self.get_error_result_by_error_code(30232)

    # 30500
    def run_control_30500(self):
        self.get_error_result_by_error_code(30500)

    # 30501
    def run_control_30501(self):
        self.get_error_result_by_error_code(30501)

    # 30502
    def run_control_30502(self):
        self.get_error_result_by_error_code(30502)

    # Kompleksowa kontrola oceny 30000

    def complex_control_ratings(self):
        self.clearPlainTextEditInfo()
        # 30100
        self.run_control_30100()
        # 30101
        self.run_control_30101()
        # 30102
        self.run_control_30102()
        # 30150
        self.run_control_30150()
        # 30200
        self.run_control_30200()
        # 30201
        self.run_control_30201()
        # 30210
        self.run_control_30210()
        # 30211
        self.run_control_30211()
        # 30212
        self.run_control_30212()
        # 30220
        self.run_control_30220()
        # 30221
        self.run_control_30221()
        # 30222
        self.run_control_30222()
        # 30230
        self.run_control_30230()
        # 30231
        self.run_control_30231()
        # 30232
        self.run_control_30232()
        # 30500
        self.run_control_30500()
        # 30501
        self.run_control_30501()
        # 30502
        self.run_control_30502()
        self.dockwidget.plainTextEdit_info.setPlainText("Wyniki kontroli zostały zapisane w lokalizacji bazy danych")
        self.dockwidget.pushButtonK30000.setStyleSheet('QPushButton {background-color: #b7eced}')

    # Kontrole zdjęć fito
    # 20000
    def run_control_20000(self):
        self.get_error_result_by_error_code(20000)
    # 20001
    def run_control_20001(self):
        self.get_error_result_by_error_code(20001)
    # 20002
    def run_control_20002(self):
        self.get_error_result_by_error_code(20002)
    # 20003
    def run_control_20003(self):
        self.get_error_result_by_error_code(20003)
    # 20004
    def run_control_20004(self):
        self.get_error_result_by_error_code(20004)
    # 20005
    def run_control_20005(self):
        self.get_error_result_by_error_code(20005)
    # 20006
    def run_control_20006(self):
        self.get_error_result_by_error_code(20006)
    # 20010
    def run_control_20010(self):
        self.get_error_result_by_error_code(20010)
    # 20020
    def run_control_20020(self):
        self.get_error_result_by_error_code(20020)

    def complex_control_phytoreleves(self):
        self.clearPlainTextEditInfo()
        # 20000
        self.run_control_20000()
        # 20001
        self.run_control_20001()
        # 20002
        self.run_control_20002()
        # 20003
        self.run_control_20003()
        # 20004
        self.run_control_20004()
        # 20005
        self.run_control_20005()
        # 20006
        self.run_control_20006()
        # 20010
        self.run_control_20010()
        # 20020
        self.run_control_20020()
        self.dockwidget.plainTextEdit_info.setPlainText("Wyniki kontroli zostały zapisane w lokalizacji bazy danych")
        self.dockwidget.pushButtonK20000.setStyleSheet('QPushButton {background-color: #b7eced}')


    # Kontrole oddziaływań, zagrożeń, działań
    # 10500
    def run_control_10500(self):
        self.get_error_result_by_error_code(10500)
    # 10501
    def run_control_10501(self):
        self.get_error_result_by_error_code(10501)
    # 10502
    def run_control_10502(self):
        self.get_error_result_by_error_code(10502)
    # 10600
    def run_control_10600(self):
        self.get_error_result_by_error_code(10600)
    # 10601
    def run_control_10601(self):
        self.get_error_result_by_error_code(10601)
    # 10602
    def run_control_10602(self):
        self.get_error_result_by_error_code(10602)
    # 10700
    def run_control_10700(self):
        self.get_error_result_by_error_code(10700)
    # 10701
    def run_control_10701(self):
        self.get_error_result_by_error_code(10701)
    # 10702
    def run_control_10702(self):
        self.get_error_result_by_error_code(10702)
    # 10703
    def run_control_10703(self):
        self.get_error_result_by_error_code(10703)
    # 10704
    def run_control_10704(self):
        self.get_error_result_by_error_code(10704)
    # 10705
    def run_control_10705(self):
        self.get_error_result_by_error_code(10705)

    def complex_control_threats(self):
        self.clearPlainTextEditInfo()
        # 10500
        self.run_control_10500()
        # 10501
        self.run_control_10501()
        # 10502
        self.run_control_10502()
        # 10600
        self.run_control_10600()
        # 10601
        self.run_control_10601()
        # 10602
        self.run_control_10602()
        # 10700
        self.run_control_10700()
        # 10701
        self.run_control_10701()
        # 10702
        self.run_control_10702()
        # 10703
        self.run_control_10703()
        # 10704
        self.run_control_10704()
        # 10705
        self.run_control_10705()
        self.dockwidget.plainTextEdit_info.setPlainText("Wyniki kontroli zostały zapisane w lokalizacji bazy danych")
        self.dockwidget.pushButtonK10500.setStyleSheet('QPushButton {background-color: #b7eced}')





    # C_0301  C_03011 C_03012 C_03013
    def compatibilyty_check_tools(self):

        # Clear info labels
        self.clear_info_labels()

        # Dbase address
        d_base = str(self.dockwidget.lineEdit_dBase_directory.text()).replace('\\', '/')

        # check if base exist
        if not (str(d_base)):
            self.dockwidget.label_warning.setText("Nie wskazano bazy danych!")
            return False

        # Declare connections
        conn = sqlite3.connect(d_base)
        cursor = conn.cursor()

        cursor.execute("SELECT stanowisko_nr FROM stanowisko_rok;")
        rows = cursor.fetchall()

        layer = self.dockwidget.mMapLayerComboBoxAraesPolygon.currentLayer()

        if not (layer):
            self.dockwidget.label_warning.setText("Nie wskazano warstwy!")
            return False


        ara_list_from_dBase = []
        area_list_from_layer = []
        field_name = self.dockwidget.comboBoxFieldsName.currentText()
        field_area_id = layer.fields().indexFromName(field_name)
        #Exist in dbase, not exist in layer
        exist_in_both = []
        exist_id_dbase = []
        exist_is_layer = []

        for row in rows:
            ara_list_from_dBase.append(row[0])


        for f in layer.getFeatures():
            id = f.id()
            feat = layer.getFeature(id)
            area_list_from_layer.append(feat[field_area_id])



        for data_dbase in  ara_list_from_dBase:
            if data_dbase in area_list_from_layer:
                exist_in_both.append(data_dbase)
            else:
                exist_id_dbase.append(data_dbase)

        for data_layer in area_list_from_layer:
            if data_layer not in ara_list_from_dBase:
                exist_is_layer.append(data_layer)

        self.appendDataToLabel("Raporty kontroli (*.csv): " + self.get_file_directory() + "/monitoring_gis_tools_raporty_kontroli", self.dockwidget.label_info)

        self.appendDataToLabel("", self.dockwidget.label_info)
        self.appendDataToLabel("Powierzchnie istniejące zarówno w warstwie i w bazie danych:", self.dockwidget.label_info)
        print("Powierzchnie istniejące w warstwie i w bazie:")
        for data in exist_in_both:
            self.appendDataToLabel(str(data), self.dockwidget.label_info)
            print(str(data))
        self.generate_csv_reports("Powierzchnie istniejące zarówno w warstwie i w bazie danych", ["ID_STANOWISKA"], exist_in_both, "monitoring_gis_tools_raporty_kontroli", "03011_wykaz_powierzchni_zgodnych_mapa_baza.csv")



        self.appendDataToLabel("", self.dockwidget.label_warning)
        self.appendDataToLabel("Powierzchnie istniejące w bazie danych a nie istniejące w warstwie:", self.dockwidget.label_warning)
        print("Powierzchnie istniejące wyłącznie w bazie danych:")
        for data in exist_id_dbase:
            self.appendDataToLabel(str(data), self.dockwidget.label_warning)
            print(str(data))
        self.generate_csv_reports("Powierzchnie istniejące w bazie danych a nie istniejące w warstwie", ["ID_STANOWISKA"], exist_id_dbase, "monitoring_gis_tools_raporty_kontroli","03012_wykaz_powierzchni_isnt_wylacznie_w_bazie.csv")


        self.appendDataToLabel("", self.dockwidget.label_warning)
        self.appendDataToLabel("Powierzchnie istniejące w warstwie a nie istniejące w bazie danych:", self.dockwidget.label_warning)
        print("Powierzchnie istniejące wyłącznie w warstwie:")
        for data in exist_is_layer:
            self.appendDataToLabel(str(data), self.dockwidget.label_warning)
            print(str(data))
        self.generate_csv_reports("Powierzchnie istniejące w warstwie a nie istniejące w bazie danych", ["ID_STANOWISKA"], exist_is_layer, "monitoring_gis_tools_raporty_kontroli","03013_wykaz_powierzchni_isnt_wylacznie_w_warstwie.csv")


        if exist_is_layer or exist_id_dbase:
            self.dockwidget.pushButton_compatibilyty.setStyleSheet('QPushButton {background-color: #ff0000}')
        else:
            self.dockwidget.pushButton_compatibilyty.setStyleSheet('QPushButton {background-color: #3cb371}')



    def make_buffer_area(self):

        # Clear info labels
        self.clear_info_labels()
        self.removeMapLayerByName('polygonized_layer')

        layer = self.dockwidget.mMapLayerComboBoxAraesPolygon.currentLayer()
        additional_height = self.dockwidget.lineEdit_additional_height.text().replace(",", ".")
        reduced_height = self.dockwidget.lineEdit_reduced_height.text().replace(",", ".")

        if not (layer):
            self.dockwidget.label_warning.setText("Nie wskazano warstwy!")
            return False

        feature_to_analize = layer.selectedFeatures()

        # Create a temporary layer for the selected features
        temp_layer = QgsVectorLayer("Polygon?crs=" + layer.crs().authid(), "temp_buffer", "memory")
        temp_layer.dataProvider().addFeatures(feature_to_analize)
        # QgsProject.instance().addMapLayer(temp_layer)

        raster_layer = self.dockwidget.mMapLayerComboBox_nmt_raster.currentLayer()



        # Clip raster by selected feature
        result = processing.run("gdal:cliprasterbymasklayer", {
            'INPUT': raster_layer,
            'MASK': temp_layer,
            'SOURCE_CRS': QgsCoordinateReferenceSystem('EPSG:2180'),
            'TARGET_CRS': QgsCoordinateReferenceSystem('EPSG:2180'),
            'TARGET_EXTENT': None,
            'NODATA': None,
            'ALPHA_BAND': False,
            'CROP_TO_CUTLINE': True,
            'KEEP_RESOLUTION': False,
            'SET_RESOLUTION': False,
            'X_RESOLUTION': None,
            'Y_RESOLUTION': None,
            'MULTITHREADING': False,
            'OPTIONS': '',
            'DATA_TYPE': 0,
            'EXTRA': '',
            'OUTPUT': 'TEMPORARY_OUTPUT'})
        cut_result_raster = QgsRasterLayer(result['OUTPUT'], 'result_layer')
        # QgsProject.instance().addMapLayer(cut_result_raster)


        # Calculate statistics
        provider = cut_result_raster.dataProvider()
        ext = cut_result_raster.extent()
        stats = provider.bandStatistics(1, QgsRasterBandStats.All, ext, 0)

        self.appendDataToLabel("Minmalna wysokość: " + str(round(stats.minimumValue,2)) + " m", self.dockwidget.label_info)
        self.appendDataToLabel("Maksymalna wysokość: " + str(round(stats.maximumValue,2)) + " m", self.dockwidget.label_info)
        self.appendDataToLabel("średnia wysokość: " + str(round(stats.mean,2)) + " m", self.dockwidget.label_info)
        self.appendDataToLabel("Odchylenie standardowe: " + str(round(stats.stdDev,2)), self.dockwidget.label_info)



        # 01 Buffer of polygon to analize
        max_buffer_width = self.dockwidget.lineEdit_max_buffer_width.text()
        result = processing.run("native:buffer", {'INPUT': temp_layer, 'DISTANCE': max_buffer_width, 'SEGMENTS': 5, 'END_CAP_STYLE': 0, 'JOIN_STYLE': 0, 'MITER_LIMIT': 2,'DISSOLVE': False,'OUTPUT': 'memory:'})
        buffer_layer = result['OUTPUT']
        buffer_layer.setName('buffer')
        # QgsProject.instance().addMapLayer(buffer_layer)


        #02 Difference - ring
        result = processing.run("native:difference", {'INPUT': buffer_layer, 'OVERLAY': temp_layer, 'OUTPUT': 'memory:', 'GRID_SIZE': None})
        difference_layer = result['OUTPUT']
        difference_layer.setName('difference')
        # QgsProject.instance().addMapLayer(difference_layer)


        # 03 Cut raster by polygon
        result = processing.run("gdal:cliprasterbymasklayer", {
            'INPUT': raster_layer,
            'MASK': difference_layer,
            'SOURCE_CRS': QgsCoordinateReferenceSystem('EPSG:2180'),
            'TARGET_CRS': QgsCoordinateReferenceSystem('EPSG:2180'),
            'TARGET_EXTENT': None,
            'NODATA': None,
            'ALPHA_BAND': False,
            'CROP_TO_CUTLINE': True,
            'KEEP_RESOLUTION': False,
            'SET_RESOLUTION': False,
            'X_RESOLUTION': None,
            'Y_RESOLUTION': None,
            'MULTITHREADING': False,
            'OPTIONS': '',
            'DATA_TYPE': 0,
            'EXTRA': '',
            'OUTPUT': 'TEMPORARY_OUTPUT'})
        cut_result_raster = QgsRasterLayer(result['OUTPUT'], 'result_layer')
        # QgsProject.instance().addMapLayer(cut_result_raster)


        # 04 First seection on raster
        max_buffer_heigth = str(round(stats.mean) + float(additional_height))
        min_buffer_heigth = str(round(stats.minimumValue) + float(reduced_height))
        # expression = '(1 * (A < 10) + 1 > 50)'
        # expresion = f'((A < {max_buffer_heigth}) + (A > {round(stats.maximumValue)}))'
        # expresion = f'((A < {max_buffer_heigth}))'




        if self.dockwidget.checkBox_analize_min_heigth.isChecked():
            expresion = f'(A > {min_buffer_heigth})*(A <= {max_buffer_heigth}) * 2'
        else:
            expresion = f'((A <= {max_buffer_heigth}))'

        parameters = {'INPUT_A': cut_result_raster, 'BAND_A': 1, 'FORMULA': expresion, 'NODATAVALUE': 1, 'OUTPUT': 'TEMPORARY_OUTPUT'}
        result = processing.run('gdal:rastercalculator', parameters)  # feed in the param
        analize_result_raster = QgsRasterLayer(result['OUTPUT'], 'result_layer01')
        # QgsProject.instance().addMapLayer(analize_result_raster)


        # 06 raster to polygon
        result = processing.run("gdal:polygonize", {
            'INPUT': analize_result_raster,
            'BAND': 1, 'FIELD': 'DN', 'EIGHT_CONNECTEDNESS': False, 'EXTRA': '', 'OUTPUT': 'TEMPORARY_OUTPUT'})
        polygonized_layer = QgsVectorLayer(result['OUTPUT'], 'polygonized_layer')

        # 07 Remove 0 values

        polygonized_layer.selectByExpression("DN = 0")
        polygonized_layer.startEditing()
        polygonized_layer.deleteSelectedFeatures()
        polygonized_layer.commitChanges()
        polygonized_layer.removeSelection()

        QgsProject.instance().addMapLayer(polygonized_layer)




    def getListOfAreaByQuery(self, query):

        list = []

        # Clear info labels
        self.clear_info_labels()

        # Dbase address
        d_base = self.get_dBase_directory()
        if not d_base:
            print("Faill")
            return False

        conn = sqlite3.connect(d_base)
        cursor = conn.cursor()
        cursor.execute(query)
        rows = cursor.fetchall()
        for row in rows:
            print(row[0])
            list.append(row[0])
        return list


    def is_numeric_with_dots(self, input_str):
        # Define the regular expression pattern
        pattern = re.compile(r'^[0-9.]+$')
        # Use the search function to check if the pattern matches the input string
        match = pattern.search(input_str)
        # If a match is found, the input string contains only numeric characters and dots
        return bool(match)


    def is_numeric_and_length(self, input_str):
        # Check if the length is 10
        if len(input_str) == 10:
            # Check if all characters are digits
            if input_str.isdigit():
                return True
            else:
                return False
        else:
            return False


    def get_file_directory(self):
        # Dbase address
        d_base = str(self.dockwidget.lineEdit_dBase_directory.text()).replace('\\', '/')
        # check if base exist
        if not (str(d_base)):
            self.dockwidget.label_warning.setText("Nie wskazano bazy danych!")
            return False
        else:
            return os.path.dirname(d_base)


    def getLayer(self):
        layer = self.dockwidget.mMapLayerComboBoxAraesPolygon.currentLayer()
        if not (str(layer)):
            CustomMessageBox.showWithTimeout(10, "Nie wybrano warstwy!", "", icon=QMessageBox.Warning)
            self.dockwidget.label_warning.setText("Nie wybrano warstwy!")
            return False
        else:
            return layer


    def get_dBase_directory(self):
        # Dbase address
        d_base = str(self.dockwidget.lineEdit_dBase_directory.text()).replace('\\', '/')
        # check if base exist
        if not (str(d_base)):
            CustomMessageBox.showWithTimeout(10, "Nie wskazano bazy danych!", "", icon=QMessageBox.Warning)
            self.dockwidget.label_warning.setText("Nie wskazano bazy danych!")
            return False
        else:
            return d_base

    def generate_geom_kontr_folder(self, folder_name):
        folder_path = os.path.join(self.get_file_directory(), folder_name)
        if not os.path.exists(folder_path):
            os.makedirs(folder_path)
        return folder_path


    def generate_csv_reports(self, description, header, data,  folder_directory, report_name):

        if not os.path.exists(self.get_file_directory() + "/" + folder_directory):
            os.makedirs(self.get_file_directory() + "/" + folder_directory)

        current_date = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

        file_path = self.get_file_directory() + "/" + folder_directory + "/" + report_name

        data = [[str(item)] for item in data]

        with open(file_path, 'w', encoding='cp1250', newline='') as f:
            writer = csv.writer(f, delimiter=';')

            # write the header
            writer.writerow([description])
            writer.writerow(['Wygenerowano: ', current_date])
            writer.writerow("")
            writer.writerow(header)
            # write multiple rows
            writer.writerows(data)

    def generate_csv_reports_second(self, name, description, header, data,  folder_directory, report_name):

        if not os.path.exists(self.get_file_directory() + "/" + folder_directory):
            os.makedirs(self.get_file_directory() + "/" + folder_directory)

        current_date = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

        file_path = self.get_file_directory() + "/" + folder_directory + "/" + report_name

        data = [[str(item)] for item in data]

        with open(file_path, 'w', encoding='cp1250', newline='') as f:
            writer = csv.writer(f, delimiter=';')

            # write the header
            writer.writerow([name])
            writer.writerow([description])
            writer.writerow(['Wygenerowano: ', current_date])
            writer.writerow("")
            writer.writerow(header)
            # write multiple rows
            writer.writerows(data)

    def repair_geometry_and_resave(input_path, output_path):
        # Load the input vector layer
        input_layer = QgsVectorLayer(input_path, 'input_layer', 'ogr')

        # Check if the layer is loaded successfully
        if not input_layer.isValid():
            print(f'Error: The input layer {input_path} failed to load!')
            return

        # Run the "native:fixgeometries" algorithm to repair geometry
        feedback = QgsProcessingFeedback()
        params = {'INPUT': input_layer, 'OUTPUT': 'memory:'}
        result = processing.run("native:fixgeometries", params, feedback=feedback)

        # Check if the algorithm ran successfully
        if result['OUTPUT'] is None:
            print('Error: Geometry repair failed!')
            return

        # Save the repaired layer to a new file
        repaired_layer = result['OUTPUT']
        QgsVectorFileWriter.writeAsVectorFormat(repaired_layer, output_path, 'utf-8', None, 'ESRI Shapefile')

        print(f'Repaired geometry saved to {output_path}')


    def removeMapLayerByName(self, layer_name_to_remove):

        root = QgsProject.instance().layerTreeRoot()
        for layer in root.children():
            layerName = str(layer.name())
            if layerName == str(layer_name_to_remove):
                layerByName = QgsProject.instance().mapLayersByName(layerName)[0]
                QgsProject.instance().removeMapLayer(layerByName.id())

    def test (self):

        self.get_error_result_by_error_code(30100)
        #
        #
        # new_control_model = self.select_control_models_by_error_code(30100)
        # data = new_control_model[0].get_error_query()
        # print(data)

    # def add_data_to_control_model(self):
    #     control_model = ControlModel(
    #         area_id=1234567890,
    #         year=2024,
    #         error_code=101,
    #         error_name="SampleError",
    #         error_poz_name="Position1",
    #         error_description="This is a sample error description.",
    #         warning_flag=1,
    #         error_status_flag=0,
    #         error_query="SELECT * FROM errors"
    #     )
    #     return control_model

    import sqlite3

    def get_error_result_by_error_code(self, error_code):
        # ADD report
        self.clearPlainTextEditInfo()

        # 01 Get list of areas
        list_of_areas = self.getListOfAreaByQuery("SELECT DISTINCT stanowisko_nr, rok FROM stanowisko_rok")
        if not list_of_areas:
            print("No areas found")
            return

        # Print list of areas to debug
        # print("List of Areas:", list_of_areas)

        # Dbase address
        d_base = self.get_dBase_directory()
        if not d_base:
            print("Database directory not found")
            return

        # Declare connections
        conn = sqlite3.connect(d_base)
        cur = conn.cursor()

        # 02 Get sql query from 'sl_kontole'
        query = ""
        controll_name = ""
        code_desc = ""

        try:
            cur.execute("SELECT kwerenda, kontrola_nm, kod_opis FROM sl_kontrola WHERE kontrola_cd=?", (error_code,))
            rows = cur.fetchall()

            if not rows:
                print("No control found for the given error code")
                return

            for row in rows:
                query = row[0]
                controll_name = row[1]
                code_desc = row[2]

            if not query:
                print("Query is empty")
                return

            list_of_failed_areas = []

            for data in list_of_areas:
                if isinstance(data, tuple) and len(data) == 2:
                    stanowisko_nr, rok = data
                else:
                    stanowisko_nr = data
                    rok = self.selected_year

                # print(f"Executing query for stanowisko_nr: {stanowisko_nr}, rok: {rok}")

                # Print the query and parameters to debug
                # print(f"Query: {query}")
                # print(f"Parameters: ({stanowisko_nr}, {rok})")

                # Count the number of placeholders in the query
                num_placeholders = query.count('?')

                try:
                    if num_placeholders == 2:
                        cur.execute(query, (stanowisko_nr, rok))
                    elif num_placeholders == 1:
                        cur.execute(query, (stanowisko_nr,))
                    else:
                        # print(f"Unexpected number of placeholders ({num_placeholders}) in query: {query}")
                        return

                    rows = cur.fetchall()
                    if rows:
                        # print(f"Failed areas for stanowisko_nr: {stanowisko_nr}, rok: {rok}: {rows}")
                        for row in rows:
                            list_of_failed_areas.append(row[0])
                except sqlite3.OperationalError as e:
                    print(f"SQLite error: {e}")

            if len(list_of_failed_areas) > 0:
                self.appendDataToPlainTextEdit("", self.dockwidget.plainTextEdit_info)
                self.appendDataToPlainTextEdit(controll_name, self.dockwidget.plainTextEdit_info)
                for data_dbase in list_of_failed_areas:
                    self.appendDataToPlainTextEdit(str(data_dbase), self.dockwidget.plainTextEdit_info)
                self.generate_csv_reports_second(controll_name, code_desc, ["ID_STANOWISKA"], list_of_failed_areas,
                                                 "monitoring_gis_tools_raporty_kontroli",
                                                 f"Kontrola_numer_{error_code}.csv")
                button_name = f'pushButton{error_code}'
                button = getattr(self.dockwidget, button_name)
                button.setStyleSheet('QPushButton {background-color: #ff0000}')
            else:
                self.appendDataToPlainTextEdit(f"Kontrola {error_code} przebiegła pomyślnie",
                                               self.dockwidget.plainTextEdit_info)
                self.generate_csv_reports_second(controll_name, code_desc, ["ID_STANOWISKA"], list_of_failed_areas,
                                                 "monitoring_gis_tools_raporty_kontroli",
                                                 f"Kontrola_numer_{error_code}_OK.csv")
                button_name = f'pushButton{error_code}'
                button = getattr(self.dockwidget, button_name)
                button.setStyleSheet('QPushButton {background-color: #3cb371}')
        finally:
            conn.close()  # Make sure to close the database connection

    def select_control_models_by_error_code(self, error_code: str) -> List[ControlModel]:

        self.clear_info_labels()

        # Dbase address
        d_base = str(self.dockwidget.lineEdit_dBase_directory.text()).replace('\\', '/')

        # Clear warning massage
        self.dockwidget.label_warning.setText("")

        # check if base exist
        if not (str(d_base)):
            self.dockwidget.label_warning.setText("Nie wskazano bazy danych!")
            return False


        # Declare connections
        conn = sqlite3.connect(d_base)

        cur = conn.cursor()
        cur.execute(
            "SELECT * FROM sl_kontrola WHERE kontrola_cd=?",
            (error_code,))

        rows = cur.fetchall()

        control_models = []
        for row in rows:
            control_model = ControlModel(
                area_id=0,
                year=2024,
                error_code=row[0],
                error_name=row[1],
                error_poz_name=row[2],
                error_description=row[3],
                warning_flag=row[4],
                error_status_flag=0,
                error_query=row[5]
            )
            control_models.append(control_model)

        return control_models


    #--------------------------------------------------------------------------
    def run(self):
        """Run method that loads and starts the plugin"""



        if not self.pluginIsActive:
            self.pluginIsActive = True


            #print "** STARTING MonitoringTools"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = MonitoringToolsDockWidget()

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            self.comboBoxAraesPolygonSelectAction()

            # Populate year combo box
            self.populate_year_combobox()

            # Connect the combo box signal to update the selected year
            self.dockwidget.comboBoxYear.currentIndexChanged.connect(self.update_selected_year)

            # Odświeżanie ostatnio wykorzystanych ścieżek
            self.dBaseDirectoryLoad()

            # Actions button click
            self.dockwidget.pushButton_select_dBase.clicked.connect(self.selectDbaseDirectory)
            self.dockwidget.pushButton_generate_point_layer.clicked.connect(self.generatePointLayer)
            self.dockwidget.pushButton_compatibilyty.clicked.connect(self.compatibilyty_check_tools)
            self.dockwidget.pushButtonNumerationValidatingLayer.clicked.connect(self.numeration_validating_map)


            # T_0101
            self.dockwidget.pushButton_rewrite_area_to_dbase.clicked.connect(self.rewrite_area_to_dbase)

            # T_0103
            self.dockwidget.pushButton_add_coordinates_to_d_base.clicked.connect(self.add_coordinates_to_dbase)

            # T_0104
            self.dockwidget.pushButton_correct_compatibility.clicked.connect(self.corect_compatibility)

            # T_0105
            self.dockwidget.pushButton_asign_n2000_to_dbase.clicked.connect(self.asign_n2000_to_dbase)

            # T_0106
            self.dockwidget.pushButton_repair_geometryset_crs.clicked.connect(self.repair_geometry_cet_crs)

            # T_0107
            self.dockwidget.pushButton_round_geometry.clicked.connect(self.round_geometry)

            # Snap
            self.dockwidget.pushButton_snaptool.clicked.connect(self.snap_vertices_to_rezerwaty)


            # T_0108
            self.dockwidget.pushButton_prepare_structure.clicked.connect(self.prepare_structure)

            # T_0109
            self.dockwidget.pushButton_asign_nature_reserve_to_dbase.clicked.connect(self.asign_nature_reserve_to_dbase)


            # C_0102
            self.dockwidget.pushButton_control_duplicates.clicked.connect(self.control_duplicates)
            # C_0103
            self.dockwidget.pushButton_control_n2000_extent.clicked.connect(self.control_n2000_extent)
            # C_0104
            self.dockwidget.pushButton_control_nat_reserve_extent.clicked.connect(self.control_nat_reserve_extent)
            # C_0105
            self.dockwidget.pushButton_find_overlaps.clicked.connect(self.find_overlaps)
            # C_0106
            self.dockwidget.pushButton_find_gaps.clicked.connect(self.find_gaps)


            # T_0301
            self.dockwidget.mMapLayerComboBox_nmt_raster.setFilters(QgsMapLayerProxyModel.RasterLayer)
            self.dockwidget.pushButton_make_buffer_area.clicked.connect(self.make_buffer_area)

            # przyciski kontroli Baza2

            # 30100
            self.dockwidget.pushButton30100.clicked.connect(self.run_control_30100)
            # 30210
            self.dockwidget.pushButton30210.clicked.connect(self.run_control_30210)
            # 30220
            self.dockwidget.pushButton30220.clicked.connect(self.run_control_30220)
            # 30230
            self.dockwidget.pushButton30230.clicked.connect(self.run_control_30230)
            # 30500
            self.dockwidget.pushButton30500.clicked.connect(self.run_control_30500)
            # 30150
            self.dockwidget.pushButton30150.clicked.connect(self.run_control_30150)
            # 30211
            self.dockwidget.pushButton30211.clicked.connect(self.run_control_30211)
            # 30221
            self.dockwidget.pushButton30221.clicked.connect(self.run_control_30221)
            # 30231
            self.dockwidget.pushButton30231.clicked.connect(self.run_control_30231)
            # 30200
            self.dockwidget.pushButton30200.clicked.connect(self.run_control_30200)
            # 30201
            self.dockwidget.pushButton30201.clicked.connect(self.run_control_30201)
            # 30501
            self.dockwidget.pushButton30501.clicked.connect(self.run_control_30501)
            # 10210
            self.dockwidget.pushButton10210.clicked.connect(self.run_control_10210)
            # 10211
            self.dockwidget.pushButton10211.clicked.connect(self.run_control_10211)
            # 10200
            self.dockwidget.pushButton10200.clicked.connect(self.run_control_10200)
            # 10201
            self.dockwidget.pushButton10201.clicked.connect(self.run_control_10201)
            # 10220
            self.dockwidget.pushButton10220.clicked.connect(self.run_control_10220)
            # 10221
            self.dockwidget.pushButton10221.clicked.connect(self.run_control_10221)
            # 10280
            self.dockwidget.pushButton10280.clicked.connect(self.run_control_10280)
            # 10101
            self.dockwidget.pushButton10101.clicked.connect(self.run_control_10101)
            # 10102
            self.dockwidget.pushButton10102.clicked.connect(self.run_control_10102)
            # 10010
            self.dockwidget.pushButton10010.clicked.connect(self.run_control_10010)
            # 10001
            self.dockwidget.pushButton10001.clicked.connect(self.run_control_10001)
            # 10002
            self.dockwidget.pushButton10002.clicked.connect(self.run_control_10002)
            # 10005
            self.dockwidget.pushButton10005.clicked.connect(self.run_control_10005)
            # 10020
            self.dockwidget.pushButton10020.clicked.connect(self.run_control_10020)
            # 10240
            self.dockwidget.pushButton10240.clicked.connect(self.run_control_10240)
            # 10230
            self.dockwidget.pushButton10230.clicked.connect(self.run_control_10230)
            # 10231
            self.dockwidget.pushButton10231.clicked.connect(self.run_control_10231)
            # 10250
            self.dockwidget.pushButton10250.clicked.connect(self.run_control_10250)
            # 10251
            self.dockwidget.pushButton10251.clicked.connect(self.run_control_10251)
            # 10252
            self.dockwidget.pushButton10252.clicked.connect(self.run_control_10252)
            # 10260
            self.dockwidget.pushButton10260.clicked.connect(self.run_control_10260)
            # 10270
            self.dockwidget.pushButton10270.clicked.connect(self.run_control_10270)
            # 10271
            self.dockwidget.pushButton10271.clicked.connect(self.run_control_10271)
            # 10290
            self.dockwidget.pushButton10290.clicked.connect(self.run_control_10290)
            # 10300
            self.dockwidget.pushButton10300.clicked.connect(self.run_control_10300)
            # 10281
            self.dockwidget.pushButton10281.clicked.connect(self.run_control_10281)
            # 20000
            self.dockwidget.pushButton20000.clicked.connect(self.run_control_20000)
            # 20001
            self.dockwidget.pushButton20001.clicked.connect(self.run_control_20001)
            # 20002
            self.dockwidget.pushButton20002.clicked.connect(self.run_control_20002)
            # 20003
            self.dockwidget.pushButton20003.clicked.connect(self.run_control_20003)
            # 20004
            self.dockwidget.pushButton20004.clicked.connect(self.run_control_20004)
            # 20005
            self.dockwidget.pushButton20005.clicked.connect(self.run_control_20005)
            # 20006
            self.dockwidget.pushButton20006.clicked.connect(self.run_control_20006)
            # 20010
            self.dockwidget.pushButton20010.clicked.connect(self.run_control_20010)
            # 20020
            self.dockwidget.pushButton20020.clicked.connect(self.run_control_20020)
            # 10500
            self.dockwidget.pushButton10500.clicked.connect(self.run_control_10500)
            # 10600
            self.dockwidget.pushButton10600.clicked.connect(self.run_control_10600)
            # 10700
            self.dockwidget.pushButton10700.clicked.connect(self.run_control_10700)
            # 30232
            self.dockwidget.pushButton30232.clicked.connect(self.run_control_30232)
            # 30212
            self.dockwidget.pushButton30212.clicked.connect(self.run_control_30212)
            # 30222
            self.dockwidget.pushButton30222.clicked.connect(self.run_control_30222)
            # 10702
            self.dockwidget.pushButton10702.clicked.connect(self.run_control_10702)
            # 10701
            self.dockwidget.pushButton10701.clicked.connect(self.run_control_10701)
            # 10703
            self.dockwidget.pushButton10703.clicked.connect(self.run_control_10703)
            # 10704
            self.dockwidget.pushButton10704.clicked.connect(self.run_control_10704)
            # 10705
            self.dockwidget.pushButton10705.clicked.connect(self.run_control_10705)
            # 10601
            self.dockwidget.pushButton10601.clicked.connect(self.run_control_10601)
            # 10602
            self.dockwidget.pushButton10602.clicked.connect(self.run_control_10602)
            # 10501
            self.dockwidget.pushButton10501.clicked.connect(self.run_control_10501)
            # 10502
            self.dockwidget.pushButton10502.clicked.connect(self.run_control_10502)
            # 30502
            self.dockwidget.pushButton30502.clicked.connect(self.run_control_30502)
            # 30101
            self.dockwidget.pushButton30101.clicked.connect(self.run_control_30101)
            # 30102
            self.dockwidget.pushButton30102.clicked.connect(self.run_control_30102)
            # 10100
            self.dockwidget.pushButton10100.clicked.connect(self.run_control_10100)
            # 10282
            self.dockwidget.pushButton10282.clicked.connect(self.run_control_10282)
            #
            # K10000
            self.dockwidget.pushButtonK10000.clicked.connect(self.complex_control_general_data)
            # K30000
            self.dockwidget.pushButtonK30000.clicked.connect(self.complex_control_ratings)
            # K20000
            self.dockwidget.pushButtonK20000.clicked.connect(self.complex_control_phytoreleves)
            # K10500
            self.dockwidget.pushButtonK10500.clicked.connect(self.complex_control_threats)

            # test
            self.dockwidget.pushButtonTest.clicked.connect(self.test)



            self.dockwidget.mMapLayerComboBoxAraesPolygon.activated.connect(lambda: self.comboBoxAraesPolygonSelectAction())
            self.dockwidget.mMapLayerComboBoxAraesPolygon.layerChanged.connect(lambda: self.comboBoxAraesPolygonSelectAction())
            self.dockwidget.mMapLayerComboBoxAraesPolygon.currentIndexChanged.connect(self.comboBoxAraesPolygonSelectAction)



            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)
            self.dockwidget.show()
