# -*- coding: utf-8 -*-
"""
/***************************************************************************
 MonitoringTools
                                 A QGIS plugin
 Wetlands Green Life Monitoring Tools
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-11-11
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Borys Draus
        email                : borys.draus@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from typing import List

from qgis import processing, PyQt
from qgis.core import QgsFillSymbol, QgsSimpleFillSymbolLayer, QgsMarkerSymbol, QgsSimpleMarkerSymbolLayer, QgsSingleSymbolRenderer, QgsSimpleMarkerSymbolLayerBase, QgsFeature, QgsDistanceArea, QgsUnitTypes, QgsLayerTreeLayer, QgsPoint, QgsPointLocator, QgsSnappingConfig, QgsSnappingUtils, QgsTolerance, QgsProcessingFeatureSourceDefinition, QgsProcessingAlgorithm, QgsProcessingParameterFeatureSource, QgsProcessingParameterFeatureSink, QgsFeatureRequest, QgsSpatialIndex
from qgis.core import QgsVectorLayer, QgsFeature, QgsField, QgsCoordinateReferenceSystem,QgsCoordinateTransform, QgsGeometry, QgsPointXY, QgsField, QgsProject, Qgis, QgsProcessingFeedback, QgsExpression, edit, QgsExpressionContext, QgsExpressionContextUtils, QgsVectorFileWriter, QgsVectorLayer, QgsProject, QgsProcessingFeedback, QgsApplication, QgsProcessingContext
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, Qt
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog, QLineEdit, QToolBar, QProgressDialog
from PyQt5.QtWidgets import QMessageBox, QWidget
from PyQt5.QtCore import QVariant, Qt,QFileInfo

from PIL import Image
from PIL.ExifTags import TAGS, GPSTAGS

from .control_model import ControlModel
from .site_year_model import SiteYearModel
from .site_year_date_of_control_model import SiteYearDateOfControllModel
from .TimerMessageBox import CustomMessageBox
# Initialize Qt resources from file resources.py
from .resources import *

from qgis._core import QgsWkbTypes, QgsMapLayer, QgsVectorFileWriter, QgsField, QgsRectangle, QgsMapLayerProxyModel

import subprocess
import sys

from datetime import datetime
import geopandas as gpd
from shapely.geometry import MultiPolygon
from shapely import Polygon, MultiLineString, Point, MultiPoint

from .atribute_table_manager import AtributeTableManager

# Import the code for the DockWidget
from .monitoring_tools_dockwidget import MonitoringToolsDockWidget
import sqlite3
import re
import os
import csv
from datetime import datetime

from qgis.core import QgsRasterLayer, QgsRasterBandStats
from qgis.analysis import QgsRasterCalculator, QgsRasterCalculatorEntry


class MonitoringTools:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)

        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'MonitoringTools_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&MonitoringTools')
        # TODO: We are going to let the user set this up in a future iteration
        self.toolbar = self.iface.addToolBar(u'MonitoringTools')
        self.toolbar.setObjectName(u'MonitoringTools')

        #print "** INITIALIZING MonitoringTools"

        self.pluginIsActive = False
        self.dockwidget = None

        self.selected_year = datetime.now().year  # Initialize with the current year

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('MonitoringTools', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            self.toolbar.addAction(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action


    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/monitoring_tools/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'MonitoringTools'),
            callback=self.run,
            parent=self.iface.mainWindow())



    #--------------------------------------------------------------------------

    def onClosePlugin(self):
        """Cleanup necessary items here when plugin dockwidget is closed"""

        #print "** CLOSING MonitoringTools"

        # disconnects
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)

        # remove this statement if dockwidget is to remain
        # for reuse if plugin is reopened
        # Commented next statement since it causes QGIS crashe
        # when closing the docked window:
        # self.dockwidget = None

        self.pluginIsActive = False


    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""

        #print "** UNLOAD MonitoringTools"

        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&MonitoringTools'),
                action)
            self.iface.removeToolBarIcon(action)
        # remove the toolbar
        del self.toolbar



    def appendDataToLabel(self, text_message, QLabel):
        text = QLabel.text()
        if text:
            print(text_message)
            QLabel.setText(text + "\n" + text_message)
        else:
            QLabel.setText(text_message)


    def clearPlainTextEditInfo(self):
        self.dockwidget.plainTextEdit_info.setPlainText("")

    def appendDataToPlainTextEdit(self, text_message, plain_text_edit):
        current_text = plain_text_edit.toPlainText().strip()  # Get current text and strip whitespace
        text_message = text_message.strip()  # Strip whitespace from the new message

        # Combine current text and new message, handling newline characters
        new_text = current_text + "\n" + text_message if current_text else text_message

        # Set the updated text to the QPlainTextEdit
        plain_text_edit.setPlainText(new_text)


    # Wskazanie bazy danych
    def selectDbaseDirectory(self):
        filename = QFileDialog.getOpenFileName(self.dockwidget, "Wskaż bazę danych: *.db", "", "*.db")
        if isinstance(filename, tuple):
            self.dockwidget.lineEdit_dBase_directory.setText(filename[0])
            # Wskazanie lokalizacji folderów z adresem
            dirnameOfCatalog = self.resolveDir('info')
            dirOfFile = dirnameOfCatalog + "/base_address.txt"
            file = open(dirOfFile, "w+")
            file.write(str(filename[0]))
            file.close()


    # Ladowanie adresu bazy po uruchomieniu aplikacji
    def dBaseDirectoryLoad(self):
        dirnameOfCatalog = self.resolveDir('info')
        dirOfFile = dirnameOfCatalog + "/base_address.txt"
        if os.path.isfile(dirOfFile):
            with open(dirOfFile) as f:
                f = f.readline()
                if os.path.exists(str(f)):
                    self.dockwidget.lineEdit_dBase_directory.setText(str(f))

        # Wskazanie folderu zdjęc

    def selectPictureDirectory(self):
        directory = QFileDialog.getExistingDirectory(self.dockwidget, "Wskaż folder ze zdjęciami")
        if directory:
            self.dockwidget.lineEdit_picture_directory.setText(directory)
            # Save the directory path to a file
            dirnameOfCatalog = self.resolveDir('info')
            dirOfFile = os.path.join(dirnameOfCatalog, "picture_address.txt")
            with open(dirOfFile, "w+") as file:
                file.write(directory)

    def pictureFolderDirectoryLoad(self):
        dirnameOfCatalog = self.resolveDir('info')
        dirOfFile = os.path.join(dirnameOfCatalog, "picture_address.txt")
        if os.path.isfile(dirOfFile):
            with open(dirOfFile) as f:
                directory = f.readline().strip()
                if os.path.exists(directory):
                    self.dockwidget.lineEdit_picture_directory.setText(directory)


    # Metoda zwraca lokalizację wskazanego folderu lub pliku
    def resolveDir(self, name, basepath=None):
        if not basepath:
            basepath = os.path.dirname(os.path.realpath(__file__))
        return os.path.join(basepath, name)


    # Method for cear info label and warning label
    def clear_info_labels(self):
        self.dockwidget.label_info.setText("")
        self.dockwidget.label_warning.setText("")


    def comboBoxAraesPolygonSelectAction(self):
        self.dockwidget.mMapLayerComboBoxAraesPolygon.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.dockwidget.comboBoxFieldsName.clear()
        layer = self.dockwidget.mMapLayerComboBoxAraesPolygon.currentLayer()
        if layer != None:
            # Get the list of field names (column names)
            field_names = [field.name() for field in layer.fields()]
            self.dockwidget.comboBoxFieldsName.addItems(field_names)

    def populate_year_combobox(self):
        # Populate the combo box and set the current year as default.
        current_year = datetime.now().year
        start_year = 2023
        end_year = 2032
        # Clear any existing items
        self.dockwidget.comboBoxYear.clear()
        # Add the years to the combo box
        for year in range(start_year, end_year + 1):
            self.dockwidget.comboBoxYear.addItem(str(year))
        # Set the current year as the default selected item
        index = self.dockwidget.comboBoxYear.findText(str(current_year))
        if index != -1:
            self.dockwidget.comboBoxYear.setCurrentIndex(index)

    def update_selected_year(self):
        """Update the selected year when the combo box changes."""
        self.selected_year = int(self.dockwidget.comboBoxYear.currentText())

    # T_0101
    def generatePointLayer(self):

        # Clear info labels
        self.clear_info_labels()

        # Dbase address
        d_base = str(self.dockwidget.lineEdit_dBase_directory.text()).replace('\\', '/')

        # Clear warning massage
        self.dockwidget.label_warning.setText("")

        # check if base exist
        if not (str(d_base)):
            self.dockwidget.label_warning.setText("Nie wskazano bazy danych!")
            return False

        # Split dbase file name
        base_name = os.path.splitext(os.path.basename(d_base))[0]
        base_name_ext = os.path.basename(d_base)

        # Declare connections
        conn = sqlite3.connect(d_base)
        cursor = conn.cursor()

        # DBASE
        self.appendDataToLabel("", self.dockwidget.label_info)
        self.appendDataToLabel("BAZA DANYCH", self.dockwidget.label_info)
        # File name
        self.appendDataToLabel(base_name_ext, self.dockwidget.label_info)
        # Version
        cursor.execute("PRAGMA user_version;")
        sqlite_version = cursor.fetchone()[0]
        self.appendDataToLabel("Wersja bazy danych: " + str(sqlite_version), self.dockwidget.label_info)
        # Date range
        cursor.execute("SELECT MIN(data_oceny) FROM stanowisko_rok WHERE data_oceny IS NOT NULL AND data_oceny <> ''")
        date_from = cursor.fetchone()[0]
        cursor.execute("SELECT MAX(data_oceny) FROM stanowisko_rok WHERE data_oceny IS NOT NULL AND data_oceny <> ''")
        date_to = cursor.fetchone()[0]
        if date_from is None:
            date_from = "?"
        if date_to is None:
            date_to = "?"
        self.appendDataToLabel("Zakres dat: " + date_from + "  -  " + date_to, self.dockwidget.label_info)

        # EXPERT
        self.appendDataToLabel("", self.dockwidget.label_info)
        self.appendDataToLabel("DANE WYKONAWCY", self.dockwidget.label_info)
        cursor.execute(
            "SELECT DISTINCT stanowisko_rok_ekspert.email, sl_ekspert.imie, sl_ekspert.nazwisko, sl_ekspert.instytucja_cd, sl_ekspert.telefon "
            "FROM stanowisko_rok_ekspert "
            "INNER JOIN sl_ekspert on stanowisko_rok_ekspert.email = sl_ekspert.email")
        rows = cursor.fetchall()
        for row in rows:
            self.appendDataToLabel("Wykonawca: " + row[1] + " " + row[2], self.dockwidget.label_info)
            self.appendDataToLabel(row[3], self.dockwidget.label_info)
            self.appendDataToLabel("Tel: " + row[4], self.dockwidget.label_info)
            self.appendDataToLabel("E-mail: " + row[0], self.dockwidget.label_info)

        # CALCULATED COORDINATES INFORMATIONS
        self.appendDataToLabel("", self.dockwidget.label_info)
        self.appendDataToLabel("KARTY POWIERZCHNI MONITORINGOWYCH", self.dockwidget.label_info)
        cursor.execute("SELECT * FROM stanowisko_rok")
        rows = cursor.fetchall()
        self.appendDataToLabel("Liczba powierzchni: " + str(len(rows)), self.dockwidget.label_info)
        cursor.execute("SELECT * FROM stanowisko_rok WHERE x != '' and y != '' and x > 0 and y >0")
        rows = cursor.fetchall()
        self.appendDataToLabel("Liczba powierzchni ze współrzędnymi: " + str(len(rows)), self.dockwidget.label_info)

        # Information about established and rejected surfaces
        cursor.execute("SELECT COUNT(*) FROM stanowisko_rok WHERE stanowisko_rok.rezygnacja_fl != 1;")
        row_count = cursor.fetchone()[0]
        self.appendDataToLabel("Liczba powierzchni założonych: " + str(row_count), self.dockwidget.label_info)
        cursor.execute("SELECT COUNT(*) FROM stanowisko_rok WHERE stanowisko_rok.rezygnacja_fl = 1;")
        row_count = cursor.fetchone()[0]
        self.appendDataToLabel("Liczba powierzchni odrzuconych: " + str(row_count), self.dockwidget.label_info)

        # DATA FOR POINT LAYER
        cursor.execute("SELECT stanowisko.stanowisko_nr,"
                       " stanowisko.stanowisko_nm,"
                       " stanowisko.siedlisko_cd,"
                       " stanowisko.siedlisko_plan_cd,"
                       " stanowisko.siedlisko_lp_cd,"
                       " stanowisko.zgodnosc_cd,"
                       " stanowisko_rok.x,"
                       " stanowisko_rok.y,"
                       " stanowisko_rok_ekspert.email,"
                       " sl_ekspert.instytucja_cd,"
                       " stanowisko_rok.data_oceny,"
                       " stanowisko_rok.ocena_cd "
                       "FROM stanowisko INNER JOIN stanowisko_rok "
                       "ON stanowisko.stanowisko_nr = stanowisko_rok.stanowisko_nr  "
                       "INNER JOIN stanowisko_rok_ekspert "
                       "ON stanowisko_rok.stanowisko_nr = stanowisko_rok_ekspert.stanowisko_nr and stanowisko_rok.rok = stanowisko_rok_ekspert.rok "
                       "INNER JOIN sl_ekspert ON stanowisko_rok_ekspert.email = sl_ekspert.email "
                       "WHERE x != '' and y != '' and x > 0 and y >0")

        # Fetch all the rows from the result set
        rows = cursor.fetchall()

        vl = QgsVectorLayer("Point", base_name + "_pkt_monit", "memory")
        pr = vl.dataProvider()
        # Enter editing mode
        vl.startEditing()
        # add fields
        pr.addAttributes([QgsField("ID_STAN", QVariant.Int),
                          QgsField("NZW_STAN", QVariant.String),
                          QgsField("SIEDL", QVariant.String),
                          QgsField("SIEDL_PLAN", QVariant.String),
                          QgsField("SIEDL_LP", QVariant.String),
                          QgsField("KOD_ZGODN", QVariant.String),
                          QgsField("X", QVariant.Double),
                          QgsField("Y", QVariant.Double),
                          QgsField("E_MAIL", QVariant.String),
                          QgsField("BUL_ODDZ", QVariant.String),
                          QgsField("DATA", QVariant.String),
                          QgsField("OCENA", QVariant.String)])

        for row in rows:

            x_str = row[7]
            y_str = row[6]

            x = 0
            y = 0

            if self.is_numeric_with_dots(str(x_str)):
                x = float(x_str)
            else:
                self.appendDataToLabel(
                    "Błędne wartości współrzędnych w bazie danych: " + str(x_str) + " Stanowisko:" + str(row[0]),
                    self.dockwidget.label_warning)
                continue

            if self.is_numeric_with_dots(str(y_str)):
                y = float(y_str)
            else:
                self.appendDataToLabel(
                    "Błędne wartości współrzędnych w bazie danych: " + str(y_str) + " Stanowisko:" + str(row[0]),
                    self.dockwidget.label_warning)
                continue

            fet = QgsFeature()
            fet.setGeometry(QgsGeometry.fromPointXY(QgsPointXY(x, y)))

            fet.setAttributes([row[0], row[1], row[2], row[3], row[4], row[5], x, y, row[8], row[9], row[10], row[11]])

            pr.addFeatures([fet])

        # Commit changes
        vl.commitChanges()
        vl.renderer().symbol().setSize(2)
        vl.triggerRepaint()

        # Close the cursor and connection
        cursor.close()
        conn.close()

        # Show in project
        QgsProject.instance().addMapLayer(vl)


    # T_0102
    def rewrite_area_to_dbase(self):

        # Clear info labels
        self.clear_info_labels()

        # Dbase
        d_base = self.get_dBase_directory()
        if not d_base:
            return False

        # Layer
        layer = self.getLayer()
        if not layer:
            return False

        CustomMessageBox.showWithTimeout(10, "Obliczanie powierzchni poligonów...", "", icon=QMessageBox.Information)
        self.appendDataToLabel("Obliczanie powierzchni poligonów...", self.dockwidget.label_info)

        # Connection settings
        conn = sqlite3.connect(d_base)
        cursor = conn.cursor()

        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, layer, "AREA_HA", QVariant.Double)
        layer_provider = layer.dataProvider()
        layer_fields = layer.fields()
        field_area = layer_fields.indexFromName("AREA_HA")
        features_of_layer = layer.getFeatures()
        total_features = layer.featureCount()
        area_list_from_layer = []
        list_of_subarea = []
        field_name = self.dockwidget.comboBoxFieldsName.currentText()
        field_area_id = layer.fields().indexFromName(field_name)


          # Create a progress dialog
        progress_dialog = QProgressDialog("Processing...", "Cancel", 0, total_features)
        progress_dialog.setWindowModality(2)  # Make the dialog modal
        progress_dialog.show()



        for f in features_of_layer:
            id = f.id()
            feat = layer.getFeature(id)

            progress_dialog.setValue(id)

            # SUBAREA
            geom = f.geometry()
            area = geom.area() / 10000
            area = round(area, 2)
            attr_value_subarea = {field_area: area}
            layer_provider.changeAttributeValues({id: attr_value_subarea})
            area_list_from_layer.append(feat[field_area_id])
            list_of_subarea.append(area)

        layer.commitChanges()

        # Info
        CustomMessageBox.showWithTimeout(5, "Obliczono powierzchnię poligonów warstwy wektorowej", "", icon=QMessageBox.Information)
        self.appendDataToLabel("Obliczono powierzchnię poligonów warstwy wektorowej", self.dockwidget.label_info)

        for index, area in enumerate(area_list_from_layer):

            area_id = area_list_from_layer[index]
            subarea = list_of_subarea[index]

            print(str(area_id) + ":" + str(subarea))

            update_query = f"UPDATE stanowisko_rok SET powierzchnia = {subarea} WHERE stanowisko_nr = {area_id}"
            cursor.execute(update_query)

            conn.commit()


        CustomMessageBox.showWithTimeout(5, "Zaktualizowano powierzchnię w bazie danych...", "", icon=QMessageBox.Information)
        self.appendDataToLabel("Zaktualizowano powierzchnię w bazie danych...", self.dockwidget.label_info)

        self.dockwidget.pushButton_rewrite_area_to_dbase.setStyleSheet('QPushButton {background-color: #3cb371}')

        cursor.close()
        conn.close()

        progress_dialog.setValue(total_features)
        progress_dialog.close()


    # T_0103
    def add_coordinates_to_dbase(self):

        # Clear info labels
        self.clear_info_labels()

        # Dbase
        d_base = self.get_dBase_directory()
        if not d_base:
            return False
        # Connection settings
        conn = sqlite3.connect(d_base)
        cursor = conn.cursor()

        # Layer
        layer = self.getLayer()
        if not layer:
            return False
        field_name = self.dockwidget.comboBoxFieldsName.currentText()
        field_area_id = layer.fields().indexFromName(field_name)
        list_of_centroid_values = []

        # Check if the layer is valid
        if not layer.isValid():
            print("Layer failed to load!")

        # Set layer scr to 2180
        crs = layer.crs()
        crs.createFromId(2180)
        layer.setCrs(QgsCoordinateReferenceSystem(crs))

        # Transform CRS from 2180 to 4326
        transform = QgsCoordinateTransform(QgsCoordinateReferenceSystem("EPSG:2180"), QgsCoordinateReferenceSystem("EPSG:4326"), QgsProject.instance())

        # Get the centroid coordinates of each feature
        for feature in layer.getFeatures():
            geometry = feature.geometry()
            if layer.type() == QgsMapLayer.VectorLayer and (layer.wkbType() == QgsWkbTypes.Polygon or layer.wkbType() == QgsWkbTypes.MultiPolygon):

                id = feature.id()
                feat = layer.getFeature(id)
                area_id = feat[field_area_id]

                # Calculate centroid
                centroid = geometry.centroid().asPoint()
                # Transform the coordinates to WGS 84
                centroid_wgs84 = transform.transform(centroid)

                # Update the records
                update_query = """UPDATE stanowisko_rok SET x = ?, y = ? 
                WHERE stanowisko_nr = ? AND coalesce(cast(x as int), 0)=0 or coalesce(cast(y as int), 0)=0"""

                # Execute the update query
                cursor.execute(update_query, (centroid_wgs84.y(), centroid_wgs84.x(), area_id))

                # Execute the update query
                # cursor.execute(update_query)

                # Commit the changes
                conn.commit()

                print(
                    f"Feature {feature.id()}: Centroid Coordinates (WGS 84) - Latitude: {centroid_wgs84.y()}, Longitude: {centroid_wgs84.x()}")
            else:
                continue

        conn.close()
        CustomMessageBox.showWithTimeout(5, "Zaktualizowano brakujce współrzędne w bazie danych.", "", icon=QMessageBox.Information)
        self.appendDataToLabel("Zaktualizowano brakujce współrzędne w bazie danych.", self.dockwidget.label_info)
        self.dockwidget.pushButton_add_coordinates_to_d_base.setStyleSheet('QPushButton {background-color: #3cb371}')

    # T_0104
    def corect_compatibility(self):

        # Clear info labels
        self.clear_info_labels()

        # Dbase
        d_base = self.get_dBase_directory()
        if not d_base:
            return False
        # Connection settings
        conn = sqlite3.connect(d_base)
        cursor = conn.cursor()

        try:

            # Update 01
            update_query = "update stanowisko set zgodnosc_cd=1 where siedlisko_cd in (select siedlisko_cd from sl_siedlisko where projekt_fl) and coalesce(zgodnosc_cd,0) in (0,'') and siedlisko_plan_cd=siedlisko_cd;"
            cursor.execute(update_query)
            conn.commit()

            # Update 08
            update_query = "update stanowisko set zgodnosc_cd=8 where siedlisko_cd in (select siedlisko_cd from sl_siedlisko where projekt_fl) and coalesce(zgodnosc_cd,0) in (0,'') and siedlisko_lp_cd=siedlisko_cd and siedlisko_plan_cd in (select siedlisko_cd from sl_siedlisko where not projekt_fl);"
            cursor.execute(update_query)
            conn.commit()

            # Update 09
            update_query = "update stanowisko set zgodnosc_cd=9 where coalesce(zgodnosc_cd,0) in (0,'') and siedlisko_plan_cd in (select siedlisko_cd from sl_siedlisko where not projekt_fl) and siedlisko_lp_cd in (select siedlisko_cd from sl_siedlisko where projekt_fl) and siedlisko_cd='brak'"
            cursor.execute(update_query)
            conn.commit()

        except Exception as e:
            CustomMessageBox.showWithTimeout(5, "Proces zakończył się niepowodzeniem!", "", icon=QMessageBox.Warning)
            self.appendDataToLabel("Proces zakończył się niepowodzeniem!", self.dockwidget.label_warning)
            self.dockwidget.pushButton_correct_compatibility.setStyleSheet('QPushButton {background-color: #ff0000}')
            conn.rollback()
            return False
        finally:
            cursor.close()
            conn.close()

        CustomMessageBox.showWithTimeout(5, "Proces zakończył się powodzeniem!", "", icon=QMessageBox.Information)
        self.appendDataToLabel("Proces zakończył się powodzeniem!", self.dockwidget.label_info)
        self.dockwidget.pushButton_correct_compatibility.setStyleSheet('QPushButton {background-color: #3cb371}')

    # T_0105
    def asign_n2000_to_dbase(self):



        self.removeMapLayerByName('N2000_PL')

        # Input data - user layer
        layer = self.getLayer()
        crs = layer.crs()
        crs.createFromId(2180)
        layer.setCrs(QgsCoordinateReferenceSystem(crs))
        if not layer.isValid():
            print(f"Layer '{layer}' is not valid.")
            CustomMessageBox.showWithTimeout(10, "Warstwa jest niepoprawna...", "", icon=QMessageBox.Information)
            return False
        field_name = self.dockwidget.comboBoxFieldsName.currentText()
        AtributeTableManager.removeColumnToLayerByLayerInstance(self, layer, "kod_n2000")
        # 01 REPAIR GEOMETRY
        result = processing.run("native:fixgeometries", {'INPUT': layer, 'OUTPUT': 'memory:'})
        repair_geom_user_layer = result['OUTPUT']


        # Input data N2000 layer
        dirnameOfCatalog = self.resolveDir('soo_layer')
        geopackage_path =  dirnameOfCatalog + "/N2000_PL.gpkg"
        natura2000_layer = self.iface.addVectorLayer(geopackage_path, "N2000_PL", "ogr")
        if not natura2000_layer:
            print("Layer failed to load!")
            return False


        # Create common part of layers
        result = processing.run("native:intersection", {
            'INPUT': repair_geom_user_layer,
            'OVERLAY': natura2000_layer,
            'INPUT_FIELDS': [], 'OVERLAY_FIELDS': [], 'OVERLAY_FIELDS_PREFIX': '', 'OUTPUT': 'memory:',
            'GRID_SIZE': None})
        common_part_layer = result['OUTPUT']
        common_part_layer.setName('w_N2000')


        # Create external part
        result = processing.run("native:difference", {
            'INPUT': repair_geom_user_layer,
            'OVERLAY': natura2000_layer,
            'OUTPUT': 'memory:',
            'GRID_SIZE': None})
        difference_layer = result['OUTPUT']
        difference_layer.setName('poza_N2000')

        # 03 MERGE
        result = processing.run("native:mergevectorlayers", {'LAYERS': [common_part_layer, difference_layer], 'CRS': None, 'OUTPUT': 'memory:'})
        merge_layer = result['OUTPUT']
        merge_layer.setName('w_poza_N2000')
        # QgsProject.instance().addMapLayer(merge_layer)


        # 04 AGREGATE
        # result = processing.run("native:dissolve", {
        #     'INPUT': merge_layer,
        #     'FIELD': [field_name, 'kod_n2000'], 'SEPARATE_DISJOINT': False, 'OUTPUT': 'memory:'})
        # dissolve_layer = result['OUTPUT']
        # dissolve_layer.setName('bledy_zasiegu')


        # Disolve by ID_STAN and N2000 layer
        # result = processing.run("native:dissolve", {
        #     'INPUT': common_part_layer,
        #     'FIELD': [field_name, 'kod_n2000'], 'SEPARATE_DISJOINT': False, 'OUTPUT': 'memory:'})
        # dissolve_layer = result['OUTPUT']
        # dissolve_layer.setName('stanowisko_n2000')

        result = processing.run("native:dissolve", {
            'INPUT': merge_layer,
            'FIELD': [field_name, 'kod_n2000'], 'SEPARATE_DISJOINT': False, 'OUTPUT': 'memory:'})
        dissolve_layer = result['OUTPUT']
        dissolve_layer.setName('stanowisko_n2000')



        # Duplicates controll with information
        # Get the index of the column
        column_index = dissolve_layer.fields().indexFromName(field_name)

        # Create a dictionary to store the count of each attribute value
        attribute_count = {}

        # Iterate through features in the layer
        for feature in dissolve_layer.getFeatures():
            # Get the attribute value for the specified column
            attribute_value = feature[column_index]

            # Update the count in the dictionary
            if attribute_value in attribute_count:
                attribute_count[attribute_value] += 1
            else:
                attribute_count[attribute_value] = 1

        # Identify duplicate attribute values
        duplicate_values = [value for value, count in attribute_count.items() if count > 1]

        if len(duplicate_values) > 0:
            CustomMessageBox.showInfoCustomMessageBox(
                "W warstwie znajdują się płaty występujące jednocześnie w kilku obszarach Natura 2000!"
                "\n\n"
                "Wykonaj kontrolę C_0104 i popraw zasięg płatów!"
                "\n\nDo stanowiska znajdującego się w obrębie kilku obszarów N2000 zostanie przypisany obszar N2000 o największej powierzchni."
                "\n\nLista powierzchni występujących w kilku płatach znajduje się w raporcie kontroli.",
                "Przypisanie obszarów N2000 do bazy.",
                icon=QMessageBox.Information)
            self.generate_csv_reports('Stanowiska występujące jednocześnie w kilku obszarach N2000:', ["ID_STANOWISKA"],duplicate_values, "monitoring_gis_tools_raporty_kontroli", "T_0105_stanowiska_w_kilku_ob_N2000.csv")



        # Calculate area
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, dissolve_layer, "AREA_HA", QVariant.Double)
        layer_provider = dissolve_layer.dataProvider()
        # layer_fields = dissolve_layer.fields()
        column_area = dissolve_layer.fields().indexFromName("AREA_HA")
        column_n2000 = dissolve_layer.fields().indexFromName("kod_n2000")
        features_of_layer = dissolve_layer.getFeatures()


        for f in features_of_layer:
            id = f.id()
            # SUBAREA
            geom = f.geometry()
            area = geom.area() / 10000
            area = round(area, 2)
            attr_value_subarea = {column_area: area}
            layer_provider.changeAttributeValues({id: attr_value_subarea})

        dissolve_layer.commitChanges()

        # Remove smaller part
        max_area_dict = {}


        # Iterate over features and update the max 'AREA' for each 'ID'
        for feature in dissolve_layer.getFeatures():
            id_value = feature.attributes()[column_index]
            area_value = feature.attributes()[column_area]

            if id_value not in max_area_dict or area_value > max_area_dict[id_value]:
                max_area_dict[id_value] = area_value

        # Create a list of feature IDs to keep
        features_to_keep = []
        for feature in dissolve_layer.getFeatures():
            id_value = feature.attributes()[column_index]
            area_value = feature.attributes()[column_area]

            if area_value == max_area_dict[id_value]:
                features_to_keep.append(feature.id())

        # Set the selected features in the original layer
        dissolve_layer.selectByIds(features_to_keep)
        # Reverse the current selection
        dissolve_layer.invertSelection()

        # Delete the selected features
        dissolve_layer.startEditing()
        dissolve_layer.deleteSelectedFeatures()
        dissolve_layer.commitChanges()

        # Remove data from dBase
        try:
            # Dbase
            d_base = self.get_dBase_directory()
            if not d_base:
                CustomMessageBox.showWithTimeout(5, "Brak dostępu do bazy danych bazie danych.", "", icon=QMessageBox.Information)
                self.dockwidget.pushButton_asign_n2000_to_dbase.setStyleSheet('QPushButton {background-color: #ff0000}')
                return False

            conn = sqlite3.connect(d_base)
            cursor = conn.cursor()

            sql_query = """DELETE FROM stanowisko_rok_forma_op
                           WHERE forma_ochrony_przyrody_cd LIKE 'n2kh%'
                              OR forma_ochrony_przyrody_cd LIKE 'n2kc%'
                              OR forma_ochrony_przyrody_cd LIKE 'PLH%'
                              OR forma_ochrony_przyrody_cd LIKE 'PLC%'
                              OR forma_ochrony_przyrody_cd LIKE 'None%'
                              OR forma_ochrony_przyrody_cd IS NULL
                              OR forma_ochrony_przyrody_cd = "";"""
            cursor.execute(sql_query)
            deleted_rows = cursor.rowcount
            conn.commit()
            CustomMessageBox.showWithTimeout(5, f"Usunięto {deleted_rows} przypisań do obszarów siedliskoskowych (PLH, PLC) z bazy danych.", "",icon=QMessageBox.Information)

        except sqlite3.Error as e:
            print(f"Error removing data from database: {e}")
            conn.rollback()
            self.dockwidget.pushButton_asign_n2000_to_dbase.setStyleSheet('QPushButton {background-color: #ff0000}')
            return False
        finally:
            conn.close()

        try:
            # Dbase
            d_base = self.get_dBase_directory()
            if not d_base:
                CustomMessageBox.showWithTimeout(5, "Brak dostępu do bazy danych bazie danych.", "", icon=QMessageBox.Information)
                return False

            conn = sqlite3.connect(d_base)
            cursor = conn.cursor()

            total_inserted_rows = 0

            for feature in dissolve_layer.getFeatures():
                id = feature.id()
                feat = dissolve_layer.getFeature(id)
                area_id = feat[column_index]
                n2000 = feat[column_n2000]

                stanowisko_value = area_id
                rok_value = self.selected_year

                forma_ochrony_przyrody_cd_value = n2000


                if n2000 is not None and n2000.startswith("PLH"):
                    forma_ochrony_przyrody_cd_value = 'n2kh_' +  n2000
                elif n2000 is not None and n2000.startswith("PLC"):
                    forma_ochrony_przyrody_cd_value = 'n2kc_' +  n2000

                # Define the SQL query to insert a new row
                if n2000 is not None:
                    sql_query = f"""INSERT INTO stanowisko_rok_forma_op (stanowisko_nr, rok, forma_ochrony_przyrody_cd) VALUES ('{stanowisko_value}', {rok_value}, '{forma_ochrony_przyrody_cd_value}');"""
                    cursor.execute(sql_query)
                    total_inserted_rows += cursor.rowcount

            conn.commit()

        except sqlite3.Error as e:
            print(f"Error adding data to database: {e}")
            conn.rollback()
            self.dockwidget.pushButton_asign_n2000_to_dbase.setStyleSheet('QPushButton {background-color: #ff0000}')
            return False

        finally:
            conn.close()
            CustomMessageBox.showWithTimeout(5, f"Dodano {total_inserted_rows} przypisań do obszarów siedliskoskowych (PLH, PLC) z warstwy do bazy danych.", "",icon=QMessageBox.Information)

        # Join layers and rewrite data between columns
        CustomMessageBox.showWithTimeout(5, "Przepisywanie kodu obszaru do warstwy siedlisk (kolumna 'kod_n2000')...", "",icon=QMessageBox.Information)
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, layer, "kod_n2000", QVariant.String)
        AtributeTableManager.rewriteDataBetweenLayers(self, dissolve_layer, layer,  "kod_n2000", field_name, field_name)


        CustomMessageBox.showWithTimeout(5, "Zaktualizowano kody obszarów N2000 w bazie danych.", "", icon=QMessageBox.Information)
        self.dockwidget.pushButton_asign_n2000_to_dbase.setStyleSheet('QPushButton {background-color: #3cb371}')

        # Add layers to project
        # QgsProject.instance().addMapLayer(common_part_layer)
        # QgsProject.instance().addMapLayer(dissolve_layer)


    # T0106
    def repair_geometry_cet_crs(self):

        layer = self.getLayer()
        crs = layer.crs()
        crs.createFromId(2180)
        layer.setCrs(QgsCoordinateReferenceSystem(crs))

        result = processing.run("native:fixgeometries", {'INPUT': layer, 'OUTPUT': 'memory:'})
        repair_geom_user_layer = result['OUTPUT']

        if repair_geom_user_layer:

            layer.startEditing()

            layer.deleteFeatures([f.id() for f in layer.getFeatures()])

            for feature in repair_geom_user_layer.getFeatures():
                layer.addFeature(feature)

            layer.commitChanges()

            print("Geometry repaired in the source layer successfully")

            layer.reload()
        else:
            print("Error fixing geometries")

    # T_0107
    def round_geometry(self):


        layer = self.getLayer()
        crs = layer.crs()
        crs.createFromId(2180)
        layer.setCrs(QgsCoordinateReferenceSystem(crs))
        layer_path = layer.source()

        # Load the layer into a GeoDataFrame
        gdf = gpd.read_file(layer_path)

        # Function to round coordinates of a geometry
        def round_coordinates(geometry, precision=2):
            if geometry.geom_type == 'Point':
                return Point(round(geometry.x, precision), round(geometry.y, precision))
            elif geometry.geom_type == 'LineString' or geometry.geom_type == 'LinearRing':
                return geometry.__class__(
                    [Point(round(coord[0], precision), round(coord[1], precision)) for coord in geometry.coords])
            elif geometry.geom_type == 'Polygon':
                exterior = round_coordinates(geometry.exterior, precision)
                interiors = [round_coordinates(interior, precision) for interior in geometry.interiors]
                return Polygon(exterior, interiors)
            elif geometry.geom_type == 'MultiPoint':
                return MultiPoint([round_coordinates(point, precision) for point in geometry])
            elif geometry.geom_type == 'MultiLineString':
                return MultiLineString([round_coordinates(line, precision) for line in geometry])
            elif geometry.geom_type == 'MultiPolygon':
                return MultiPolygon([round_coordinates(polygon, precision) for polygon in geometry.geoms])
            else:
                raise ValueError(f"Unsupported geometry type: {geometry.geom_type}")

        # Round coordinates of each geometry in the GeoDataFrame
        gdf['geometry'] = gdf['geometry'].apply(round_coordinates)

        # Write the modified GeoDataFrame back to the same shapefile
        gdf.to_file(layer_path, driver='ESRI Shapefile')
        layer.reload()

        # Refresh the QGIS layer to reflect the changes
        layer.triggerRepaint()

    def snap_vertices_to_rezerwaty(self):
        self.appendDataToPlainTextEdit("Starting snapping process...", self.dockwidget.plainTextEdit_info)

        self.removeMapLayerByName('N2000_PL')
        self.removeMapLayerByName('rezerwaty_PL')

        # Input data - user layer
        layer_to_snap = self.getLayer()
        self.appendDataToPlainTextEdit("Got layer to snap: " + layer_to_snap.name(), self.dockwidget.plainTextEdit_info)

        crs = layer_to_snap.crs()
        crs.createFromId(2180)
        layer_to_snap.setCrs(QgsCoordinateReferenceSystem(crs))

        # Get snapping tolerance from the GUI input
        try:
            snap_tolerance = float(self.dockwidget.lineEdit_snap_tolerance.text().replace(",", "."))
        except ValueError:
            self.appendDataToPlainTextEdit("Invalid snapping tolerance value.", self.dockwidget.plainTextEdit_info)
            return

        self.appendDataToPlainTextEdit("Snapping tolerance: " + str(snap_tolerance), self.dockwidget.plainTextEdit_info)

        # Input data rezerwaty layer
        dirnameOfCatalog = self.resolveDir('rez_layer')
        geopackage_path = dirnameOfCatalog + "/rezerwaty_PL.gpkg"
        reserve_layer = self.iface.addVectorLayer(geopackage_path, "rezerwaty_PL", "ogr")
        reserve_layer.setCrs(QgsCoordinateReferenceSystem(crs))
        if not reserve_layer:
            self.appendDataToPlainTextEdit("Layer failed to load: " + geopackage_path, self.dockwidget.plainTextEdit_info)
            return False
        self.appendDataToPlainTextEdit("Loaded rezerwaty layer", self.dockwidget.plainTextEdit_info)

        # Input data N2000 layer
        dirnameOfCatalog = self.resolveDir('soo_layer')
        geopackage_path = dirnameOfCatalog + "/N2000_PL.gpkg"
        natura2000_layer = self.iface.addVectorLayer(geopackage_path, "N2000_PL", "ogr")
        if not natura2000_layer:
            self.appendDataToPlainTextEdit("Layer failed to load: " + geopackage_path, self.dockwidget.plainTextEdit_info)
            return False
        self.appendDataToPlainTextEdit("Loaded N2000 layer", self.dockwidget.plainTextEdit_info)

        if not reserve_layer.isValid() or not natura2000_layer.isValid():
            self.appendDataToPlainTextEdit("One of the layers is not valid.", self.dockwidget.plainTextEdit_info)
            return

        self.appendDataToPlainTextEdit("Snapping layers are valid", self.dockwidget.plainTextEdit_info)

        # Define snapping options
        snapping_config = QgsSnappingConfig()
        snapping_config.setEnabled(True)
        snapping_config.setTolerance(snap_tolerance)  # Set the snapping tolerance
        snapping_config.setType(QgsSnappingConfig.VertexAndSegment)
        snapping_config.setMode(QgsSnappingConfig.AdvancedConfiguration)

        # Set snapping environment to the "rezerwaty_PL" and "N2000_PL.gpkg" layers with priorities
        reserve_layer_settings = QgsSnappingConfig.IndividualLayerSettings(True, QgsSnappingConfig.VertexAndSegment,
                                                                           snap_tolerance,
                                                                           QgsTolerance.ProjectUnits)
        natura2000_layer_settings = QgsSnappingConfig.IndividualLayerSettings(True,
                                                                              QgsSnappingConfig.VertexAndSegment,
                                                                              snap_tolerance,
                                                                              QgsTolerance.ProjectUnits)

        snapping_config.setIndividualLayerSettings(reserve_layer, reserve_layer_settings)
        snapping_config.setIndividualLayerSettings(natura2000_layer, natura2000_layer_settings)

        # Enable snapping
        snapping_utils = self.iface.mapCanvas().snappingUtils()
        snapping_utils.setConfig(snapping_config)
        self.appendDataToPlainTextEdit("Snapping enabled", self.dockwidget.plainTextEdit_info)

        # Initialize progress dialog
        num_features = layer_to_snap.featureCount()
        progress_dialog = QProgressDialog("Snapping vertices...", "Cancel", 0, num_features)
        progress_dialog.setWindowTitle("Processing")
        progress_dialog.setWindowModality(Qt.WindowModal)
        progress_dialog.show()

        # Iterate through the features of the layer to snap
        for i, feature in enumerate(layer_to_snap.getFeatures()):
            if progress_dialog.wasCanceled():
                self.appendDataToPlainTextEdit("Process canceled by user.", self.dockwidget.plainTextEdit_info)
                break

            self.appendDataToPlainTextEdit("Processing feature: " + str(feature.id()), self.dockwidget.plainTextEdit_info)
            geom = feature.geometry()
            if geom:
                new_vertices = []
                for vertex in geom.vertices():
                    point_xy = QgsPointXY(vertex)
                    snapped_match = None

                    # Attempt to snap to the "rezerwaty" layer first
                    snapped_match = snapping_utils.snapToMap(point_xy)
                    if not snapped_match.isValid():
                        # If snapping to "rezerwaty" is not successful, attempt to snap to an edge
                        snapped_match = snapping_utils.snapToMap(point_xy)
                    if not snapped_match.isValid():
                        # If snapping to an edge in "rezerwaty" is not successful, attempt to snap to a vertex in "N2000_PL"
                        snapped_match = snapping_utils.snapToMap(point_xy)
                    if not snapped_match.isValid():
                        # If snapping to a vertex in "N2000_PL" is not successful, attempt to snap to an edge
                        snapped_match = snapping_utils.snapToMap(point_xy)

                    if snapped_match.isValid():
                        new_vertex = snapped_match.point()
                    else:
                        new_vertex = vertex
                    new_vertices.append(QgsPointXY(new_vertex))  # Ensure QgsPointXY objects

                # Update the geometry with snapped vertices
                new_geom = QgsGeometry.fromPolygonXY([new_vertices])
                layer_to_snap.dataProvider().changeGeometryValues({feature.id(): new_geom})

            # Update progress dialog
            progress_dialog.setValue(i + 1)

        # Close progress dialog
        progress_dialog.close()

        # Disable snapping after snapping is complete
        snapping_utils.setConfig(QgsSnappingConfig())

        # Refresh the map canvas to make the changes visible
        self.iface.mapCanvas().refreshAllLayers()

    # T_0108

    def prepare_structure(self):
        layer = self.getLayer()
        field_name = self.dockwidget.comboBoxFieldsName.currentText()
        field_area_id = layer.fields().indexFromName(field_name)


        column_index = layer.fields().indexFromName(field_name)



        # Add new columns
        self.add_new_columns(layer)

        # Dbase address
        d_base = str(self.dockwidget.lineEdit_dBase_directory.text()).replace('\\', '/')
        if not d_base:
            self.dockwidget.label_warning.setText("Nie wskazano bazy danych!")
            return False

        # Declare connections
        conn = sqlite3.connect(d_base)
        cursor = conn.cursor()

        cursor.execute(
            """
            SELECT s.stanowisko_nr, s.siedlisko_cd, s.siedlisko_plan_cd, s.siedlisko_lp_cd, 
                   s.zgodnosc_cd, sz.zgodnosc_nm, sr.rok, sr.rezygnacja_fl, sr.uzasadnienie_rezygnacji, 
                   sr.wartosci_przyrodnicze, sr.opis_siedliska, sr.zarzadzajacy_terenem, sr.data_oceny, 
                   MAX(CASE WHEN srp.parametr_cd = 'PS' OR srp.ocena_cd = '' THEN srp.ocena_cd ELSE NULL END) AS PS, 
                   MAX(CASE WHEN srp.parametr_cd = 'SF' OR srp.ocena_cd = '' THEN srp.ocena_cd ELSE NULL END) AS SF, 
                   MAX(CASE WHEN srp.parametr_cd = 'PO' OR srp.ocena_cd = '' THEN srp.ocena_cd ELSE NULL END) AS PO, 
                   sr.ocena_cd, sr.komentarz_ocena_stanu_ochrony 
            FROM stanowisko s 
            LEFT JOIN stanowisko_rok sr ON sr.stanowisko_nr = s.stanowisko_nr 
            LEFT JOIN stanowisko_rok_parametr srp ON sr.stanowisko_nr = srp.stanowisko_nr AND sr.rok = srp.rok 
            LEFT JOIN sl_zgodnosc sz ON s.zgodnosc_cd = sz.zgodnosc_cd 
            GROUP BY sr.stanowisko_nr;
            """
        )
        rows = cursor.fetchall()

        data_list = []

        for row in rows:
            data_list.append((row[0], row[1], row[2], row[3], row[4], row[5], row[6], row[7], row[8], row[9], row[10],
                              row[11], row[12], row[13], row[14], row[15], row[16], row[17]))

        total_features = layer.featureCount()

        # Create a progress dialog
        progress_dialog = QProgressDialog("Processing...", "Cancel", 0, total_features)
        progress_dialog.setWindowModality(2)  # Make the dialog modal
        progress_dialog.show()

        layer.startEditing()
        layer_provider = layer.dataProvider()
        fields = layer.fields()

        for f in layer.getFeatures():
            id = f.id()
            feat = layer.getFeature(id)

            # Extract the value, handling QVariant
            attribute_value = feat.attribute(column_index)
            if isinstance(attribute_value, QVariant):
                attribute_value = attribute_value.value()

            progress_dialog.setValue(id)

            # Find corresponding data in data_list
            for data in data_list:
                if data[0] == attribute_value:
                    try:
                        changes = {}

                        if data[1] is not None:
                            changes[fields.indexFromName("SIEDL")] = data[1]
                        if data[2] is not None:
                            changes[fields.indexFromName("SIEDL_PLAN")] = data[2]
                        if data[3] is not None:
                            changes[fields.indexFromName("SIEDL_LP")] = data[3]
                        if data[4] is not None:
                            changes[fields.indexFromName("ZGODN_KOD")] = data[4]
                        if data[5] is not None:
                            changes[fields.indexFromName("ZGODN_OPIS")] = data[5]
                        if data[6] is not None:
                            changes[fields.indexFromName("ROK")] = data[6]
                        if data[7] is not None:
                            if isinstance(data[7], int):
                                changes[fields.indexFromName("REZYGNACJA")] = data[7]
                            else:
                                print(f"Invalid data type for REZYGNACJA: {data[7]}")
                        if data[8] is not None:
                            changes[fields.indexFromName("UZ_REZYGN")] = data[8]
                        if data[9] is not None:
                            changes[fields.indexFromName("WART_PRZYR")] = data[9]
                        if data[10] is not None:
                            changes[fields.indexFromName("OPIS_SIEDL")] = data[10]
                        if data[11] is not None:
                            changes[fields.indexFromName("ZARZ_TEREN")] = data[11]
                        if data[12] is not None:
                            changes[fields.indexFromName("DATA_OCENY")] = data[12]
                        if data[13] is not None:
                            changes[fields.indexFromName("PARAM_PS")] = data[13]
                        if data[14] is not None:
                            changes[fields.indexFromName("PARAM_SSF")] = data[14]
                        if data[15] is not None:
                            changes[fields.indexFromName("PARAM_PO")] = data[15]
                        if data[16] is not None:
                            changes[fields.indexFromName("OCENA")] = data[16]
                        if data[17] is not None:
                            changes[fields.indexFromName("OCENA_OPIS")] = data[17]

                        if changes:
                            layer_provider.changeAttributeValues({id: changes})
                            print(f"Updated feature {id} with changes: {changes}")

                    except Exception as e:
                        print(f"Error updating feature {id}: {e}")

        columns_to_leave = [field_name, "AREA_HA", "kod_n2000", "rez_przyr", "SDLN2K_T", "WYK", "SIEDL", "SIEDL_PLAN",
                            "SIEDL_LP", "ZGODN_KOD", "ZGODN_OPIS", "ROK", "REZYGNACJA", "UZ_REZYGN", "WART_PRZYR",
                            "OPIS_SIEDL", "ZARZ_TEREN", "DATA_OCENY", "PARAM_PS", "PARAM_SSF", "PARAM_PO", "OCENA",
                            "OCENA_OPIS"]
        # Remove columns except declared ones (not shown in the provided snippet)
        AtributeTableManager.removeEachColumnExeptDeclaredByLayerInstance(self, layer, columns_to_leave)

        layer.commitChanges()
        progress_dialog.close()

        conn.commit()
        conn.close()

        return True

    def add_new_columns(self, layer):
        """ Helper method to add new columns to the layer """
        attributes = [
            ("SIEDL", QVariant.String),
            ("SIEDL_PLAN", QVariant.String),
            ("SIEDL_LP", QVariant.String),
            ("ZGODN_KOD", QVariant.Int),
            ("ZGODN_OPIS", QVariant.String),
            ("ROK", QVariant.Int),
            ("REZYGNACJA", QVariant.Int),
            ("UZ_REZYGN", QVariant.String),
            ("WART_PRZYR", QVariant.String),
            ("OPIS_SIEDL", QVariant.String),
            ("ZARZ_TEREN", QVariant.String),
            ("DATA_OCENY", QVariant.String),
            ("PARAM_PS", QVariant.String),
            ("PARAM_SSF", QVariant.String),
            ("PARAM_PO", QVariant.String),
            ("OCENA", QVariant.String),
            ("OCENA_OPIS", QVariant.String),
        ]

        layer.startEditing()
        for name, data_type in attributes:
            if layer.fields().indexFromName(name) == -1:
                layer.addAttribute(QgsField(name, data_type))

        layer.updateFields()
        layer.commitChanges()

    # T_0109
    def asign_nature_reserve_to_dbase(self):


        self.removeMapLayerByName('rezerwaty_PL')

        # Input data - user layer
        layer = self.getLayer()
        crs = layer.crs()
        crs.createFromId(2180)
        layer.setCrs(QgsCoordinateReferenceSystem(crs))

        field_name = self.dockwidget.comboBoxFieldsName.currentText()


        column_index = layer.fields().indexFromName(field_name)

        if not layer.isValid():
            print(f"Layer '{layer}' is not valid.")
            CustomMessageBox.showWithTimeout(10, "Warstwa jest niepoprawna...", "", icon=QMessageBox.Information)
            return False

        field_name = self.dockwidget.comboBoxFieldsName.currentText()
        AtributeTableManager.removeColumnToLayerByLayerInstance(self, layer, "rez_przyr")

        # 01 REPAIR GEOMETRY
        result = processing.run("native:fixgeometries", {'INPUT': layer, 'OUTPUT': 'memory:'})
        repair_geom_user_layer = result['OUTPUT']


        # Input data N2000 layer
        dirnameOfCatalog = self.resolveDir('rez_layer')
        geopackage_path =  dirnameOfCatalog + "/rezerwaty_PL.gpkg"
        nature_reserve_layer = self.iface.addVectorLayer(geopackage_path, "rezerwaty_PL", "ogr")
        nature_reserve_layer.setCrs(QgsCoordinateReferenceSystem(crs))

        if not nature_reserve_layer:
            print("Layer failed to load!")
            return False


        # Create common part of layers
        result = processing.run("native:intersection", {
            'INPUT': repair_geom_user_layer,
            'OVERLAY': nature_reserve_layer,
            'INPUT_FIELDS': [], 'OVERLAY_FIELDS': [], 'OVERLAY_FIELDS_PREFIX': '', 'OUTPUT': 'memory:',
            'GRID_SIZE': None})
        common_part_layer = result['OUTPUT']
        common_part_layer.setName('w_rezerwacie')


        # Create external part
        result = processing.run("native:difference", {
            'INPUT': repair_geom_user_layer,
            'OVERLAY': nature_reserve_layer,
            'OUTPUT': 'memory:',
            'GRID_SIZE': None})
        difference_layer = result['OUTPUT']
        difference_layer.setName('poza_rezerwatem')

        # 03 MERGE
        result = processing.run("native:mergevectorlayers", {'LAYERS': [common_part_layer, difference_layer], 'CRS': None, 'OUTPUT': 'memory:'})
        merge_layer = result['OUTPUT']
        merge_layer.setName('w_poza_rezerwatem')
        # QgsProject.instance().addMapLayer(merge_layer)


        result = processing.run("native:dissolve", {
            'INPUT': merge_layer,
            'FIELD': [field_name, 'rez_przyr'], 'SEPARATE_DISJOINT': False, 'OUTPUT': 'memory:'})
        dissolve_layer = result['OUTPUT']
        dissolve_layer.setName('stanowisko_rez_przyr')
        columnns_to_leave = [  field_name, "rez_przyr", "kodinspire"]
        AtributeTableManager.removeEachColumnExeptDeclaredByLayerInstance(self, dissolve_layer, columnns_to_leave)
        # QgsProject.instance().addMapLayer(dissolve_layer)


        # Duplicates controll with information
        # Get the index of the column
        column_index = dissolve_layer.fields().indexFromName(field_name)


        # Create a dictionary to store the count of each attribute value
        attribute_count = {}

        # Iterate through features in the layer
        for feature in dissolve_layer.getFeatures():
            # Get the attribute value for the specified column
            attribute_value = feature[column_index]

            # Update the count in the dictionary
            if attribute_value in attribute_count:
                attribute_count[attribute_value] += 1
            else:
                attribute_count[attribute_value] = 1

        # Identify duplicate attribute values
        duplicate_values = [value for value, count in attribute_count.items() if count > 1]
        print(duplicate_values)


        if len(duplicate_values) > 0:
            CustomMessageBox.showInfoCustomMessageBox(
                "W warstwie znajdują się płaty występujące jednocześnie w kilku rezerwatach przyrody, lub przecinają się w kilu miejscach z jednym rezerwatem przyrody!"
                "\n\n"
                "Wykonaj kontrolę C_0104 i popraw zasięg płatów!"
                "\n\nDo stanowiska znajdującego się w obrębie kilku rezerwatów zostanie przypisany rezerwat o największej powierzchni."
                "\n\nLista powierzchni występujących w kilku płatach znajduje się w raporcie kontroli.",
                "Przypisanie rezerwatów do bazy.",
                icon=QMessageBox.Information)
            self.generate_csv_reports('Stanowiska występujące jednocześnie w kilku rezerwatach przyrody:', ["ID_STANOWISKA"],duplicate_values, "monitoring_gis_tools_raporty_kontroli", "T_0109_stanowiska_w_rezerwatach_przyrody.csv")



        # Calculate area
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, dissolve_layer, "AREA_HA", QVariant.Double)
        layer_provider = dissolve_layer.dataProvider()
        # layer_fields = dissolve_layer.fields()
        column_area = dissolve_layer.fields().indexFromName("AREA_HA")
        column_nature_reserve = dissolve_layer.fields().indexFromName("rez_przyr")
        column_kod_inspire = dissolve_layer.fields().indexFromName("kodinspire")
        features_of_layer = dissolve_layer.getFeatures()


        for f in features_of_layer:
            id = f.id()
            # SUBAREA
            geom = f.geometry()
            area = geom.area() / 10000
            area = round(area, 2)
            attr_value_subarea = {column_area: area}
            layer_provider.changeAttributeValues({id: attr_value_subarea})

        dissolve_layer.commitChanges()

        # Remove smaller part
        max_area_dict = {}


        # Iterate over features and update the max 'AREA' for each 'ID'
        for feature in dissolve_layer.getFeatures():
            id_value = feature.attributes()[column_index]
            area_value = feature.attributes()[column_area]

            if id_value not in max_area_dict or area_value > max_area_dict[id_value]:
                max_area_dict[id_value] = area_value

        # Create a list of feature IDs to keep
        features_to_keep = []
        for feature in dissolve_layer.getFeatures():
            id_value = feature.attributes()[column_index]
            area_value = feature.attributes()[column_area]

            if area_value == max_area_dict[id_value]:
                features_to_keep.append(feature.id())

        # Set the selected features in the original layer
        dissolve_layer.selectByIds(features_to_keep)
        # Reverse the current selection
        dissolve_layer.invertSelection()

        # Delete the selected features
        dissolve_layer.startEditing()
        dissolve_layer.deleteSelectedFeatures()
        dissolve_layer.commitChanges()

        # Remove data from dBase
        try:
            # Dbase
            d_base = self.get_dBase_directory()
            if not d_base:
                CustomMessageBox.showWithTimeout(5, "Brak dostępu do bazy danych bazie danych.", "", icon=QMessageBox.Information)
                self.dockwidget.pushButton_asign_n2000_to_dbase.setStyleSheet('QPushButton {background-color: #ff0000}')
                return False

            conn = sqlite3.connect(d_base)
            cursor = conn.cursor()

            sql_query = """DELETE FROM stanowisko_rok_forma_op
                           WHERE forma_ochrony_przyrody_cd LIKE 'rp%'
                              OR forma_ochrony_przyrody_cd = "";"""
            cursor.execute(sql_query)
            deleted_rows = cursor.rowcount
            conn.commit()
            CustomMessageBox.showWithTimeout(5, f"Usunięto {deleted_rows} przypisań do rezerwatów przyrody z bazy danych.", "",icon=QMessageBox.Information)

        except sqlite3.Error as e:
            print(f"Error removing data from database: {e}")
            conn.rollback()
            self.dockwidget.pushButton_asign_nature_reserve_to_dbase.setStyleSheet('QPushButton {background-color: #ff0000}')
            return False
        finally:
            conn.close()

        try:
            # Dbase
            d_base = self.get_dBase_directory()
            if not d_base:
                CustomMessageBox.showWithTimeout(5, "Brak dostępu do bazy danych bazie danych.", "", icon=QMessageBox.Information)
                return False

            conn = sqlite3.connect(d_base)
            cursor = conn.cursor()

            total_inserted_rows = 0

            for feature in dissolve_layer.getFeatures():
                id = feature.id()
                feat = dissolve_layer.getFeature(id)
                area_id = feat[column_index]
                nature_reserve = feat[column_nature_reserve]
                nature_reserve_nr = feat[column_kod_inspire]
                nature_reserve_nr_last_part = None

                if nature_reserve_nr is not None and isinstance(nature_reserve_nr, str):
                    nature_reserve_nr_last_part = nature_reserve_nr.rsplit('.', 1)[-1]


                stanowisko_value = area_id
                rok_value = self.selected_year

                forma_ochrony_przyrody_cd_value = None


                if nature_reserve_nr is not None:
                    forma_ochrony_przyrody_cd_value = 'rp_' +  nature_reserve_nr_last_part


                # Define the SQL query to insert a new row
                if nature_reserve is not None:
                    sql_query = f"""INSERT INTO stanowisko_rok_forma_op (stanowisko_nr, rok, forma_ochrony_przyrody_cd) VALUES ('{stanowisko_value}', {rok_value}, '{forma_ochrony_przyrody_cd_value}');"""
                    cursor.execute(sql_query)
                    total_inserted_rows += cursor.rowcount

            conn.commit()

        except sqlite3.Error as e:
            print(f"Error adding data to database: {e}")
            conn.rollback()
            self.dockwidget.pushButton_asign_nature_reserve_to_dbase.setStyleSheet('QPushButton {background-color: #ff0000}')
            return False

        finally:
            conn.close()
            CustomMessageBox.showWithTimeout(5, f"Dodano {total_inserted_rows} przypisań do rezerwatów z warstwy do bazy danych.", "",icon=QMessageBox.Information)

        # Join layers and rewrite data between columns
        CustomMessageBox.showWithTimeout(5, "Przepisywanie rezerwatów przyrody do warstwy siedlisk (kolumna 'rez_przyr')...", "",icon=QMessageBox.Information)
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, layer, "rez_przyr", QVariant.String)
        AtributeTableManager.rewriteDataBetweenLayers(self, dissolve_layer, layer,  "rez_przyr", field_name, field_name)


        CustomMessageBox.showWithTimeout(5, "Zaktualizowano przypisanie do rezerwatów w bazie danych.", "", icon=QMessageBox.Information)
        self.dockwidget.pushButton_asign_nature_reserve_to_dbase.setStyleSheet('QPushButton {background-color: #3cb371}')

        # Add layers to project
        # QgsProject.instance().addMapLayer(common_part_layer)
        # QgsProject.instance().addMapLayer(dissolve_layer)

    # C_0101
    def numeration_validating_map(self):

        # Clear info labels
        self.clear_info_labels()

        # Layer
        layer = self.dockwidget.mMapLayerComboBoxAraesPolygon.currentLayer()
        if not (layer):
            self.dockwidget.label_warning.setText("Nie wskazano warstwy!")
            return False

        area_list_from_layer = []
        invalid_numbers_layer = []

        field_name = self.dockwidget.comboBoxFieldsName.currentText()
        field_area_id = layer.fields().indexFromName(field_name)

        for f in layer.getFeatures():
            id = f.id()
            feat = layer.getFeature(id)
            area_list_from_layer.append(feat[field_area_id])


        # Check corectness
        for data_layer in area_list_from_layer:
            if not self.is_numeric_and_length(str(data_layer)):
                invalid_numbers_layer.append(data_layer)
        if len(invalid_numbers_layer) > 0:
            self.appendDataToLabel("", self.dockwidget.label_warning)
            self.appendDataToLabel("Błędnie zanumerowane powierzchnie w warstwie:", self.dockwidget.label_warning)

            for data_layer in invalid_numbers_layer:
                    self.appendDataToLabel(str(data_layer), self.dockwidget.label_warning)

            self.generate_csv_reports("Błędnie zanumerowane powierzchnie w warstwie", ["ID_STANOWISKA"],invalid_numbers_layer, "monitoring_gis_tools_raporty_kontroli", "0101_wykaz_blednie_zan_powierzchni_mapa.csv")
            self.dockwidget.pushButtonNumerationValidatingLayer.setStyleSheet('QPushButton {background-color: #ff0000}')
        else:
            self.appendDataToLabel("Wszystkie powierzchnie w warstwie zanumerowano poprawnie.", self.dockwidget.label_info)
            self.generate_csv_reports("Błędnie zanumerowane powierzchnie w warstwie - brak", ["ID_STANOWISKA"],invalid_numbers_layer, "monitoring_gis_tools_raporty_kontroli", "0101_wykaz_blednie_zan_powierzchni_mapa_OK.csv")
            self.dockwidget.pushButtonNumerationValidatingLayer.setStyleSheet('QPushButton {background-color: #3cb371}')

    # C_0102
    def control_duplicates(self):

        self.clear_info_labels()

        layer = self.getLayer()

        # Check if the layer is valid
        if not layer.isValid():
            print(f"Layer '{layer}' is not valid.")
            CustomMessageBox.showWithTimeout(10, "Warstwa jest niepoprawna...", "", icon=QMessageBox.Information)
            return False

        # Get the index of the column
        column_name = self.dockwidget.comboBoxFieldsName.currentText()
        column_index = layer.fields().indexFromName(column_name)

        # Create a dictionary to store the count of each attribute value
        attribute_count = {}

        # Iterate through features in the layer
        for feature in layer.getFeatures():
            # Get the attribute value for the specified column
            attribute_value = feature[column_index]

            # Update the count in the dictionary
            if attribute_value in attribute_count:
                attribute_count[attribute_value] += 1
            else:
                attribute_count[attribute_value] = 1

        # Identify duplicate attribute values
        duplicate_values = [value for value, count in attribute_count.items() if count > 1]

        if len(duplicate_values) == 0:
            self.appendDataToLabel(f'Brak duplikatów, kolumna: {column_name}', self.dockwidget.label_info)
            CustomMessageBox.showWithTimeout(5, f'Brak duplikatów, kolumna: {column_name}', "", icon=QMessageBox.Information)
            self.generate_csv_reports(f'Brak duplikatów, kolumna: {column_name}', ["ID_STANOWISKA"], duplicate_values, "monitoring_gis_tools_raporty_kontroli", "0102_duplikaty_warstwa_OK.csv")
            self.dockwidget.pushButton_control_duplicates.setStyleSheet('QPushButton {background-color: #3cb371}')
            return False

        CustomMessageBox.showWithTimeout(5, f'Warstwa zawiera duplikaty w kolumnie: {column_name}', "", icon=QMessageBox.Information)
        self.appendDataToLabel(f'Warstwa zawiera duplikaty w kolumnie: {column_name}:', self.dockwidget.label_warning)
        for duplicate_value in duplicate_values:
            self.appendDataToLabel(str(duplicate_value), self.dockwidget.label_warning)
        self.generate_csv_reports(f'Warstwa zawiera duplikaty w kolumnie: {column_name}', ["ID_STANOWISKA"],duplicate_values, "monitoring_gis_tools_raporty_kontroli", "0102_duplikaty_warstwa.csv")
        self.dockwidget.pushButton_control_duplicates.setStyleSheet('QPushButton {background-color: #ff0000}')

        # Create a list to store feature IDs with duplicate values
        duplicate_feature_ids = []

        # Iterate through features again to identify features with duplicate values
        for feature in layer.getFeatures():
            attribute_value = feature[column_index]

            # Check if the attribute value is in the list of duplicate values
            if attribute_value in duplicate_values:
                duplicate_feature_ids.append(feature.id())

        # Select duplicates
        layer.selectByIds(duplicate_feature_ids)

        # Zoom to the selected features with buffer
        box = layer.boundingBoxOfSelected()
        xmin, xmax, ymin, ymax = box.xMinimum(), box.xMaximum(), box.yMinimum(), box.yMaximum()
        xmin -= 100
        xmax += 100
        ymin -= 100
        ymax += 100
        box = QgsRectangle(xmin, ymin, xmax, ymax)
        self.iface.mapCanvas().setExtent(box)
        self.iface.mapCanvas().refresh()



    # C_0103
    def control_n2000_extent(self):

        CustomMessageBox.showInfoCustomMessageBox("Sprawdź ustawienie warstwy zasięgu siedlisk oraz prawidłowej kolumny z numerem stanowiska!"
                                                  "\n\n"
                                                  "Wygenerowane zostaną warstwy: "
                                                  "\n-płatów w obszarze N2000 (w_N2000),"
                                                  "\n-płatów poza N2000 (poza_N2000),"
                                                  "\n-płatów w i poza N2000 (w_poza_N2000),"
                                                  "\n-płatów, które przecienają się z zasięgiem N2000 (bledy_zasiegu),"
                                                  "\n\n Należy przeanalizować warstwę 'bledy_zasiegu' i skorygować dane.",
                                                  "Kontrola zasięgu płatów względem obszarów N2000",
                                         icon=QMessageBox.Information)

        # remove_map_layer
        self.removeMapLayerByName('N2000_PL')
        self.removeMapLayerByName("w_N2000")
        self.removeMapLayerByName('poza_N2000')
        self.removeMapLayerByName('w_poza_N2000')
        self.removeMapLayerByName('bledy_zasiegu')
        self.removeMapLayerByName('rezerwaty_PL')
        self.removeMapLayerByName("w_rezerwacie")
        self.removeMapLayerByName('poza_rezerwatem')
        self.removeMapLayerByName('w_poza_rezerwatem')


        self.clear_info_labels()

        #Get n2000 - layer
        dirnameOfCatalog = self.resolveDir('soo_layer')
        geopackage_path =  dirnameOfCatalog + "/N2000_PL.gpkg"

        layer = self.getLayer()
        crs = layer.crs()
        crs.createFromId(2180)
        layer.setCrs(QgsCoordinateReferenceSystem(crs))
        if not layer.isValid():
            print(f"Layer '{layer}' is not valid.")
            CustomMessageBox.showWithTimeout(10, "Warstwa jest niepoprawna...", "", icon=QMessageBox.Information)
            return False

        AtributeTableManager.removeColumnToLayerByLayerInstance(self, layer, "kod_n2000")
        field_name = self.dockwidget.comboBoxFieldsName.currentText()
        field_area_id = layer.fields().indexFromName(field_name)


        # 01 REPAIR GEOMETRY
        result = processing.run("native:fixgeometries", {'INPUT': layer, 'OUTPUT': 'memory:'})
        repair_geom_user_layer = result['OUTPUT']


        natura2000_layer = self.iface.addVectorLayer(geopackage_path, "N2000_PL", "ogr")
        if not natura2000_layer:
            print("Layer failed to load!")


        # 01 INTERSECT (COMMON PART)
        result = processing.run("native:intersection", {
            'INPUT': repair_geom_user_layer,
            'OVERLAY': natura2000_layer,
            'INPUT_FIELDS': [], 'OVERLAY_FIELDS': [], 'OVERLAY_FIELDS_PREFIX': '', 'OUTPUT': 'memory:',
            'GRID_SIZE': None})
        common_part_layer = result['OUTPUT']
        common_part_layer.setName('w_N2000')


        # 02 ROZNICA
        result = processing.run("native:difference", {
            'INPUT': repair_geom_user_layer,
            'OVERLAY': natura2000_layer,
            'OUTPUT': 'memory:',
            'GRID_SIZE': None})
        difference_layer = result['OUTPUT']
        difference_layer.setName('poza_N2000')


        # 03 MERGE
        result = processing.run("native:mergevectorlayers", {'LAYERS': [common_part_layer, difference_layer], 'CRS': None, 'OUTPUT': 'memory:'})
        merge_layer = result['OUTPUT']
        merge_layer.setName('w_poza_N2000')
        QgsProject.instance().addMapLayer(merge_layer)


        # 04 AGREGATE
        result = processing.run("native:dissolve", {
            'INPUT': merge_layer,
            'FIELD': [field_name, 'kod_n2000'], 'SEPARATE_DISJOINT': False, 'OUTPUT': 'memory:'})
        dissolve_layer = result['OUTPUT']
        dissolve_layer.setName('bledy_zasiegu')
        # 05 CALCULATE AREA
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, dissolve_layer, "AREA_HA", QVariant.Double)
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, dissolve_layer, "DUPLICATE", QVariant.Int)
        layer_provider = dissolve_layer.dataProvider()
        layer_fields = dissolve_layer.fields()
        field_area = layer_fields.indexFromName("AREA_HA")
        field_duplicate = layer_fields.indexFromName("DUPLICATE")
        features_of_layer = dissolve_layer.getFeatures()
        field_area_id = dissolve_layer.fields().indexFromName(field_name)

        for f in features_of_layer:
            id = f.id()
            feat = dissolve_layer.getFeature(id)

            # SUBAREA
            geom = f.geometry()
            area = geom.area() / 10000
            area = round(area, 2)
            attr_value_subarea = {field_area: area}
            layer_provider.changeAttributeValues({id: attr_value_subarea})
            # area_list_from_layer.append(feat[field_area_id])
            # list_of_subarea.append(area)

        # 06 FIND DUPLICATES
        # Create a dictionary to store the count of each attribute value
        attribute_count = {}
        duplicate_feature_ids = []
        # Iterate through features in the layer
        for feature in dissolve_layer.getFeatures():
            # Get the attribute value for the specified column
            attribute_value = feature[field_area_id]
            # Update the count in the dictionary
            if attribute_value in attribute_count:
                attribute_count[attribute_value] += 1
            else:
                attribute_count[attribute_value] = 1

        # Identify duplicate attribute values
        duplicate_values = [value for value, count in attribute_count.items() if count > 1]

        if len(duplicate_values) == 0:
            self.appendDataToLabel('Brak obiektów o błędnym zasięgu w odniesieniu do obszarów Natura 2000', self.dockwidget.label_info)
            CustomMessageBox.showWithTimeout(5, 'Brak obiektów o błędnym zasięgu w odniesieniu do obszarów Natura 2000', "", icon=QMessageBox.Information)
            self.generate_csv_reports(f'Brak obiektów o błędnym zasięgu w odniesieniu do obszarów Natura 2000', ["ID_STANOWISKA"], duplicate_values, "monitoring_gis_tools_raporty_kontroli", "0103_bledny_zasieg_N2000_OK.csv")
            self.dockwidget.pushButton_control_n2000_extent.setStyleSheet('QPushButton {background-color: #3cb371}')

        else:
            CustomMessageBox.showWithTimeout(5, 'Warstwa zawiera obiekty o błędnym zasięgu w odniesieniu do obszarów Natura 2000', "", icon=QMessageBox.Information)
            self.appendDataToLabel('Warstwa zawiera obiekty o błędnym zasięgu w odniesieniu do obszarów Natura 2000', self.dockwidget.label_warning)
            for duplicate_value in duplicate_values:
                self.appendDataToLabel(str(duplicate_value), self.dockwidget.label_warning)
            self.generate_csv_reports('Warstwa zawiera obiekty o błędnym zasięgu w odniesieniu do obszarów Natura 2000', ["ID_STANOWISKA"],duplicate_values, "monitoring_gis_tools_raporty_kontroli", "0103_bledny_zasieg_N2000.csv")
            self.dockwidget.pushButton_control_n2000_extent.setStyleSheet('QPushButton {background-color: #ff0000}')

        # Iterate through features again to identify features with duplicate values
        for feature in dissolve_layer.getFeatures():
            attribute_value = feature[field_area_id]
            id = feature.id()

            # Check if the attribute value is in the list of duplicate values
            if attribute_value in duplicate_values:
                attr_value_duplicates = {field_duplicate: 1}
                layer_provider.changeAttributeValues({id: attr_value_duplicates})
                duplicate_feature_ids.append(feature.id())

        # Select duplicates
        # dissolve_layer.selectByIds(duplicate_feature_ids)
        dissolve_layer.selectByExpression("DUPLICATE IS null")

        # Remove the selected features
        dissolve_layer.startEditing()
        dissolve_layer.deleteSelectedFeatures()
        dissolve_layer.commitChanges()

        # Clear the selection
        dissolve_layer.removeSelection()

        # Create a dictionary to store the smallest area for each unique NR_PLATU
        smallest_areas = {}

        # Iterate through features in the layer
        for feature in dissolve_layer.getFeatures():
            nr_platu = feature[self.dockwidget.comboBoxFieldsName.currentText()]
            area = feature['AREA_HA']

            # If NR_PLATU is not in the dictionary or the current area is smaller than the stored one
            if nr_platu not in smallest_areas or area < smallest_areas[nr_platu][0]:
                smallest_areas[nr_platu] = (area, feature.id())

        # Select only the features with the smallest area for each NR_PLATU
        selected_feature_ids = []
        for nr_platu, (smallest_area, feature_id) in smallest_areas.items():
            selected_feature_ids.append(feature_id)

        # Deselect all features
        dissolve_layer.removeSelection()

        # Select the features with the smallest area
        dissolve_layer.selectByIds(selected_feature_ids)

        # Inverse the selection
        dissolve_layer.invertSelection()

        # Remove the selected features (i.e., the ones with larger areas)
        dissolve_layer.startEditing()
        dissolve_layer.deleteSelectedFeatures()
        dissolve_layer.commitChanges()

        QgsProject.instance().addMapLayer(common_part_layer)
        QgsProject.instance().addMapLayer(difference_layer)
        QgsProject.instance().addMapLayer(dissolve_layer)

    # C_0104
    def control_nat_reserve_extent(self):

        CustomMessageBox.showInfoCustomMessageBox("Sprawdź ustawienie warstwy zasięgu siedlisk oraz prawidłowej kolumny z numerem stanowiska!"
                                                  "\n\n"
                                                    "Wygenerowane zostaną warstwy: "
                                                  "\n-płatów w zasięgu rezerwatów (w_rezerwacie),"
                                                  "\n-płatów poza rezerwatem (poza_rezerwatem),"
                                                  "\n-płatów w i poza rezerwatem (w_poza_rezerwatem),"
                                                  "\n-płatów, które przecienają się z zasięgiem rezerwatów (bledy_zasiegu),"
                                                  "\n\n Należy przeanalizować warstwę 'bledy_zasiegu' i skorygować dane.",
                                                  "Kontrola zasięgu płatów względem rezerwatów przyrody",
                                         icon=QMessageBox.Information)

        # remove_map_layer
        self.removeMapLayerByName('N2000_PL')
        self.removeMapLayerByName("w_N2000")
        self.removeMapLayerByName('poza_N2000')
        self.removeMapLayerByName('w_poza_N2000')
        self.removeMapLayerByName('bledy_zasiegu')
        self.removeMapLayerByName('rezerwaty_PL')
        self.removeMapLayerByName("w_rezerwacie")
        self.removeMapLayerByName('poza_rezerwatem')
        self.removeMapLayerByName('w_poza_rezerwatem')

        self.clear_info_labels()

        #Get n2000 - layer
        dirnameOfCatalog = self.resolveDir('rez_layer')
        geopackage_path =  dirnameOfCatalog + "/rezerwaty_PL.gpkg"

        layer = self.getLayer()
        crs = layer.crs()
        crs.createFromId(2180)
        layer.setCrs(QgsCoordinateReferenceSystem(crs))
        if not layer.isValid():
            print(f"Layer '{layer}' is not valid.")
            CustomMessageBox.showWithTimeout(10, "Warstwa jest niepoprawna...", "", icon=QMessageBox.Information)
            return False

        field_name = self.dockwidget.comboBoxFieldsName.currentText()
        field_area_id = layer.fields().indexFromName(field_name)

        # 01 REPAIR GEOMETRY
        result = processing.run("native:fixgeometries", {'INPUT': layer, 'OUTPUT': 'memory:'})
        repair_geom_user_layer = result['OUTPUT']

        reserve_layer = self.iface.addVectorLayer(geopackage_path, "rezerwaty_PL", "ogr")
        reserve_layer.setCrs(QgsCoordinateReferenceSystem(crs))
        if not reserve_layer:
            print("Layer failed to load!")

        # 01 INTERSECT (COMMON PART)
        result = processing.run("native:intersection", {
            'INPUT': repair_geom_user_layer,
            'OVERLAY': reserve_layer,
            'INPUT_FIELDS': [], 'OVERLAY_FIELDS': [], 'OVERLAY_FIELDS_PREFIX': '', 'OUTPUT': 'memory:',
            'GRID_SIZE': None})
        common_part_layer = result['OUTPUT']
        common_part_layer.setName('w_rezerwacie')
        QgsProject.instance().addMapLayer(common_part_layer)

        # 02 ROZNICA
        result = processing.run("native:difference", {
            'INPUT': repair_geom_user_layer,
            'OVERLAY': reserve_layer,
            'OUTPUT': 'memory:',
            'GRID_SIZE': None})
        difference_layer = result['OUTPUT']
        difference_layer.setName('poza_rezerwatem')
        QgsProject.instance().addMapLayer(difference_layer)

        # 03 MERGE
        result = processing.run("native:mergevectorlayers", {'LAYERS': [common_part_layer, difference_layer], 'CRS': None, 'OUTPUT': 'memory:'})
        merge_layer = result['OUTPUT']
        merge_layer.setName('w_poza_rezerwatem')
        QgsProject.instance().addMapLayer(merge_layer)

        # 04 AGREGATE
        result = processing.run("native:dissolve", {
            'INPUT': merge_layer,
            'FIELD': [field_name, 'rez_przyr'], 'SEPARATE_DISJOINT': False, 'OUTPUT': 'memory:'})
        dissolve_layer = result['OUTPUT']
        dissolve_layer.setName('bledy_zasiegu')
        QgsProject.instance().addMapLayer(dissolve_layer)

        # 05 CALCULATE AREA
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, dissolve_layer, "AREA_HA", QVariant.Double)
        AtributeTableManager.addNewColumnToLayerByLayerInstance(self, dissolve_layer, "DUPLICATE", QVariant.Int)
        layer_provider = dissolve_layer.dataProvider()
        layer_fields = dissolve_layer.fields()
        field_area = layer_fields.indexFromName("AREA_HA")
        field_duplicate = layer_fields.indexFromName("DUPLICATE")
        features_of_layer = dissolve_layer.getFeatures()
        field_area_id = dissolve_layer.fields().indexFromName(field_name)

        for f in features_of_layer:
            id = f.id()
            feat = dissolve_layer.getFeature(id)

            # SUBAREA
            geom = f.geometry()
            area = geom.area() / 10000
            area = round(area, 2)
            attr_value_subarea = {field_area: area}
            layer_provider.changeAttributeValues({id: attr_value_subarea})
            # area_list_from_layer.append(feat[field_area_id])
            # list_of_subarea.append(area)

        # 06 FIND DUPLICATES
        # Create a dictionary to store the count of each attribute value
        attribute_count = {}
        duplicate_feature_ids = []
        # Iterate through features in the layer
        for feature in dissolve_layer.getFeatures():
            # Get the attribute value for the specified column
            attribute_value = feature[field_area_id]
            # Update the count in the dictionary
            if attribute_value in attribute_count:
                attribute_count[attribute_value] += 1
            else:
                attribute_count[attribute_value] = 1

        # Identify duplicate attribute values
        duplicate_values = [value for value, count in attribute_count.items() if count > 1]

        if len(duplicate_values) == 0:
            self.appendDataToLabel('Brak obiektów o błędnym zasięgu w odniesieniu do rezerwatów', self.dockwidget.label_info)
            CustomMessageBox.showWithTimeout(5, 'Brak obiektów o błędnym zasięgu w odniesieniu do rezerwatów', "", icon=QMessageBox.Information)
            self.generate_csv_reports(f'Brak obiektów o błędnym zasięgu w odniesieniu do rezerwatów', ["ID_STANOWISKA"], duplicate_values, "monitoring_gis_tools_raporty_kontroli", "0104_bledny_zasieg_rererwaty_OK.csv")
            self.dockwidget.pushButton_control_nat_reserve_extent.setStyleSheet('QPushButton {background-color: #3cb371}')

        else:
            CustomMessageBox.showWithTimeout(5, 'Warstwa zawiera obiekty o błędnym zasięgu w odniesieniu do rezerwatów przyrody', "", icon=QMessageBox.Information)
            self.appendDataToLabel('Warstwa zawiera obiekty o błędnym zasięgu w odniesieniu do rezerwatów przyrody', self.dockwidget.label_warning)
            for duplicate_value in duplicate_values:
                self.appendDataToLabel(str(duplicate_value), self.dockwidget.label_warning)
            self.generate_csv_reports('Warstwa zawiera obiekty o błędnym zasięgu w odniesieniu do rezerwatów przyrody', ["ID_STANOWISKA"],duplicate_values, "monitoring_gis_tools_raporty_kontroli", "0104_bledny_zasieg_rererwaty.csv")
            self.dockwidget.pushButton_control_nat_reserve_extent.setStyleSheet('QPushButton {background-color: #ff0000}')

        # Iterate through features again to identify features with duplicate values
        for feature in dissolve_layer.getFeatures():
            attribute_value = feature[field_area_id]
            id = feature.id()

            # Check if the attribute value is in the list of duplicate values
            if attribute_value in duplicate_values:
                attr_value_duplicates = {field_duplicate: 1}
                layer_provider.changeAttributeValues({id: attr_value_duplicates})
                duplicate_feature_ids.append(feature.id())

        # Select duplicates
        # dissolve_layer.selectByIds(duplicate_feature_ids)
        dissolve_layer.selectByExpression("DUPLICATE IS null")

        # Remove the selected features
        dissolve_layer.startEditing()
        dissolve_layer.deleteSelectedFeatures()
        dissolve_layer.commitChanges()

        # Clear the selection
        dissolve_layer.removeSelection()

        # Create a dictionary to store the smallest area for each unique NR_PLATU
        smallest_areas = {}

        # Iterate through features in the layer
        for feature in dissolve_layer.getFeatures():
            nr_platu = feature[self.dockwidget.comboBoxFieldsName.currentText()]
            area = feature['AREA_HA']

            # If NR_PLATU is not in the dictionary or the current area is smaller than the stored one
            if nr_platu not in smallest_areas or area < smallest_areas[nr_platu][0]:
                smallest_areas[nr_platu] = (area, feature.id())

        # Select only the features with the smallest area for each NR_PLATU
        selected_feature_ids = []
        for nr_platu, (smallest_area, feature_id) in smallest_areas.items():
            selected_feature_ids.append(feature_id)

        # Deselect all features
        dissolve_layer.removeSelection()

        # Select the features with the smallest area
        dissolve_layer.selectByIds(selected_feature_ids)

        # Inverse the selection
        dissolve_layer.invertSelection()

        # Remove the selected features (i.e., the ones with larger areas)
        dissolve_layer.startEditing()
        dissolve_layer.deleteSelectedFeatures()
        dissolve_layer.commitChanges()

    # C_0105

    # def find_overlaps(self):
    #     self.clear_info_labels()
    #
    #     layer = self.getLayer()
    #     if not layer.isValid():
    #         print(f"Layer '{layer}' is not valid.")
    #         CustomMessageBox.showWithTimeout(10, "Warstwa jest niepoprawna...", "", icon=QMessageBox.Information)
    #         return False
    #
    #     AtributeTableManager.addNewColumnToLayerByLayerInstance(self, layer, "ID", QVariant.Int)
    #     AtributeTableManager.recalculateIDInColumnByLayerInstance(self, layer, "ID", 0)
    #
    #     result = processing.run("native:union",
    #                             {'INPUT': layer, 'OVERLAY': layer, 'OVERLAY_FIELDS_PREFIX': '', 'OUTPUT': 'memory:',
    #                              'GRID_SIZE': None})
    #     unionLayer = result['OUTPUT']
    #
    #     unionLayer.selectByExpression('"ID" <> "ID_2"')
    #
    #     layer.triggerRepaint()
    #     unionLayer.invertSelection()
    #     unionLayer.startEditing()
    #     unionLayer.deleteSelectedFeatures()
    #     unionLayer.commitChanges()
    #
    #     unionLayer.setName('nalozenia_overlaps')
    #     QgsProject.instance().addMapLayer(unionLayer)

    def find_overlaps(self):
        self.clear_info_labels()

        # Get the layer
        layer = self.getLayer()
        if not layer.isValid():
            print(f"Layer '{layer}' is not valid.")
            CustomMessageBox.showWithTimeout(10, "Warstwa jest niepoprawna...", "", icon=QMessageBox.Information)
            return False

        # Create a new memory layer to store overlaps
        overlaps_layer = QgsVectorLayer("MultiPolygon?crs=epsg:2180", "Nakładki_overlaps", "memory")

        # Start editing the new layer
        overlaps_layer.startEditing()

        # Delete all existing fields (if any) and add a new field for area in hectares
        overlaps_layer_data_provider = overlaps_layer.dataProvider()
        overlaps_layer_data_provider.addAttributes([QgsField("area", QVariant.Double)])
        overlaps_layer.updateFields()

        # Function to handle adding intersection geometries to the overlaps layer
        def add_intersections_to_layer(intersection_geometry, attributes):
            if intersection_geometry.wkbType() == QgsWkbTypes.GeometryCollection:
                for sub_geometry in intersection_geometry.asGeometryCollection():
                    if sub_geometry.wkbType() in [QgsWkbTypes.Polygon, QgsWkbTypes.MultiPolygon]:
                        new_feature = QgsFeature()
                        new_feature.setGeometry(sub_geometry)
                        new_feature.setAttributes([sub_geometry.area()])  # Area in hectares
                        overlaps_layer.addFeature(new_feature)
            elif intersection_geometry.wkbType() in [QgsWkbTypes.Polygon, QgsWkbTypes.MultiPolygon]:
                new_feature = QgsFeature()
                new_feature.setGeometry(intersection_geometry)
                new_feature.setAttributes([intersection_geometry.area()])  # Area in hectares
                overlaps_layer.addFeature(new_feature)

        # Create a progress dialog
        total_features = layer.featureCount()
        progress_dialog = QProgressDialog("Szukam nakładek...", "Cancel", 0, total_features)
        progress_dialog.setWindowModality(Qt.WindowModal)
        progress_dialog.show()

        # Loop through each feature
        feature_ids = list(layer.allFeatureIds())
        for index, feature1_id in enumerate(feature_ids):
            feature1 = layer.getFeature(feature1_id)

            # Update progress
            progress_dialog.setValue(index)
            if progress_dialog.wasCanceled():
                break

            # Get the geometry of feature 1
            geometry1 = feature1.geometry()

            # Check for self-overlaps within the same feature
            if geometry1.isMultipart():
                geometries1 = geometry1.asGeometryCollection()
                for i in range(len(geometries1)):
                    for j in range(i + 1, len(geometries1)):
                        if geometries1[i].intersects(geometries1[j]):
                            intersection_geometry = geometries1[i].intersection(geometries1[j])
                            add_intersections_to_layer(intersection_geometry, feature1.attributes())
            else:
                if geometry1.intersects(geometry1):
                    intersection_geometry = geometry1.intersection(geometry1)
                    add_intersections_to_layer(intersection_geometry, feature1.attributes())

            # Loop through the remaining features
            for feature2_id in feature_ids[index + 1:]:
                feature2 = layer.getFeature(feature2_id)
                # Get the geometry of feature 2
                geometry2 = feature2.geometry()

                # Iterate through parts if it's a multipart geometry
                if geometry2.isMultipart():
                    geometries2 = geometry2.asGeometryCollection()
                else:
                    geometries2 = [geometry2]

                # Check for overlap between parts of both geometries
                for part1 in (geometry1.asGeometryCollection() if geometry1.isMultipart() else [geometry1]):
                    for part2 in geometries2:
                        if part1.intersects(part2):
                            intersection_geometry = part1.intersection(part2)
                            add_intersections_to_layer(intersection_geometry, feature1.attributes())

        # Commit changes to the new layer
        overlaps_layer.commitChanges()

        # Add the new layer to the project
        QgsProject.instance().addMapLayer(overlaps_layer)

        qml_path = self.resolveDir('qml_styles') + "/overlaps.qml"  # Update this to the path of your QML file
        overlaps_layer.loadNamedStyle(qml_path)
        overlaps_layer.triggerRepaint()

        # Ensure the progress dialog reaches 100%
        progress_dialog.setValue(total_features)

    def find_gaps(self, cluster_tolerance=0.001):
        self.clear_info_labels()

        # Get the layer
        layer = self.getLayer()
        if not layer.isValid():
            print(f"Layer '{layer}' is not valid.")
            CustomMessageBox.showWithTimeout(10, "Warstwa jest niepoprawna...", "", icon=QMessageBox.Information)
            return False

        # Create a new memory layer to store gap points
        gaps_layer = QgsVectorLayer("Point?crs=epsg:2180", "Szczeliny_gaps", "memory")

        # Start editing the new layer
        gaps_layer.startEditing()

        # Add fields to the new layer
        fields = [QgsField("id", QVariant.Int), QgsField("cluster_tolerance", QVariant.Double),
                  QgsField("area", QVariant.Double)]
        gaps_layer_data_provider = gaps_layer.dataProvider()
        gaps_layer_data_provider.addAttributes(fields)
        gaps_layer.updateFields()

        # Get the map units of the layer's CRS
        crs_map_units = layer.crs().mapUnits()

        # Convert the cluster tolerance to the units of the layer's CRS map units
        if crs_map_units != QgsUnitTypes.DistanceMeters:
            cluster_tolerance = QgsUnitTypes.convertMeasurement(cluster_tolerance, QgsUnitTypes.UnitType(0),
                                                                crs_map_units)


        # Create a progress dialog
        total_features = layer.featureCount()
        progress_dialog = QProgressDialog("Szukam szczelin...", "Cancel", 0, total_features)
        progress_dialog.setWindowModality(Qt.WindowModal)
        progress_dialog.show()

        # Collect all geometries to union them
        geometries = []
        for index, feature in enumerate(layer.getFeatures()):
            # Update progress
            progress_dialog.setValue(index)
            QCoreApplication.processEvents()  # Process GUI events
            if progress_dialog.wasCanceled():
                break
            geometries.append(feature.geometry())

        # Perform union of all geometries
        if not geometries:
            return False

        union_geometry = geometries[0]
        for geometry in geometries[1:]:
            union_geometry = union_geometry.combine(geometry)

        # Get the bounding box of the union geometry
        bbox = union_geometry.boundingBox()
        bbox_polygon = QgsGeometry.fromRect(bbox)

        # Subtract the union geometry from the bounding box to find gaps
        gaps_geometry = bbox_polygon.difference(union_geometry)

        # Function to add gap centroids to the gaps layer with cluster tolerance and area attributes
        def add_gap_centroids_to_layer(geometry):
            if geometry.isMultipart():
                for sub_geometry in geometry.asGeometryCollection():
                    if sub_geometry.wkbType() in [QgsWkbTypes.Polygon, QgsWkbTypes.MultiPolygon]:
                        if sub_geometry.area() < cluster_tolerance:
                            continue
                        centroid = sub_geometry.centroid()
                        if centroid.isEmpty():
                            continue
                        new_feature = QgsFeature()
                        new_feature.setGeometry(centroid)
                        new_feature.setAttributes([1, cluster_tolerance, sub_geometry.area()])  # Set attributes
                        gaps_layer.addFeature(new_feature)
            elif geometry.wkbType() in [QgsWkbTypes.Polygon, QgsWkbTypes.MultiPolygon]:
                if geometry.area() < cluster_tolerance:
                    return
                centroid = geometry.centroid()
                if centroid.isEmpty():
                    return
                new_feature = QgsFeature()
                new_feature.setGeometry(centroid)
                new_feature.setAttributes([1, cluster_tolerance, geometry.area()])  # Set attributes
                gaps_layer.addFeature(new_feature)

        # Add the centroids of the gaps to the gaps layer
        add_gap_centroids_to_layer(gaps_geometry)

        # Commit changes to the new layer
        gaps_layer.commitChanges()

        # Apply QML style to the gaps layer
        qml_path = self.resolveDir('qml_styles') + "/gaps.qml"  # Update this to the path of your QML file
        gaps_layer.loadNamedStyle(qml_path)
        gaps_layer.triggerRepaint()

        QgsProject.instance().addMapLayer(gaps_layer)

    def break_multiparts_and_filter(self, area_threshold=0.01):
        self.clear_info_labels()

        # Get the layer
        layer = self.getLayer()
        if not layer.isValid():
            CustomMessageBox.showWithTimeout(10, "Warstwa jest niepoprawna...", "", icon=QMessageBox.Information)
            return False

        # Create a new memory layer to store the filtered polygons
        filtered_layer = QgsVectorLayer("Polygon?crs=epsg:2180", "Poligony poniżej 0,01ha", "memory")

        # Start editing the new layer
        filtered_layer.startEditing()

        # Add fields to the new layer
        fields = [QgsField("id", QVariant.Int), QgsField("area_ha", QVariant.Double)]
        filtered_layer_data_provider = filtered_layer.dataProvider()
        filtered_layer_data_provider.addAttributes(fields)
        filtered_layer.updateFields()

        # Create a progress dialog
        total_features = layer.featureCount()
        progress_dialog = QProgressDialog("Szukam małych poligonów...", "Cancel", 0, total_features)
        progress_dialog.setWindowModality(Qt.WindowModal)
        progress_dialog.show()

        # Process each feature in the input layer
        for index, feature in enumerate(layer.getFeatures()):
            # Update progress
            progress_dialog.setValue(index)
            if progress_dialog.wasCanceled():
                break

            geometry = feature.geometry()
            if geometry.isMultipart():
                for part in geometry.asMultiPolygon():
                    for polygon in part:
                        area = QgsGeometry.fromPolygonXY(
                            [polygon]).area() / 10000  # Convert area from square meters to hectares
                        if area <= area_threshold:
                            new_feature = QgsFeature()
                            new_feature.setGeometry(QgsGeometry.fromPolygonXY([polygon]))
                            new_feature.setAttributes([feature.id(), area])
                            filtered_layer.addFeature(new_feature)
            else:
                area = geometry.area() / 10000  # Convert area from square meters to hectares
                if area <= area_threshold:
                    new_feature = QgsFeature()
                    new_feature.setGeometry(geometry)
                    new_feature.setAttributes([feature.id(), area])
                    filtered_layer.addFeature(new_feature)

        # Commit changes to the new layer
        filtered_layer.commitChanges()

        # Add the new layer to the project
        QgsProject.instance().addMapLayer(filtered_layer)

        # Finalize progress dialog
        progress_dialog.setValue(total_features)

        return True

    def calculate_distance_between_polygon_parts(self):
        # Get the selected field name
        field_name = self.dockwidget.comboBoxFieldsName.currentText()

        # Get the layer
        layer = self.getLayer()
        if not layer.isValid():
            CustomMessageBox.showWithTimeout(10, "Warstwa jest niepoprawna...", "", icon=QMessageBox.Information)
            return False

        # Create a new memory layer to store the results
        result_layer = QgsVectorLayer("Polygon?crs=epsg:2180", "Odległości części multipoigonów", "memory")

        # Start editing the new layer
        result_layer.startEditing()

        # Add fields to the new layer
        fields = [QgsField("feature_id", QVariant.Int), QgsField("odleglosc", QVariant.Double),
                  QgsField(field_name, QVariant.String)]
        result_layer_data_provider = result_layer.dataProvider()
        result_layer_data_provider.addAttributes(fields)
        result_layer.updateFields()

        # Create a progress dialog
        total_features = layer.featureCount()
        progress_dialog = QProgressDialog("Obliczam odległości...", "Cancel", 0, total_features)
        progress_dialog.setWindowModality(Qt.WindowModal)
        progress_dialog.show()

        # Process each feature in the input layer
        for index, feature in enumerate(layer.getFeatures()):
            # Update progress
            progress_dialog.setValue(index)
            if progress_dialog.wasCanceled():
                break

            # Get the value of the selected field
            field_value = feature[field_name]

            # Extract multipolygon geometry
            geometry = feature.geometry()
            if geometry.isMultipart():
                # Group parts by their multipolygon number
                parts_by_number = {}
                for part in geometry.asMultiPolygon():
                    polygon = QgsGeometry.fromPolygonXY(part)  # No need for extra list
                    parts_by_number.setdefault(field_value, []).append(polygon)

                # Calculate distances within each group
                for part_list in parts_by_number.values():
                    for i, polygon1 in enumerate(part_list):
                        min_distance = float('inf')
                        for j, polygon2 in enumerate(part_list):
                            if i != j:
                                distance = polygon1.distance(polygon2)
                                min_distance = min(min_distance, distance)
                        # Check if the distance is neither 0 nor "inf"
                        if min_distance != 0 and min_distance != float('inf'):
                            # Create a new feature with the minimum distance
                            new_feature = QgsFeature()
                            new_feature.setGeometry(polygon1)
                            new_feature.setAttributes([feature.id(), min_distance, field_value])  # Include field value
                            result_layer.addFeature(new_feature)
            else:
                # Single part polygon, so no need for distance calculation
                min_distance = 0
                new_feature = QgsFeature()
                new_feature.setGeometry(geometry)
                new_feature.setAttributes([feature.id(), min_distance, field_value])  # Include field value
                result_layer.addFeature(new_feature)

        # Commit changes to the new layer
        result_layer.commitChanges()

        # Add the new layer to the project
        QgsProject.instance().addMapLayer(result_layer)

        # Finalize progress dialog
        progress_dialog.setValue(total_features)

        return True

    def select_control_models_by_error_code(self, error_code: str) -> List[ControlModel]:

        self.clear_info_labels()

        # Dbase address
        d_base = str(self.dockwidget.lineEdit_dBase_directory.text()).replace('\\', '/')

        # Clear warning massage
        self.dockwidget.label_warning.setText("")

        # check if base exist
        if not (str(d_base)):
            self.dockwidget.label_warning.setText("Nie wskazano bazy danych!")
            return False

        # Declare connections
        conn = sqlite3.connect(d_base)

        cur = conn.cursor()
        cur.execute(
            "SELECT * FROM sl_kontrola WHERE kontrola_cd=?",
            (error_code,))

        rows = cur.fetchall()

        control_models = []
        for row in rows:
            control_model = ControlModel(
                area_id=0,
                year=2024,
                error_code=row[0],
                error_name=row[1],
                error_poz_name=row[2],
                error_description=row[3],
                warning_flag=row[4],
                error_status_flag=0,
                error_query=row[5]
            )
            control_models.append(control_model)

        return control_models

    def get_error_result_by_error_code(self, error_code):
        # ADD report
        self.clearPlainTextEditInfo()

        # 01 Get list of areas
        list_of_areas = self.getListOfAreaByQuery("SELECT DISTINCT stanowisko_nr, rok FROM stanowisko_rok")
        if not list_of_areas:
            print("No areas found")
            return

        # Print list of areas to debug
        # print("List of Areas:", list_of_areas)

        # Dbase address
        d_base = self.get_dBase_directory()
        if not d_base:
            print("Database directory not found")
            return

        # Declare connections
        conn = sqlite3.connect(d_base)
        cur = conn.cursor()

        # 02 Get sql query from 'sl_kontole'
        query = ""
        controll_name = ""
        code_desc = ""

        try:
            cur.execute("SELECT kwerenda, kontrola_nm, kod_opis FROM sl_kontrola WHERE kontrola_cd=?", (error_code,))
            rows = cur.fetchall()

            if not rows:
                print("No control found for the given error code")
                return

            for row in rows:
                query = row[0]
                controll_name = row[1]
                code_desc = row[2]

            if not query:
                print("Query is empty")
                return

            list_of_failed_areas = []

            for data in list_of_areas:
                if isinstance(data, tuple) and len(data) == 2:
                    stanowisko_nr, rok = data
                else:
                    stanowisko_nr = data
                    rok = self.selected_year

                # print(f"Executing query for stanowisko_nr: {stanowisko_nr}, rok: {rok}")

                # Print the query and parameters to debug
                # print(f"Query: {query}")
                # print(f"Parameters: ({stanowisko_nr}, {rok})")

                # Count the number of placeholders in the query
                num_placeholders = query.count('?')

                try:
                    if num_placeholders == 2:
                        cur.execute(query, (stanowisko_nr, rok))
                    elif num_placeholders == 1:
                        cur.execute(query, (stanowisko_nr,))
                    else:
                        # print(f"Unexpected number of placeholders ({num_placeholders}) in query: {query}")
                        return

                    rows = cur.fetchall()
                    if rows:
                        # print(f"Failed areas for stanowisko_nr: {stanowisko_nr}, rok: {rok}: {rows}")
                        for row in rows:
                            list_of_failed_areas.append(row[0])
                except sqlite3.OperationalError as e:
                    print(f"SQLite error: {e}")

            if len(list_of_failed_areas) > 0:
                self.appendDataToPlainTextEdit("", self.dockwidget.plainTextEdit_info)
                self.appendDataToPlainTextEdit(controll_name, self.dockwidget.plainTextEdit_info)
                for data_dbase in list_of_failed_areas:
                    self.appendDataToPlainTextEdit(str(data_dbase), self.dockwidget.plainTextEdit_info)
                self.generate_csv_reports_second(controll_name, code_desc, ["ID_STANOWISKA"], list_of_failed_areas,
                                                 "monitoring_gis_tools_raporty_kontroli",
                                                 f"Kontrola_numer_{error_code}.csv")
                button_name = f'pushButton{error_code}'
                button = getattr(self.dockwidget, button_name)
                button.setStyleSheet('QPushButton {background-color: #ff0000}')
            else:
                self.appendDataToPlainTextEdit(f"Kontrola {error_code} przebiegła pomyślnie",
                                               self.dockwidget.plainTextEdit_info)
                self.generate_csv_reports_second(controll_name, code_desc, ["ID_STANOWISKA"], list_of_failed_areas,
                                                 "monitoring_gis_tools_raporty_kontroli",
                                                 f"Kontrola_numer_{error_code}_OK.csv")
                button_name = f'pushButton{error_code}'
                button = getattr(self.dockwidget, button_name)
                button.setStyleSheet('QPushButton {background-color: #3cb371}')
        finally:
            conn.close()  # Make sure to close the database connection


    def get_control_results_for_all_areas(self, error_code, area_id_parameter_only):
        control_models = []
        list_of_failed_areas = []

        d_base = self.get_dBase_directory()
        if not d_base:
            return False

        conn = sqlite3.connect(d_base)

        year = self.selected_year  # Assuming selected_year is defined somewhere in your class

        try:
            cursor = conn.cursor()

            # Fetch all area IDs from stanowisko_rok table
            cursor.execute("SELECT stanowisko_nr FROM stanowisko_rok")
            area_ids = cursor.fetchall()

            for area_id_tuple in area_ids:
                area_id = area_id_tuple[0]

                error_name = None
                error_poz_name = None
                error_description = None
                warning_flag = 0
                error_status_flag = 0
                error_query = None

                # Fetch error details from sl_kontrola table based on error_code
                cursor.execute("SELECT kontrola_nm, kontrola_poz_nm, kod_opis, ostrzezenie_fl, kwerenda FROM sl_kontrola WHERE kontrola_cd = ?", (error_code,))
                row = cursor.fetchone()
                if row:
                    error_name, error_poz_name, error_description, warning_flag, error_query = row

                    # Execute error_query to check for error status in the specific area
                    if area_id_parameter_only:
                        if error_query:
                            cursor.execute(error_query, (error_code, area_id))  # Adjusted to pass both error_code and area_id
                    else:
                        if error_query:
                            cursor.execute(error_query, (error_code, area_id, year))  # Adjusted to pass error_code, area_id, and year

                    if cursor.fetchone():
                        error_status_flag = 1
                        list_of_failed_areas.append(area_id)

                    # Create ControlModel instance and append to control_models list
                    control_model = ControlModel(area_id, year, error_code, error_name, error_poz_name, error_description,
                                                 warning_flag, error_status_flag, error_query)
                    control_models.append(control_model)

            # Display results and generate reports
            if len(list_of_failed_areas) > 0:
                self.appendDataToPlainTextEdit("", self.dockwidget.plainTextEdit_info)
                self.appendDataToPlainTextEdit(error_name, self.dockwidget.plainTextEdit_info)
                for data_dbase in list_of_failed_areas:
                    self.appendDataToPlainTextEdit(str(data_dbase), self.dockwidget.plainTextEdit_info)
                # Generate CSV report for failed areas
                self.generate_csv_reports_second(error_name, error_description, ["ID_STANOWISKA"], list_of_failed_areas,
                                                 "monitoring_gis_tools_raporty_kontroli",
                                                 f"Kontrola_numer_{error_code}.csv")
                # Change button color (assuming GUI-specific functionality)
                button_name = f'pushButton{error_code}'
                button = getattr(self.dockwidget, button_name)
                button.setStyleSheet('QPushButton {background-color: #ff0000}')
            else:
                self.appendDataToPlainTextEdit(f"Kontrola {error_code} przebiegła pomyślnie",
                                               self.dockwidget.plainTextEdit_info)
                # Generate CSV report for successful control
                self.generate_csv_reports_second(error_name, error_description, ["ID_STANOWISKA"], list_of_failed_areas,
                                                 "monitoring_gis_tools_raporty_kontroli",
                                                 f"Kontrola_numer_{error_code}_OK.csv")
                # Change button color (assuming GUI-specific functionality)
                button_name = f'pushButton{error_code}'
                button = getattr(self.dockwidget, button_name)
                button.setStyleSheet('QPushButton {background-color: #3cb371}')

        except sqlite3.Error as e:
            print(f"Database operation error: {e}")
        finally:
            if 'cursor' in locals():
                cursor.close()
            conn.close()

        return control_models

    def get_site_year_model(self, area_id):
        site_year_model = None
        db = None
        cursor = None
        d_base = self.get_dBase_directory()
        if not d_base:
            return False
        year = self.selected_year
        query = """
        SELECT 
            stanowisko_nr, 
            rok, 
            kontrola_fl, 
            rezygnacja_fl, 
            uzasadnienie_rezygnacji, 
            wartosci_przyrodnicze, 
            uwagi, 
            opis_stanowiska, 
            opis_siedliska, 
            zarzadzajacy_terenem, 
            data_oceny, 
            ocena_cd, 
            komentarz_ocena_stanu_ochrony, 
            x, 
            y, 
            z, 
            z_min, 
            z_max, 
            powierzchnia,
            
        FROM 
            stanowisko_rok
        WHERE 
            stanowisko_nr = ? AND rok = ?;
        """
        # można dołożyć po "powierzchnia" jak bedziesz chciał rozkminiać bląd-uwaga
        # 'status_code_placeholder' as status_code,  -- Replace with the actual status code column if it exists
        # 0 as warnings_number,  -- Replace with the actual warnings number column if it exists
        # 0 as errors_number  -- Replace with the actual errors number column if it exists

        try:
            db = sqlite3.connect(d_base)
            cursor = db.cursor()
            cursor.execute(query, (area_id, year))

            row = cursor.fetchone()
            if row:
                site_year_model = SiteYearModel(
                    area_id=row[0],
                    year=row[1],
                    controll_flag=row[2],
                    resignation_flag=row[3],
                    cause_of_resignation=row[4],
                    nature_values=row[5],
                    comments=row[6],
                    site_description=row[7],
                    habitat_description=row[8],
                    owner=row[9],
                    date_of_controll=row[10],
                    general_assessmnent=row[11],
                    general_assessmnent_comments=row[12],
                    x_coord=row[13],
                    y_coord=row[14],
                    z_coord=row[15],
                    z_min=row[16],
                    z_max=row[17],
                    site_area=row[18],
                    status_code=row[19],
                    warnings_number=row[20],
                    errors_number=row[21]
                )
        except Exception as e:
            self.dockwidget.plainTextEdit_info.appendPlainText(f"Database Operation Error: Method: get_site_year_model: {e}")
        finally:
            if cursor:
                cursor.close()
            if db:
                db.close()

        return site_year_model

    def get_site_year_date_of_controll_model(self, area_id):
        site_year_date_of_controll_model = None
        db = None
        cursor = None
        d_base = self.get_dBase_directory()
        if not d_base:
            return False
        year = self.selected_year
        query = """
        SELECT 
            stanowisko_nr, 
            rok, 
            data_oceny, 
            availability,
            description
        FROM 
            stanowisko_rok
        WHERE 
            stanowisko_nr = ? AND rok = ?;
        """

        try:
            db = sqlite3.connect(d_base)
            cursor = db.cursor()
            cursor.execute(query, (area_id, year))

            row = cursor.fetchone()
            if row:
                site_year_date_of_controll_model = SiteYearDateOfControllModel(
                    area_id=row[0],
                    year=row[1],
                    date_of_controll=row[2],
                    availability=row[3],
                    description=row[4]
                )
        except Exception as e:
            self.dockwidget.plainTextEdit_info.appendPlainText(f"Database Operation Error: Method: get_site_year_date_of_controll_model: {e}")
        finally:
            if cursor:
                cursor.close()
            if db:
                db.close()

        return site_year_date_of_controll_model

    #  !!!
    # W tym przykładzie wywołania masz print, który wywala Ci cały zebrany słownik danych i informacji
    # def run2_control_30100(self):
    #     results = self.get_control_results_for_all_areas(30100, True)
    #     for result in results:
    #         self.appendDataToPlainTextEdit(f"Control Model: {result.__dict__}", self.dockwidget.plainTextEdit_info)
    # !!!

    # Metody kontroli -dodawane po opracowaniu SQL dla WebMonitoring

    # Kontrole danych ogólnych
    # 10001
    def run_control_10001(self):
        self.get_error_result_by_error_code(10001)

    # 10002
    def run_control_10002(self):
        self.get_error_result_by_error_code(10002)

    # 10005
    def run_control_10005(self):
        self.get_error_result_by_error_code(10005)

    # 10010
    def run_control_10010(self):
        self.get_error_result_by_error_code(10010)

    # 10020
    def run_control_10020(self):
        self.get_error_result_by_error_code(10020)

    # 10100
    def run_control_10100(self):
        self.get_error_result_by_error_code(10100)

    # 10101
    def run_control_10101(self):
        self.get_error_result_by_error_code(10101)

    # 10102
    def run_control_10102(self):
        self.get_error_result_by_error_code(10102)

    # 10200
    def run_control_10200(self):
        self.get_error_result_by_error_code(10200)

    # 10201
    def run_control_10201(self):
        self.get_error_result_by_error_code(10201)

    # 10210
    def run_control_10210(self):
        self.get_error_result_by_error_code(10210)

    # 10211
    def run_control_10211(self):
        self.get_error_result_by_error_code(10211)

    # 10220
    def run_control_10220(self):
        self.get_error_result_by_error_code(10220)

    # 10221
    def run_control_10221(self):
        self.get_error_result_by_error_code(10221)

    # 10230
    def run_control_10230(self):
        self.get_error_result_by_error_code(10230)

    # 10231
    def run_control_10231(self):
        self.get_error_result_by_error_code(10231)

    # 10240
    def run_control_10240(self):
        self.get_error_result_by_error_code(10240)

    # 10250
    def run_control_10250(self):
        self.get_error_result_by_error_code(10250)

    # 10251
    def run_control_10251(self):
        self.get_error_result_by_error_code(10251)

    # 10252
    def run_control_10252(self):
        self.get_error_result_by_error_code(10252)

    # 10260
    def run_control_10260(self):
        self.get_error_result_by_error_code(10260)

    # 10270
    def run_control_10270(self):
        self.get_error_result_by_error_code(10270)

    # 10271
    def run_control_10271(self):
        self.get_error_result_by_error_code(10271)

    # 10280
    def run_control_10280(self):
        self.get_error_result_by_error_code(10280)

    # 10281
    def run_control_10281(self):
        self.get_error_result_by_error_code(10281)

    # 10282
    def run_control_10282(self):
        self.get_error_result_by_error_code(10282)

    # 10290
    def run_control_10290(self):
        self.get_error_result_by_error_code(10290)

    # 10300
    def run_control_10300(self):
        self.get_error_result_by_error_code(10300)

    def complex_control_general_data(self):
        self.clearPlainTextEditInfo()
        # 10001
        self.run_control_10001()
        # 10002
        self.run_control_10002()
        # 10005
        self.run_control_10005()
        # 10010
        self.run_control_10010()
        # 10020
        self.run_control_10020()
        # 10100
        self.run_control_10100()
        # 10101
        self.run_control_10101()
        # 10102
        self.run_control_10102()
        # 10200
        self.run_control_10200()
        # 10201
        self.run_control_10201()
        # 10210
        self.run_control_10210()
        # 10211
        self.run_control_10211()
        # 10220
        self.run_control_10220()
        # 10221
        self.run_control_10221()
        # 10230
        self.run_control_10230()
        # 10231
        self.run_control_10231()
        # 10240
        self.run_control_10240()
        # 10250
        self.run_control_10250()
        # 10251
        self.run_control_10251()
        # 10252
        self.run_control_10252()
        # 10260
        self.run_control_10260()
        # 10270
        self.run_control_10270()
        # 10271
        self.run_control_10271()
        # 10280
        self.run_control_10280()
        # 10281
        self.run_control_10281()
        # 10282
        self.run_control_10282()
        # 10290
        self.run_control_10290()
        # 10300
        self.run_control_10300()
        self.dockwidget.plainTextEdit_info.setPlainText("Wyniki kontroli zostały zapisane w lokalizacji bazy danych")
        self.dockwidget.pushButtonK10000.setStyleSheet('QPushButton {background-color: #b7eced}')

    # Kontrole ocen
    # 30100
    def run_control_30100(self):
        self.get_error_result_by_error_code(30100)

    # 30101
    def run_control_30101(self):
        self.get_error_result_by_error_code(30101)

    # 30102
    def run_control_30102(self):
        self.get_error_result_by_error_code(30102)

    # 30150
    def run_control_30150(self):
        self.get_error_result_by_error_code(30150)

    # 30200
    def run_control_30200(self):
        self.get_error_result_by_error_code(30200)

    # 30201
    def run_control_30201(self):
        self.get_error_result_by_error_code(30201)

    # 30210
    def run_control_30210(self):
        self.get_error_result_by_error_code(30210)

    # 30211
    def run_control_30211(self):
        self.get_error_result_by_error_code(30211)

    # 30212
    def run_control_30212(self):
        self.get_error_result_by_error_code(30212)

    # 30220
    def run_control_30220(self):
        self.get_error_result_by_error_code(30220)

    # 30221
    def run_control_30221(self):
        self.get_error_result_by_error_code(30221)

    # 30222
    def run_control_30222(self):
        self.get_error_result_by_error_code(30222)

    # 30230
    def run_control_30230(self):
        self.get_error_result_by_error_code(30230)

    # 30231
    def run_control_30231(self):
        self.get_error_result_by_error_code(30231)

    # 30232
    def run_control_30232(self):
        self.get_error_result_by_error_code(30232)

    # 30500
    def run_control_30500(self):
        self.get_error_result_by_error_code(30500)

    # 30501
    def run_control_30501(self):
        self.get_error_result_by_error_code(30501)

    # 30502
    def run_control_30502(self):
        self.get_error_result_by_error_code(30502)

    # Kompleksowa kontrola oceny 30000

    def complex_control_ratings(self):
        self.clearPlainTextEditInfo()
        # 30100
        self.run_control_30100()
        # 30101
        self.run_control_30101()
        # 30102
        self.run_control_30102()
        # 30150
        self.run_control_30150()
        # 30200
        self.run_control_30200()
        # 30201
        self.run_control_30201()
        # 30210
        self.run_control_30210()
        # 30211
        self.run_control_30211()
        # 30212
        self.run_control_30212()
        # 30220
        self.run_control_30220()
        # 30221
        self.run_control_30221()
        # 30222
        self.run_control_30222()
        # 30230
        self.run_control_30230()
        # 30231
        self.run_control_30231()
        # 30232
        self.run_control_30232()
        # 30500
        self.run_control_30500()
        # 30501
        self.run_control_30501()
        # 30502
        self.run_control_30502()
        self.dockwidget.plainTextEdit_info.setPlainText("Wyniki kontroli zostały zapisane w lokalizacji bazy danych")
        self.dockwidget.pushButtonK30000.setStyleSheet('QPushButton {background-color: #b7eced}')

    # Kontrole zdjęć fito
    # 20000
    def run_control_20000(self):
        self.get_error_result_by_error_code(20000)
    # 20001
    def run_control_20001(self):
        self.get_error_result_by_error_code(20001)
    # 20002
    def run_control_20002(self):
        self.get_error_result_by_error_code(20002)
    # 20003
    def run_control_20003(self):
        self.get_error_result_by_error_code(20003)
    # 20004
    def run_control_20004(self):
        self.get_error_result_by_error_code(20004)
    # 20005
    def run_control_20005(self):
        self.get_error_result_by_error_code(20005)
    # 20006
    def run_control_20006(self):
        self.get_error_result_by_error_code(20006)
    # 20010
    def run_control_20010(self):
        self.get_error_result_by_error_code(20010)
    # 20020
    def run_control_20020(self):
        self.get_error_result_by_error_code(20020)

    def complex_control_phytoreleves(self):
        self.clearPlainTextEditInfo()
        # 20000
        self.run_control_20000()
        # 20001
        self.run_control_20001()
        # 20002
        self.run_control_20002()
        # 20003
        self.run_control_20003()
        # 20004
        self.run_control_20004()
        # 20005
        self.run_control_20005()
        # 20006
        self.run_control_20006()
        # 20010
        self.run_control_20010()
        # 20020
        self.run_control_20020()
        self.dockwidget.plainTextEdit_info.setPlainText("Wyniki kontroli zostały zapisane w lokalizacji bazy danych")
        self.dockwidget.pushButtonK20000.setStyleSheet('QPushButton {background-color: #b7eced}')


    # Kontrole oddziaływań, zagrożeń, działań
    # 10500
    def run_control_10500(self):
        self.get_error_result_by_error_code(10500)
    # 10501
    def run_control_10501(self):
        self.get_error_result_by_error_code(10501)
    # 10502
    def run_control_10502(self):
        self.get_error_result_by_error_code(10502)
    # 10600
    def run_control_10600(self):
        self.get_error_result_by_error_code(10600)
    # 10601
    def run_control_10601(self):
        self.get_error_result_by_error_code(10601)
    # 10602
    def run_control_10602(self):
        self.get_error_result_by_error_code(10602)
    # 10700
    def run_control_10700(self):
        self.get_error_result_by_error_code(10700)
    # 10701
    def run_control_10701(self):
        self.get_error_result_by_error_code(10701)
    # 10702
    def run_control_10702(self):
        self.get_error_result_by_error_code(10702)
    # 10703
    def run_control_10703(self):
        self.get_error_result_by_error_code(10703)
    # 10704
    def run_control_10704(self):
        self.get_error_result_by_error_code(10704)
    # 10705
    def run_control_10705(self):
        self.get_error_result_by_error_code(10705)

    def complex_control_threats(self):
        self.clearPlainTextEditInfo()
        # 10500
        self.run_control_10500()
        # 10501
        self.run_control_10501()
        # 10502
        self.run_control_10502()
        # 10600
        self.run_control_10600()
        # 10601
        self.run_control_10601()
        # 10602
        self.run_control_10602()
        # 10700
        self.run_control_10700()
        # 10701
        self.run_control_10701()
        # 10702
        self.run_control_10702()
        # 10703
        self.run_control_10703()
        # 10704
        self.run_control_10704()
        # 10705
        self.run_control_10705()
        self.dockwidget.plainTextEdit_info.setPlainText("Wyniki kontroli zostały zapisane w lokalizacji bazy danych")
        self.dockwidget.pushButtonK10500.setStyleSheet('QPushButton {background-color: #b7eced}')





    # C_0301  C_03011 C_03012 C_03013
    def compatibilyty_check_tools(self):

        # Clear info labels
        self.clear_info_labels()

        # Dbase address
        d_base = str(self.dockwidget.lineEdit_dBase_directory.text()).replace('\\', '/')

        # check if base exist
        if not (str(d_base)):
            self.dockwidget.label_warning.setText("Nie wskazano bazy danych!")
            return False

        # Declare connections
        conn = sqlite3.connect(d_base)
        cursor = conn.cursor()

        cursor.execute("SELECT stanowisko_nr FROM stanowisko_rok;")
        rows = cursor.fetchall()

        layer = self.dockwidget.mMapLayerComboBoxAraesPolygon.currentLayer()

        if not (layer):
            self.dockwidget.label_warning.setText("Nie wskazano warstwy!")
            return False


        ara_list_from_dBase = []
        area_list_from_layer = []
        field_name = self.dockwidget.comboBoxFieldsName.currentText()
        field_area_id = layer.fields().indexFromName(field_name)
        #Exist in dbase, not exist in layer
        exist_in_both = []
        exist_id_dbase = []
        exist_is_layer = []

        for row in rows:
            ara_list_from_dBase.append(row[0])


        for f in layer.getFeatures():
            id = f.id()
            feat = layer.getFeature(id)
            area_list_from_layer.append(int(feat[field_area_id]))



        for data_dbase in  ara_list_from_dBase:
            if data_dbase in area_list_from_layer:
                exist_in_both.append(data_dbase)
            else:
                exist_id_dbase.append(data_dbase)

        for data_layer in area_list_from_layer:
            if data_layer not in ara_list_from_dBase:
                exist_is_layer.append(data_layer)

        self.appendDataToLabel("Raporty kontroli (*.csv): " + self.get_file_directory() + "/monitoring_gis_tools_raporty_kontroli", self.dockwidget.label_info)

        self.appendDataToLabel("", self.dockwidget.label_info)
        self.appendDataToLabel("Powierzchnie istniejące zarówno w warstwie i w bazie danych:", self.dockwidget.label_info)
        print("Powierzchnie istniejące w warstwie i w bazie:")
        for data in exist_in_both:
            self.appendDataToLabel(str(data), self.dockwidget.label_info)
            print(str(data))
        self.generate_csv_reports("Powierzchnie istniejące zarówno w warstwie i w bazie danych", ["ID_STANOWISKA"], exist_in_both, "monitoring_gis_tools_raporty_kontroli", "03011_wykaz_powierzchni_zgodnych_mapa_baza.csv")



        self.appendDataToLabel("", self.dockwidget.label_warning)
        self.appendDataToLabel("Powierzchnie istniejące w bazie danych a nie istniejące w warstwie:", self.dockwidget.label_warning)
        print("Powierzchnie istniejące wyłącznie w bazie danych:")
        for data in exist_id_dbase:
            self.appendDataToLabel(str(data), self.dockwidget.label_warning)
            print(str(data))
        self.generate_csv_reports("Powierzchnie istniejące w bazie danych a nie istniejące w warstwie", ["ID_STANOWISKA"], exist_id_dbase, "monitoring_gis_tools_raporty_kontroli","03012_wykaz_powierzchni_isnt_wylacznie_w_bazie.csv")


        self.appendDataToLabel("", self.dockwidget.label_warning)
        self.appendDataToLabel("Powierzchnie istniejące w warstwie a nie istniejące w bazie danych:", self.dockwidget.label_warning)
        print("Powierzchnie istniejące wyłącznie w warstwie:")
        for data in exist_is_layer:
            self.appendDataToLabel(str(data), self.dockwidget.label_warning)
            print(str(data))
        self.generate_csv_reports("Powierzchnie istniejące w warstwie a nie istniejące w bazie danych", ["ID_STANOWISKA"], exist_is_layer, "monitoring_gis_tools_raporty_kontroli","03013_wykaz_powierzchni_isnt_wylacznie_w_warstwie.csv")


        if exist_is_layer or exist_id_dbase:
            self.dockwidget.pushButton_compatibilyty.setStyleSheet('QPushButton {background-color: #ff0000}')
        else:
            self.dockwidget.pushButton_compatibilyty.setStyleSheet('QPushButton {background-color: #3cb371}')

    def check_pictures(self):
        self.clearPlainTextEditInfo()

        # Get the input layer
        layer = self.getLayer()
        if not layer.isValid():
            message = "Warstwa jest niepoprawna."
            print(message)
            self.dockwidget.plainTextEdit_info.appendPlainText(message)
            return False

        # Get the folder path from the line edit
        folder_path = self.dockwidget.lineEdit_picture_directory.text()
        if not os.path.exists(folder_path):
            message = "Ścieżka folderu ze zdjęciami jest niepoprawna."
            self.dockwidget.plainTextEdit_info.appendPlainText(message)
            return False

        # Get the column name from the combo box and find the index
        column_name = self.dockwidget.comboBoxFieldsName.currentText()
        column_index = layer.fields().indexFromName(column_name)
        if column_index == -1:
            message = f"Nie znaleziono kolumny: {column_name}"
            self.dockwidget.plainTextEdit_info.appendPlainText(message)
            return False

        # Create a progress dialog
        total_features = layer.featureCount()
        progress_dialog = QProgressDialog("Sprawdzanie zdjęć...", "Cancel", 0, total_features)
        progress_dialog.setWindowModality(Qt.WindowModal)
        progress_dialog.show()

        # Loop through each feature
        missing_pictures = []
        for index, feature in enumerate(layer.getFeatures()):
            # Update progress
            progress_dialog.setValue(index)
            if progress_dialog.wasCanceled():
                break

            # Get the 10-digit number from the feature using the column index
            number = feature[column_index]

            # Find pictures that start with the 10-digit number
            matching_pictures = [file for file in os.listdir(folder_path) if file.startswith(str(number))]

            # Check if there are at least two pictures
            if len(matching_pictures) < 2:
                missing_pictures.append((number, len(matching_pictures)))

        # Ensure the progress dialog reaches 100%
        progress_dialog.setValue(total_features)

        # Show results in plainTextEdit_info
        if missing_pictures:
            message = "Niektóre płaty mają mniej niż dwa zdjęcia:\n"
            for number, count in missing_pictures:
                message += f"Numer płatu: {number}, Liczba zdjęć: {count}\n"
            self.dockwidget.plainTextEdit_info.appendPlainText(message)
        else:
            message = "Wszystkie płaty mają co najmniej dwa zdjęcia."
            self.dockwidget.plainTextEdit_info.appendPlainText(message)

        return True

    @staticmethod
    def get_exif_data(image):
        """Returns a dictionary from the exif data of an PIL Image item. Also converts the GPS Tags."""
        exif_data = {}
        info = image._getexif()
        if info:
            for tag, value in info.items():
                decoded = TAGS.get(tag, tag)
                if decoded == "GPSInfo":
                    gps_data = {}
                    for t in value:
                        sub_decoded = GPSTAGS.get(t, t)
                        gps_data[sub_decoded] = value[t]
                    exif_data[decoded] = gps_data
                else:
                    exif_data[decoded] = value
        return exif_data

    @staticmethod
    def convert_to_degrees(value):
        """Helper function to convert the GPS coordinates stored in the EXIF to degrees in float format"""
        d, m, s = value
        d = float(d)
        m = float(m)
        s = float(s)
        return d + (m / 60.0) + (s / 3600.0)

    def get_lat_lon(self, exif_data):
        """Returns the latitude and longitude, if available, from the provided exif_data (obtained through get_exif_data above)"""
        if "GPSInfo" in exif_data:
            gps_info = exif_data["GPSInfo"]
            gps_lat = gps_info.get("GPSLatitude")
            gps_lat_ref = gps_info.get("GPSLatitudeRef")
            gps_lon = gps_info.get("GPSLongitude")
            gps_lon_ref = gps_info.get("GPSLongitudeRef")

            if gps_lat and gps_lon and gps_lat_ref and gps_lon_ref:
                lat = self.convert_to_degrees(gps_lat)
                if gps_lat_ref != "N":
                    lat = 0 - lat

                lon = self.convert_to_degrees(gps_lon)
                if gps_lon_ref != "E":
                    lon = 0 - lon

                return lat, lon
        return None, None

    def check_geotags_and_generate_shapefile(self):
        self.clearPlainTextEditInfo()

        # Get the input layer
        layer = self.getLayer()
        if not layer.isValid():
            message = "Warstwa jest nieprawidłowa."
            self.dockwidget.plainTextEdit_info.appendPlainText(message)
            return False

        # Get the folder path from the line edit
        folder_path = self.dockwidget.lineEdit_picture_directory.text()
        if not os.path.exists(folder_path):
            message = "Ścieżka folderu ze zdjęciami jest nieprawidłowa."
            self.dockwidget.plainTextEdit_info.appendPlainText(message)
            return False

        # Get the column name from the combo box and find the index
        column_name = self.dockwidget.comboBoxFieldsName.currentText()
        column_index = layer.fields().indexFromName(column_name)
        if column_index == -1:
            message = f"Kolumna nie znaleziona: {column_name}"
            self.dockwidget.plainTextEdit_info.appendPlainText(message)
            return False

        # Check if the field 'il_zdj' already exists in the layer, if not add it
        if not layer.fields().indexFromName("il_zdj") >= 0:
            layer.startEditing()
            layer.addAttribute(QgsField("il_zdj", QVariant.Int))
            layer.updateFields()
            layer.commitChanges()

        # Create a progress dialog
        total_features = layer.featureCount()
        progress_dialog = QProgressDialog("Sprawdzam geotagi...", "Cancel", 0, total_features)
        progress_dialog.setWindowModality(Qt.WindowModal)
        progress_dialog.show()

        # Define CRS for input layer (EPSG:2180) and WGS84 (EPSG:4326)
        crs_input = QgsCoordinateReferenceSystem('EPSG:2180')
        crs_wgs84 = QgsCoordinateReferenceSystem('EPSG:4326')

        # Coordinate transformation context
        transform_context = QgsProject.instance().transformContext()

        # Dictionary to count pictures per feature ID
        picture_count_per_feature = {}

        # Create a temporary layer to store picture locations with EPSG:2180
        picture_layer = QgsVectorLayer("Point?crs=epsg:2180", "Lokalizacja zdjęć", "memory")
        picture_layer_data_provider = picture_layer.dataProvider()
        picture_layer_data_provider.addAttributes([
            QgsField("PictureName", QVariant.String),
            QgsField("FeatureID", QVariant.String),
            QgsField("Latitude", QVariant.Double),
            QgsField("Longitude", QVariant.Double),
        ])
        picture_layer.updateFields()

        # Count of features with one or zero pictures
        features_with_one_or_zero_pictures = 0

        # List to keep track of pictures without geotags
        pictures_without_geotags = []

        # Loop through each feature
        issues_found = []
        for index, feature in enumerate(layer.getFeatures()):
            # Update progress
            progress_dialog.setValue(index)
            if progress_dialog.wasCanceled():
                break

            # Get the 10-digit number from the feature using the column index
            number = feature[column_index]
            geometry = feature.geometry()

            # Initialize count for current feature ID
            if number not in picture_count_per_feature:
                picture_count_per_feature[number] = 0

            # Find pictures that start with the 10-digit number
            matching_pictures = [file for file in os.listdir(folder_path) if file.startswith(str(number))]

            for picture in matching_pictures:
                picture_path = os.path.join(folder_path, picture)
                try:
                    # Read image and extract geotags
                    image = Image.open(picture_path)
                    exif_data = MonitoringTools.get_exif_data(image)  # Corrected static method call
                    lat, lon = MonitoringTools.get_lat_lon(self, exif_data)  # Corrected method call

                    if lat is not None and lon is not None:
                        # Transform picture coordinates from EPSG:4326 to EPSG:2180
                        point_wgs84 = QgsPointXY(lon, lat)
                        point = QgsPointXY(lon, lat)
                        transform = QgsCoordinateTransform(crs_wgs84, crs_input, transform_context)
                        transformed_point = transform.transform(point)

                        point_geometry = QgsGeometry.fromPointXY(transformed_point)

                        # Check if picture location intersects with feature geometry
                        if not geometry.contains(point_geometry):
                            issues_found.append((number, picture, lat, lon))

                        # Add picture location to the temporary layer
                        picture_feature = QgsFeature()
                        picture_feature.setGeometry(point_geometry)
                        picture_feature.setAttributes([picture, number, lat, lon])
                        picture_layer_data_provider.addFeature(picture_feature)

                        # Increment picture count for current feature ID
                        picture_count_per_feature[number] += 1
                    else:
                        # Log pictures without geotags
                        pictures_without_geotags.append(picture)

                except Exception as e:
                    self.dockwidget.plainTextEdit_info.appendPlainText(f"Błąd odczytu zdjęcia {picture}: {str(e)}")

            # Check if the feature has one or zero pictures
            if picture_count_per_feature[number] <= 1:
                features_with_one_or_zero_pictures += 1

        # Ensure the progress dialog reaches 100%
        progress_dialog.setValue(total_features)

        # Update il_zdj field for each feature in the input layer
        layer.startEditing()
        for feature in layer.getFeatures():
            feature_id = feature[column_name]
            if feature_id in picture_count_per_feature:
                num_pictures = picture_count_per_feature[feature_id]
                feature["il_zdj"] = num_pictures
                layer.updateFeature(feature)

        layer.commitChanges()

        # Add the new layer to the project
        QgsProject.instance().addMapLayer(picture_layer)

        # Show results in plainTextEdit_info
        if issues_found:
            message = "Miejsce wykonania niektórych zdjęć nie pokrywa się z korespondującym płatem:\n"
            for number, picture, lat, lon in issues_found:
                message += f"Numer płatu: {number}, Zdjęcie: {picture}, Lat: {lat}, Lon: {lon}\n"
            self.dockwidget.plainTextEdit_info.appendPlainText(message)
        else:
            message = "Lokalizacje istniejących zdjęć są prawidłowe."
            self.dockwidget.plainTextEdit_info.appendPlainText(message)

        # Add message about features with one or zero pictures
        message = f"Ilość płatów z jednym lub bez zdjęć: {features_with_one_or_zero_pictures}"
        self.dockwidget.plainTextEdit_info.appendPlainText(message)

        # Add message about pictures without geotags
        if pictures_without_geotags:
            message = "Zdjęcia bez geotagów:\n"
            for picture in pictures_without_geotags:
                message += f"{picture}\n"
            self.dockwidget.plainTextEdit_info.appendPlainText(message)

        return True

    def generate_picture_report(self):
        self.clearPlainTextEditInfo()

        # Get the input layer
        layer = self.getLayer()
        if not layer.isValid():
            message = "Warstwa jest nieprawidłowa."
            self.dockwidget.plainTextEdit_info.appendPlainText(message)
            return False

        # Get the folder path from the line edit
        folder_path = self.dockwidget.lineEdit_picture_directory.text()
        if not os.path.exists(folder_path):
            message = "Ścieżka folderu ze zdjęciami jest nieprawidłowa."
            self.dockwidget.plainTextEdit_info.appendPlainText(message)
            return False

        # Get the column name from the combo box and find the index
        column_name = self.dockwidget.comboBoxFieldsName.currentText()
        column_index = layer.fields().indexFromName(column_name)
        if column_index == -1:
            message = f"Kolumna nie znaleziona: {column_name}"
            self.dockwidget.plainTextEdit_info.appendPlainText(message)
            return False

        # Check if the field 'il_zdj' already exists in the layer, if not add it
        if not layer.fields().indexFromName("il_zdj") >= 0:
            layer.startEditing()
            layer.addAttribute(QgsField("il_zdj", QVariant.Int))
            layer.updateFields()
            layer.commitChanges()

        # Create a progress dialog
        total_features = layer.featureCount()
        progress_dialog = QProgressDialog("Sprawdzanie zdjęć i geotagów...", "Cancel", 0, total_features)
        progress_dialog.setWindowModality(Qt.WindowModal)
        progress_dialog.show()

        # Define CRS for input layer (EPSG:2180) and WGS84 (EPSG:4326)
        crs_input = QgsCoordinateReferenceSystem('EPSG:2180')
        crs_wgs84 = QgsCoordinateReferenceSystem('EPSG:4326')

        # Coordinate transformation context
        transform_context = QgsProject.instance().transformContext()

        # Dictionaries to count pictures per feature ID and to store issues
        picture_count_per_feature_name = {}
        picture_count_per_feature_geo = {}
        missing_pictures = []
        issues_found = []
        pictures_without_geotags = []

        # Count of features with one or zero pictures
        features_with_one_or_zero_pictures = 0

        # Loop through each feature
        for index, feature in enumerate(layer.getFeatures()):
            # Update progress
            progress_dialog.setValue(index)
            if progress_dialog.wasCanceled():
                break

            # Get the 10-digit number from the feature using the column index
            number = feature[column_index]
            geometry = feature.geometry()

            # Initialize count for current feature ID
            if number not in picture_count_per_feature_name:
                picture_count_per_feature_name[number] = 0
            if number not in picture_count_per_feature_geo:
                picture_count_per_feature_geo[number] = 0

            # Find pictures that start with the 10-digit number
            matching_pictures = [file for file in os.listdir(folder_path) if file.startswith(str(number))]

            # Check if there are at least two pictures
            if len(matching_pictures) < 2:
                missing_pictures.append((number, len(matching_pictures)))

            for picture in matching_pictures:
                picture_path = os.path.join(folder_path, picture)
                try:
                    # Read image and extract geotags
                    with Image.open(picture_path) as image:
                        exif_data = MonitoringTools.get_exif_data(image)  # Corrected static method call
                        lat, lon = MonitoringTools.get_lat_lon(self, exif_data)  # Corrected method call

                        if lat is not None and lon is not None:
                            # Transform picture coordinates from EPSG:4326 to EPSG:2180
                            point_wgs84 = QgsPointXY(lon, lat)
                            transform = QgsCoordinateTransform(crs_wgs84, crs_input, transform_context)
                            transformed_point = transform.transform(point_wgs84)

                            point_geometry = QgsGeometry.fromPointXY(transformed_point)

                            # Check if picture location intersects with feature geometry
                            if geometry.contains(point_geometry):
                                picture_count_per_feature_geo[number] += 1
                            else:
                                issues_found.append((number, picture, lat, lon))
                        else:
                            # Log pictures without geotags
                            pictures_without_geotags.append(picture)

                        # Increment picture count for current feature ID based on name
                        picture_count_per_feature_name[number] += 1

                except Exception as e:
                    self.dockwidget.plainTextEdit_info.appendPlainText(f"Błąd odczytu zdjęcia {picture}: {str(e)}")

            # Check if the feature has one or zero pictures based on name
            if picture_count_per_feature_name[number] <= 1:
                features_with_one_or_zero_pictures += 1

        # Ensure the progress dialog reaches 100%
        progress_dialog.setValue(total_features)

        # Update il_zdj field for each feature in the input layer
        layer.startEditing()
        for feature in layer.getFeatures():
            feature_id = feature[column_name]
            if feature_id in picture_count_per_feature_name:
                num_pictures = picture_count_per_feature_name[feature_id]
                feature["il_zdj"] = num_pictures
                layer.updateFeature(feature)

        layer.commitChanges()

        # Generate the report
        shapefile_name = os.path.basename(layer.source())
        report_filename_csv = os.path.join(folder_path, 'Zał 2. Wynik kontroli fotografii płatów.csv')
        try:
            with open(report_filename_csv, 'w', newline='', encoding='utf-8-sig') as csvfile:
                writer = csv.writer(csvfile, delimiter=';')
                writer.writerow([f"Nazwa shapefile: {shapefile_name}"])
                writer.writerow([f"Data raportu: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"])
                writer.writerow([])  # Empty row for separation
                writer.writerow(['Kontrola zdjęć na podstawie nazwy pliku'])
                writer.writerow(['Numer płatu', 'Liczba zdjęć', 'Opis problemu'])

                for number, count in missing_pictures:
                    writer.writerow([number, count, 'Mniej niż 2 zdjęcia'])

                # Add list of all features and how many pictures they have according to name checking
                writer.writerow([])  # Empty row for separation
                writer.writerow(['Numer płatu', 'Liczba zdjęć'])
                for number, count in picture_count_per_feature_name.items():
                    writer.writerow([number, count])

                writer.writerow([])  # Empty row for separation
                writer.writerow(['Kontrola zdjęć na podstawie geolokalizacji'])
                writer.writerow(['Numer płatu', 'Pozostała liczba zdjęć dla płatu', 'Opis problemu'])

                for number, picture, lat, lon in issues_found:
                    writer.writerow([number, picture_count_per_feature_geo[number],
                                     f'Błąd lokalizacji dla zdjęcia {picture} (Lat: {lat}, Lon: {lon})'])

                # Add list table with number of pictures according to geotag checking
                writer.writerow([])  # Empty row for separation
                writer.writerow(['Numer płatu', 'Liczba zdjęć'])
                for number, count in picture_count_per_feature_geo.items():
                    writer.writerow([number, count])

                # Add section for pictures without geotags
                writer.writerow([])  # Empty row for separation
                writer.writerow(['Zdjęcia bez geotagów'])
                writer.writerow(['Nazwa zdjęcia'])
                for picture in pictures_without_geotags:
                    writer.writerow([picture])

            self.dockwidget.plainTextEdit_info.appendPlainText("Raport wygenerowany pomyślnie.")
        except Exception as e:
            self.dockwidget.plainTextEdit_info.appendPlainText(f"Wystąpił problem z wygenerowaniem raportu: {str(e)}")

        return True

    def make_buffer_area(self):

        # Clear info labels
        self.clear_info_labels()
        self.removeMapLayerByName('polygonized_layer')

        layer = self.dockwidget.mMapLayerComboBoxAraesPolygon.currentLayer()
        additional_height = self.dockwidget.lineEdit_additional_height.text().replace(",", ".")
        reduced_height = self.dockwidget.lineEdit_reduced_height.text().replace(",", ".")

        if not (layer):
            self.dockwidget.label_warning.setText("Nie wskazano warstwy!")
            return False

        feature_to_analize = layer.selectedFeatures()

        # Create a temporary layer for the selected features
        temp_layer = QgsVectorLayer("Polygon?crs=" + layer.crs().authid(), "temp_buffer", "memory")
        temp_layer.dataProvider().addFeatures(feature_to_analize)
        # QgsProject.instance().addMapLayer(temp_layer)

        raster_layer = self.dockwidget.mMapLayerComboBox_nmt_raster.currentLayer()



        # Clip raster by selected feature
        result = processing.run("gdal:cliprasterbymasklayer", {
            'INPUT': raster_layer,
            'MASK': temp_layer,
            'SOURCE_CRS': QgsCoordinateReferenceSystem('EPSG:2180'),
            'TARGET_CRS': QgsCoordinateReferenceSystem('EPSG:2180'),
            'TARGET_EXTENT': None,
            'NODATA': None,
            'ALPHA_BAND': False,
            'CROP_TO_CUTLINE': True,
            'KEEP_RESOLUTION': False,
            'SET_RESOLUTION': False,
            'X_RESOLUTION': None,
            'Y_RESOLUTION': None,
            'MULTITHREADING': False,
            'OPTIONS': '',
            'DATA_TYPE': 0,
            'EXTRA': '',
            'OUTPUT': 'TEMPORARY_OUTPUT'})
        cut_result_raster = QgsRasterLayer(result['OUTPUT'], 'result_layer')
        # QgsProject.instance().addMapLayer(cut_result_raster)


        # Calculate statistics
        provider = cut_result_raster.dataProvider()
        ext = cut_result_raster.extent()
        stats = provider.bandStatistics(1, QgsRasterBandStats.All, ext, 0)

        self.appendDataToLabel("Minmalna wysokość: " + str(round(stats.minimumValue,2)) + " m", self.dockwidget.label_info)
        self.appendDataToLabel("Maksymalna wysokość: " + str(round(stats.maximumValue,2)) + " m", self.dockwidget.label_info)
        self.appendDataToLabel("średnia wysokość: " + str(round(stats.mean,2)) + " m", self.dockwidget.label_info)
        self.appendDataToLabel("Odchylenie standardowe: " + str(round(stats.stdDev,2)), self.dockwidget.label_info)



        # 01 Buffer of polygon to analize
        max_buffer_width = self.dockwidget.lineEdit_max_buffer_width.text()
        result = processing.run("native:buffer", {'INPUT': temp_layer, 'DISTANCE': max_buffer_width, 'SEGMENTS': 5, 'END_CAP_STYLE': 0, 'JOIN_STYLE': 0, 'MITER_LIMIT': 2,'DISSOLVE': False,'OUTPUT': 'memory:'})
        buffer_layer = result['OUTPUT']
        buffer_layer.setName('buffer')
        # QgsProject.instance().addMapLayer(buffer_layer)


        #02 Difference - ring
        result = processing.run("native:difference", {'INPUT': buffer_layer, 'OVERLAY': temp_layer, 'OUTPUT': 'memory:', 'GRID_SIZE': None})
        difference_layer = result['OUTPUT']
        difference_layer.setName('difference')
        # QgsProject.instance().addMapLayer(difference_layer)


        # 03 Cut raster by polygon
        result = processing.run("gdal:cliprasterbymasklayer", {
            'INPUT': raster_layer,
            'MASK': difference_layer,
            'SOURCE_CRS': QgsCoordinateReferenceSystem('EPSG:2180'),
            'TARGET_CRS': QgsCoordinateReferenceSystem('EPSG:2180'),
            'TARGET_EXTENT': None,
            'NODATA': None,
            'ALPHA_BAND': False,
            'CROP_TO_CUTLINE': True,
            'KEEP_RESOLUTION': False,
            'SET_RESOLUTION': False,
            'X_RESOLUTION': None,
            'Y_RESOLUTION': None,
            'MULTITHREADING': False,
            'OPTIONS': '',
            'DATA_TYPE': 0,
            'EXTRA': '',
            'OUTPUT': 'TEMPORARY_OUTPUT'})
        cut_result_raster = QgsRasterLayer(result['OUTPUT'], 'result_layer')
        # QgsProject.instance().addMapLayer(cut_result_raster)


        # 04 First seection on raster
        max_buffer_heigth = str(round(stats.mean) + float(additional_height))
        min_buffer_heigth = str(round(stats.minimumValue) + float(reduced_height))
        # expression = '(1 * (A < 10) + 1 > 50)'
        # expresion = f'((A < {max_buffer_heigth}) + (A > {round(stats.maximumValue)}))'
        # expresion = f'((A < {max_buffer_heigth}))'




        if self.dockwidget.checkBox_analize_min_heigth.isChecked():
            expresion = f'(A > {min_buffer_heigth})*(A <= {max_buffer_heigth}) * 2'
        else:
            expresion = f'((A <= {max_buffer_heigth}))'

        parameters = {'INPUT_A': cut_result_raster, 'BAND_A': 1, 'FORMULA': expresion, 'NODATAVALUE': 1, 'OUTPUT': 'TEMPORARY_OUTPUT'}
        result = processing.run('gdal:rastercalculator', parameters)  # feed in the param
        analize_result_raster = QgsRasterLayer(result['OUTPUT'], 'result_layer01')
        # QgsProject.instance().addMapLayer(analize_result_raster)


        # 06 raster to polygon
        result = processing.run("gdal:polygonize", {
            'INPUT': analize_result_raster,
            'BAND': 1, 'FIELD': 'DN', 'EIGHT_CONNECTEDNESS': False, 'EXTRA': '', 'OUTPUT': 'TEMPORARY_OUTPUT'})
        polygonized_layer = QgsVectorLayer(result['OUTPUT'], 'polygonized_layer')

        # 07 Remove 0 values

        polygonized_layer.selectByExpression("DN = 0")
        polygonized_layer.startEditing()
        polygonized_layer.deleteSelectedFeatures()
        polygonized_layer.commitChanges()
        polygonized_layer.removeSelection()

        QgsProject.instance().addMapLayer(polygonized_layer)




    def getListOfAreaByQuery(self, query):

        list = []

        # Clear info labels
        self.clear_info_labels()

        # Dbase address
        d_base = self.get_dBase_directory()
        if not d_base:
            print("Faill")
            return False

        conn = sqlite3.connect(d_base)
        cursor = conn.cursor()
        cursor.execute(query)
        rows = cursor.fetchall()
        for row in rows:
            print(row[0])
            list.append(row[0])
        return list


    def is_numeric_with_dots(self, input_str):
        # Define the regular expression pattern
        pattern = re.compile(r'^[0-9.]+$')
        # Use the search function to check if the pattern matches the input string
        match = pattern.search(input_str)
        # If a match is found, the input string contains only numeric characters and dots
        return bool(match)


    def is_numeric_and_length(self, input_str):
        # Check if the length is 10
        if len(input_str) == 10:
            # Check if all characters are digits
            if input_str.isdigit():
                return True
            else:
                return False
        else:
            return False


    def get_file_directory(self):
        # Dbase address
        d_base = str(self.dockwidget.lineEdit_dBase_directory.text()).replace('\\', '/')
        # check if base exist
        if not (str(d_base)):
            self.dockwidget.label_warning.setText("Nie wskazano bazy danych!")
            return False
        else:
            return os.path.dirname(d_base)


    def getLayer(self):
        layer = self.dockwidget.mMapLayerComboBoxAraesPolygon.currentLayer()
        if not (str(layer)):
            CustomMessageBox.showWithTimeout(10, "Nie wybrano warstwy!", "", icon=QMessageBox.Warning)
            self.dockwidget.label_warning.setText("Nie wybrano warstwy!")
            return False
        else:
            return layer


    def get_dBase_directory(self):
        # Dbase address
        d_base = str(self.dockwidget.lineEdit_dBase_directory.text()).replace('\\', '/')
        # check if base exist
        if not (str(d_base)):
            CustomMessageBox.showWithTimeout(10, "Nie wskazano bazy danych!", "", icon=QMessageBox.Warning)
            self.dockwidget.label_warning.setText("Nie wskazano bazy danych!")
            return False
        else:
            return d_base

    def generate_geom_kontr_folder(self, folder_name):
        folder_path = os.path.join(self.get_file_directory(), folder_name)
        if not os.path.exists(folder_path):
            os.makedirs(folder_path)
        return folder_path


    def generate_csv_reports(self, description, header, data,  folder_directory, report_name):

        if not os.path.exists(self.get_file_directory() + "/" + folder_directory):
            os.makedirs(self.get_file_directory() + "/" + folder_directory)

        current_date = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

        file_path = self.get_file_directory() + "/" + folder_directory + "/" + report_name

        data = [[str(item)] for item in data]

        with open(file_path, 'w', encoding='cp1250', newline='') as f:
            writer = csv.writer(f, delimiter=';')

            # write the header
            writer.writerow([description])
            writer.writerow(['Wygenerowano: ', current_date])
            writer.writerow("")
            writer.writerow(header)
            # write multiple rows
            writer.writerows(data)

    def generate_csv_reports_second(self, name, description, header, data,  folder_directory, report_name):

        if not os.path.exists(self.get_file_directory() + "/" + folder_directory):
            os.makedirs(self.get_file_directory() + "/" + folder_directory)

        current_date = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

        file_path = self.get_file_directory() + "/" + folder_directory + "/" + report_name

        data = [[str(item)] for item in data]

        with open(file_path, 'w', encoding='cp1250', newline='') as f:
            writer = csv.writer(f, delimiter=';')

            # write the header
            writer.writerow([name])
            writer.writerow([description])
            writer.writerow(['Wygenerowano: ', current_date])
            writer.writerow("")
            writer.writerow(header)
            # write multiple rows
            writer.writerows(data)

    def repair_geometry_and_resave(input_path, output_path):
        # Load the input vector layer
        input_layer = QgsVectorLayer(input_path, 'input_layer', 'ogr')

        # Check if the layer is loaded successfully
        if not input_layer.isValid():
            print(f'Error: The input layer {input_path} failed to load!')
            return

        # Run the "native:fixgeometries" algorithm to repair geometry
        feedback = QgsProcessingFeedback()
        params = {'INPUT': input_layer, 'OUTPUT': 'memory:'}
        result = processing.run("native:fixgeometries", params, feedback=feedback)

        # Check if the algorithm ran successfully
        if result['OUTPUT'] is None:
            print('Error: Geometry repair failed!')
            return

        # Save the repaired layer to a new file
        repaired_layer = result['OUTPUT']
        QgsVectorFileWriter.writeAsVectorFormat(repaired_layer, output_path, 'utf-8', None, 'ESRI Shapefile')

        print(f'Repaired geometry saved to {output_path}')


    def removeMapLayerByName(self, layer_name_to_remove):

        root = QgsProject.instance().layerTreeRoot()
        for layer in root.children():
            layerName = str(layer.name())
            if layerName == str(layer_name_to_remove):
                layerByName = QgsProject.instance().mapLayersByName(layerName)[0]
                QgsProject.instance().removeMapLayer(layerByName.id())



    #--------------------------------------------------------------------------
    def run(self):
        """Run method that loads and starts the plugin"""



        if not self.pluginIsActive:
            self.pluginIsActive = True


            #print "** STARTING MonitoringTools"

            # dockwidget may not exist if:
            #    first run of plugin
            #    removed on close (see self.onClosePlugin method)
            if self.dockwidget == None:
                # Create the dockwidget (after translation) and keep reference
                self.dockwidget = MonitoringToolsDockWidget()

            # connect to provide cleanup on closing of dockwidget
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            def install_package(package_name, whl_path):
                try:
                    __import__(package_name)
                except ImportError:
                    subprocess.check_call([sys.executable, '-m', 'pip', 'install', whl_path])

            def resolve_external_packages():
                dir_of_external_packages_whl = self.resolveDir("python_package_external")

                # Ensure pip is installed
                try:
                    import pip
                except ImportError:
                    get_pip_path = os.path.join(dir_of_external_packages_whl.replace("\\", "/"), 'get-pip.py')
                    with open(get_pip_path, 'r') as f:
                        exec(f.read())
                    import pip

                # Install Geopandas
                install_package('geopandas',
                                os.path.join(dir_of_external_packages_whl, 'geopandas-0.14.4-py3-none-any.whl'))

                # Install Shapely
                install_package('shapely',
                                os.path.join(dir_of_external_packages_whl, 'shapely-2.0.4-cp312-cp312-win_amd64.whl'))

                # Install PyODBC
                install_package('pyodbc',
                                os.path.join(dir_of_external_packages_whl, 'pyodbc-4.0.32-cp27-cp27m-win_amd64.whl'))

            resolve_external_packages()

            self.comboBoxAraesPolygonSelectAction()

            # Populate year combo box
            self.populate_year_combobox()

            # Connect the combo box signal to update the selected year
            self.dockwidget.comboBoxYear.currentIndexChanged.connect(self.update_selected_year)

            # Odświeżanie ostatnio wykorzystanych ścieżek
            self.dBaseDirectoryLoad()
            self.pictureFolderDirectoryLoad()

            # Actions button click
            self.dockwidget.pushButton_select_dBase.clicked.connect(self.selectDbaseDirectory)
            self.dockwidget.pushButton_select_picture.clicked.connect(self.selectPictureDirectory)
            self.dockwidget.pushButton_generate_point_layer.clicked.connect(self.generatePointLayer)
            self.dockwidget.pushButton_compatibilyty.clicked.connect(self.compatibilyty_check_tools)
            self.dockwidget.pushButtonNumerationValidatingLayer.clicked.connect(self.numeration_validating_map)


            # T_0101
            self.dockwidget.pushButton_rewrite_area_to_dbase.clicked.connect(self.rewrite_area_to_dbase)

            # T_0103
            self.dockwidget.pushButton_add_coordinates_to_d_base.clicked.connect(self.add_coordinates_to_dbase)

            # T_0104
            self.dockwidget.pushButton_correct_compatibility.clicked.connect(self.corect_compatibility)

            # T_0105
            self.dockwidget.pushButton_asign_n2000_to_dbase.clicked.connect(self.asign_n2000_to_dbase)

            # T_0106
            self.dockwidget.pushButton_repair_geometryset_crs.clicked.connect(self.repair_geometry_cet_crs)

            # T_0107
            self.dockwidget.pushButton_round_geometry.clicked.connect(self.round_geometry)

            # Snap
            self.dockwidget.pushButton_snaptool.clicked.connect(self.snap_vertices_to_rezerwaty)


            # T_0108
            self.dockwidget.pushButton_prepare_structure.clicked.connect(self.prepare_structure)

            # T_0109
            self.dockwidget.pushButton_asign_nature_reserve_to_dbase.clicked.connect(self.asign_nature_reserve_to_dbase)

            # Geometry check-ups
            # C_0102
            self.dockwidget.pushButton_control_duplicates.clicked.connect(self.control_duplicates)
            # C_0103
            self.dockwidget.pushButton_control_n2000_extent.clicked.connect(self.control_n2000_extent)
            # C_0104
            self.dockwidget.pushButton_control_nat_reserve_extent.clicked.connect(self.control_nat_reserve_extent)
            # C_0105
            self.dockwidget.pushButton_find_overlaps.clicked.connect(self.find_overlaps)
            # C_0106
            self.dockwidget.pushButton_find_gaps.clicked.connect(lambda: self.find_gaps())

            self.dockwidget.pushButton_small_polygons.clicked.connect(self.break_multiparts_and_filter)

            self.dockwidget.pushButton_multipart_distance.clicked.connect(self.calculate_distance_between_polygon_parts)



            # T_0301
            self.dockwidget.mMapLayerComboBox_nmt_raster.setFilters(QgsMapLayerProxyModel.RasterLayer)
            self.dockwidget.pushButton_make_buffer_area.clicked.connect(self.make_buffer_area)

            # przyciski kontroli Baza2

            # 30100
            self.dockwidget.pushButton30100.clicked.connect(self.run_control_30100)
            # 30210
            self.dockwidget.pushButton30210.clicked.connect(self.run_control_30210)
            # 30220
            self.dockwidget.pushButton30220.clicked.connect(self.run_control_30220)
            # 30230
            self.dockwidget.pushButton30230.clicked.connect(self.run_control_30230)
            # 30500
            self.dockwidget.pushButton30500.clicked.connect(self.run_control_30500)
            # 30150
            self.dockwidget.pushButton30150.clicked.connect(self.run_control_30150)
            # 30211
            self.dockwidget.pushButton30211.clicked.connect(self.run_control_30211)
            # 30221
            self.dockwidget.pushButton30221.clicked.connect(self.run_control_30221)
            # 30231
            self.dockwidget.pushButton30231.clicked.connect(self.run_control_30231)
            # 30200
            self.dockwidget.pushButton30200.clicked.connect(self.run_control_30200)
            # 30201
            self.dockwidget.pushButton30201.clicked.connect(self.run_control_30201)
            # 30501
            self.dockwidget.pushButton30501.clicked.connect(self.run_control_30501)
            # 10210
            self.dockwidget.pushButton10210.clicked.connect(self.run_control_10210)
            # 10211
            self.dockwidget.pushButton10211.clicked.connect(self.run_control_10211)
            # 10200
            self.dockwidget.pushButton10200.clicked.connect(self.run_control_10200)
            # 10201
            self.dockwidget.pushButton10201.clicked.connect(self.run_control_10201)
            # 10220
            self.dockwidget.pushButton10220.clicked.connect(self.run_control_10220)
            # 10221
            self.dockwidget.pushButton10221.clicked.connect(self.run_control_10221)
            # 10280
            self.dockwidget.pushButton10280.clicked.connect(self.run_control_10280)
            # 10101
            self.dockwidget.pushButton10101.clicked.connect(self.run_control_10101)
            # 10102
            self.dockwidget.pushButton10102.clicked.connect(self.run_control_10102)
            # 10010
            self.dockwidget.pushButton10010.clicked.connect(self.run_control_10010)
            # 10001
            self.dockwidget.pushButton10001.clicked.connect(self.run_control_10001)
            # 10002
            self.dockwidget.pushButton10002.clicked.connect(self.run_control_10002)
            # 10005
            self.dockwidget.pushButton10005.clicked.connect(self.run_control_10005)
            # 10020
            self.dockwidget.pushButton10020.clicked.connect(self.run_control_10020)
            # 10240
            self.dockwidget.pushButton10240.clicked.connect(self.run_control_10240)
            # 10230
            self.dockwidget.pushButton10230.clicked.connect(self.run_control_10230)
            # 10231
            self.dockwidget.pushButton10231.clicked.connect(self.run_control_10231)
            # 10250
            self.dockwidget.pushButton10250.clicked.connect(self.run_control_10250)
            # 10251
            self.dockwidget.pushButton10251.clicked.connect(self.run_control_10251)
            # 10252
            self.dockwidget.pushButton10252.clicked.connect(self.run_control_10252)
            # 10260
            self.dockwidget.pushButton10260.clicked.connect(self.run_control_10260)
            # 10270
            self.dockwidget.pushButton10270.clicked.connect(self.run_control_10270)
            # 10271
            self.dockwidget.pushButton10271.clicked.connect(self.run_control_10271)
            # 10290
            self.dockwidget.pushButton10290.clicked.connect(self.run_control_10290)
            # 10300
            self.dockwidget.pushButton10300.clicked.connect(self.run_control_10300)
            # 10281
            self.dockwidget.pushButton10281.clicked.connect(self.run_control_10281)
            # 20000
            self.dockwidget.pushButton20000.clicked.connect(self.run_control_20000)
            # 20001
            self.dockwidget.pushButton20001.clicked.connect(self.run_control_20001)
            # 20002
            self.dockwidget.pushButton20002.clicked.connect(self.run_control_20002)
            # 20003
            self.dockwidget.pushButton20003.clicked.connect(self.run_control_20003)
            # 20004
            self.dockwidget.pushButton20004.clicked.connect(self.run_control_20004)
            # 20005
            self.dockwidget.pushButton20005.clicked.connect(self.run_control_20005)
            # 20006
            self.dockwidget.pushButton20006.clicked.connect(self.run_control_20006)
            # 20010
            self.dockwidget.pushButton20010.clicked.connect(self.run_control_20010)
            # 20020
            self.dockwidget.pushButton20020.clicked.connect(self.run_control_20020)
            # 10500
            self.dockwidget.pushButton10500.clicked.connect(self.run_control_10500)
            # 10600
            self.dockwidget.pushButton10600.clicked.connect(self.run_control_10600)
            # 10700
            self.dockwidget.pushButton10700.clicked.connect(self.run_control_10700)
            # 30232
            self.dockwidget.pushButton30232.clicked.connect(self.run_control_30232)
            # 30212
            self.dockwidget.pushButton30212.clicked.connect(self.run_control_30212)
            # 30222
            self.dockwidget.pushButton30222.clicked.connect(self.run_control_30222)
            # 10702
            self.dockwidget.pushButton10702.clicked.connect(self.run_control_10702)
            # 10701
            self.dockwidget.pushButton10701.clicked.connect(self.run_control_10701)
            # 10703
            self.dockwidget.pushButton10703.clicked.connect(self.run_control_10703)
            # 10704
            self.dockwidget.pushButton10704.clicked.connect(self.run_control_10704)
            # 10705
            self.dockwidget.pushButton10705.clicked.connect(self.run_control_10705)
            # 10601
            self.dockwidget.pushButton10601.clicked.connect(self.run_control_10601)
            # 10602
            self.dockwidget.pushButton10602.clicked.connect(self.run_control_10602)
            # 10501
            self.dockwidget.pushButton10501.clicked.connect(self.run_control_10501)
            # 10502
            self.dockwidget.pushButton10502.clicked.connect(self.run_control_10502)
            # 30502
            self.dockwidget.pushButton30502.clicked.connect(self.run_control_30502)
            # 30101
            self.dockwidget.pushButton30101.clicked.connect(self.run_control_30101)
            # 30102
            self.dockwidget.pushButton30102.clicked.connect(self.run_control_30102)
            # 10100
            self.dockwidget.pushButton10100.clicked.connect(self.run_control_10100)
            # 10282
            self.dockwidget.pushButton10282.clicked.connect(self.run_control_10282)
            #
            # K10000
            self.dockwidget.pushButtonK10000.clicked.connect(self.complex_control_general_data)
            # K30000
            self.dockwidget.pushButtonK30000.clicked.connect(self.complex_control_ratings)
            # K20000
            self.dockwidget.pushButtonK20000.clicked.connect(self.complex_control_phytoreleves)
            # K10500
            self.dockwidget.pushButtonK10500.clicked.connect(self.complex_control_threats)

            # test
            self.dockwidget.pushButtonTest.clicked.connect(self.run2_control_30100)

            # Kointrole zdjęć
            self.dockwidget.pushButton_picture_names.clicked.connect(self.check_pictures)
            self.dockwidget.pushButton_picture_geotags.clicked.connect(self.check_geotags_and_generate_shapefile)
            self.dockwidget.pushButton_picture_raport.clicked.connect(self.generate_picture_report)



            self.dockwidget.mMapLayerComboBoxAraesPolygon.activated.connect(lambda: self.comboBoxAraesPolygonSelectAction())
            self.dockwidget.mMapLayerComboBoxAraesPolygon.layerChanged.connect(lambda: self.comboBoxAraesPolygonSelectAction())
            self.dockwidget.mMapLayerComboBoxAraesPolygon.currentIndexChanged.connect(self.comboBoxAraesPolygonSelectAction)



            # show the dockwidget
            # TODO: fix to allow choice of dock location
            self.iface.addDockWidget(Qt.RightDockWidgetArea, self.dockwidget)
            self.dockwidget.show()
